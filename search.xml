<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软件测试的方法]]></title>
    <url>%2F2018%2F09%2F07%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[### 白盒测试语句覆盖：判断覆盖： 黑盒测试等价类划分法：边界值分析法：判断表法：]]></content>
      <tags>
        <tag>-软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux环境下gdb的使用]]></title>
    <url>%2F2018%2F08%2F25%2FLinux%E7%8E%AF%E5%A2%83%E4%B8%8Bgdb%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[gdb环境搭建1.查看是否安装gdb1rpm -qa | grep gdb 如果有的话请用以下命令删除1rpm -e --nodeps+安装包名称 2.安装Texinfo文档系统1yum install ncurses-devel 3.下载gdb的安装包12wget http://ftp.gnu.org/gnu/gdb/gdb-7.6.1.tar.gz//这里建议将安装包重新放到一个新文件夹，例如/home/download 4.解压文件夹12cd /home/downloads/tar -zxvf gdb-7.6.1.tar.gz 5.生成makefile12cd /home/downloads/gdb-7.6.1./configure 6.安装12makesudo make install 7.检查1gdb -v 结果如图即成功 gdb调试常用命令启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率; 运行run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。continue （简写c ）：继续执行，到下一个断点处（或运行结束）next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。until+行号： 运行至某行，不仅仅用来跳出循环finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)quit：简记为 q ，退出gdb 设置断点break n （简写b n）:在第n行处设置断点（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）b fn1 if a＞b：条件断点设置break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_buttondelete 断点号n：删除第n个断点disable 断点号n：暂停第n个断点enable 断点号n：开启第n个断点clear 行号n：清除第n行的断点info b （info breakpoints） ：显示当前程序的断点设置情况delete breakpoints：清除所有断点： 查看源代码list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12list 函数名：将显示“函数名”所在函数的源代码，如：list mainlist ：不带参数，将接着上一次 list 命令的，输出下边的内容。 打印表达式print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。print a：将显示整数 a 的值print ++a：将把 a 中的值加1,并显示出来print name：将显示字符串 name 的值print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display awatch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch awhatis ：查询变量或函数info function： 查询函数扩展info locals： 显示当前堆栈页的所有变量 查询运行信息where/bt ：当前运行的堆栈列表；bt backtrace 显示当前调用堆栈up/down 改变堆栈显示的深度set args 参数:指定运行时的参数show args：查看设置好的参数info program： 来查看程序的是否在运行，进程号，被暂停的原因。 分割窗口layout：用于分割窗口，可以一边查看代码，一边测试：layout src：显示源代码窗口layout asm：显示反汇编窗口layout regs：显示源代码/反汇编和CPU寄存器窗口layout split：显示源代码和反汇编窗口Ctrl + L：刷新窗口]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP数据报格式]]></title>
    <url>%2F2018%2F08%2F20%2FTCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F%2F</url>
    <content type="text"><![CDATA[IP数据报IP数据报的格式能够说明IP协议都具有什么功能，IP数据报分为首部和数据两个部分，首部格式为固定长度的20字节，是所有IP数据报所都具有的。在首部的国定部分后面是一些可选部分。其长度是可变的，下图展示了IP数据报的格式，我们着重并解释其各首部字段意义。(1)版本占4位,指IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4(即Pv4)。关于以后要使用的IPv6(即版本6的IP协议)。 (2)首部长度占4位,可表示的最大十进制数值是15。请注意,首部长度字段所表示数的单位是32位字(1个32位字长是4字节)。因此,首部长度字段的最小值是5(即进制的0101),相当于IP首部长度为5×4=20字节。而当首部长度为1111时(即十进制的15),首部长度就达到最大值15个32位字长即60字节。当IP分组的首部长度不是4字节的整数倍时,必须利用最后的填充字段加以填充。因此IP数据报的数据部分永远在4字节的整数倍时开始,这样在实现IP协议时较为方便。首部长度限制为60字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是20字节(即首部长度为0101),这时不使用任何选项。 (3)区分服务古8位,用来获得更好的服务。这个字段在旧标准中叫做服务类型,但实际上一直没有被使用过。1998年IETF把这个字段改名为区分服务DS只有在使用区分服务时,这个字段才起作用在一般的情况下都不使用这个字段。 (4)总长度总长度指首部和数据之和的长度,单位为字节。总长度字段为16位,因此数据报的最大长度为216-1=65535字节。然而实际上传送这样长的数据报在现实中是极少遇到的。我们知道,在IP层下面的每一种数据链路层协议都规定了一个数据帧中的数据字段的最大长度,这称为最大送单元MTU( Maximum transfer Unit)。当一个P数据报封装成链路层的帧时,此数据报的总长度(即首部加上数据部分)一定不能超过下面的数据链路层所规定的MTU值。例如,最常用的以太网就规定其MTU值是1500字节。若所传送的数据报长度超过数据链路层的MTU值,就必须把过长的数据报进行分片处理。 (5)标识( identification)占16位。IP软件在存储器中维持一个计数器,每产生一个数据报,计数器就加1,并将此值赋给标识字段。但这个“标识”并不是序号,因为IP是无连接服务,数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时,这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报 (6)标志ag)占3位,但目前只有两位有意义。标志字段中的最低位记为MF( More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。标志字段中间的一位记为DF( Dont Fragment),意思是“不能分片”。只有当DF=0，寸才允许分片。 (7)片偏移占13位。片偏移指出:较长的分组在分片后,某片在原分组中的相对位置。也就是说,相对于用户数据字段的起点,该片从何处开始。片偏移以8个字节为偏移单位。这就是说,每个分片的长度一定是8字节(64位)的整数倍。(8)生存时间占8位,生存时间字段常用的英文缩写是 TTL(表明据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子(例如从路由器R1转发到R2,再转发到R3,然后又转发到R1),因而白白消耗网络资源。最初的设计是以秒作为TIL值的单位。每经过一个路由器时,就把TIL减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于1秒,就把TIL值减1。当TTL值减为零时,就丢弃这个数据报。然而,随着技术的进步,路由器处理数据报所需的时间不断在缩短,一般都远远小于1秒钟,后来就把TTL字段的功能改为“跳数限制”(但名称不变)。路由器在转发数据报之前就把TIL值减1。若TIL值减小到零,就丢弃这个数据报,不再转发。因此,现在TTL的单位不再是秒,而是跳数。TTL的意义是指明数据报在因特网中至多可经过多少个路由器。显然,数据报能在因特网中经过的路由器的最大数值是255。若把TTL的初始化设置为1,就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器,在被转发之前TIL值就减小到零,因而就会被这个路由器丢弃。(9)协议占8位,协议字段指出此数据报携带的数据是使用何种协议,以便使目的主机的IP层知道应将数据部分上交给哪个处理过程。常用的一些协议和相应的协议字段值如下: 协议名 ICMP IGMP IP TCP EGP IGP UDP IPV6 ESP OSPF 协议字段值 1 2 4 6 8 9 17 41 50 89 (10)首部检验和占16位。这个字段只检验数据报的首部,但不包括数据部分。这是因为数据报每经过一个路由器,路由器都要重新计算一下首部检验和(一些字段,如生存时间、标志、片偏移等都可能发生变化)。不检验数据部分可减少计算的工作量。为了进步减小计算检验和的工作量,IP首部的检验和不采用复杂的CRC检验码而采用下面的简单计算方法:在发送方,先把IP数据报首部划分为许多16位字的序列,并把检验和字段置零。反码算术运算把所有16位字相加后,将得到的和的反码写入检验和字段。接收方收到数据报后,将首部的所有16位字再使用反码算术运算相加一次。将得到的和取反码,即得出接收方检验和的计算结果。若首部未发生任何变化,则此结果必为0,于是就保留这个数据报。否则即认为出差错,并将此数据报丢弃。下图为校验和计算过程(11)源地址：占32位。(12)目的地址：占32位。 关于IP数据报的可变部分IP首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施,内容很丰富。此字段的长度可变,从1个字节到40个字节不等,取决于所选择的项目。某些选项项目只需要1个字节,它只包括1个字节的选项代码。但还有些选项需要多个字节,这些选项一个个拼接起来,中间不需要有分隔符,最后用全0的填充字段补齐成为4字节的整数倍。增加首部的可变部分是为了增加IP数据报的功能,但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用很多路由器都不考虑IP首部的选项字段,因此新的IP版本IPV6就把IP数据报的首部长度做成固定的。这里就不讨论这些选项的细节了。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selset、poll、epoll的优缺点]]></title>
    <url>%2F2018%2F08%2F16%2Fselset%E3%80%81poll%E3%80%81epoll%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%2F</url>
    <content type="text"><![CDATA[SelectSelect用来实现多路复用输入/输出模型&ensp;1.Select系统调用是用来让我们程序监视多个文件描述符的状态变化&ensp;2.程序会停在select这里等待，直到被监视文件描述符有了一个或者多个发生了状态改变； 函数原型：12#include &lt;sys/select.h&gt;int select(int nfds, fd_set* readfds,fd_set *writefds,fd_set* exceptfds,struct timeval *timeout); 1.参数ndfs是需要监视的最大的文件描述符值+1。2.rdset,wrset,exset分别对应需要检测的可读文件描述符的集合，可写文件描述符集合及异常文件描述符集合。3.参数timeout为结构timeval, 用来设置Select的等待时间。4.关于fd_set结构:其实这个结果是一个整形数组，更严格的说，它是一个位图，使用位图对应的位来表示需要监视的文件描述符。系统提供了一组fd_set调用接口，用来操作位图。 1234void FD_CLR(int fd,fd_set * set);//用来清除描述词组set中的相关fd位int FD_ISSET(int fd,fd_set * set);//用来测试描述词组set相关fd位是否为真void FD_SET(int fd, fd_set * set);//用来设置描述词组set中相关fd的位void FD_ZERO(fd_set* set);//用来清除描述词组中set的全部位 函数返回值：1.执行成功返回文件描述符的改变个数。2。如果返回0代表timewait时间超时，没有返回。3.当返回-1，出现错误。 Select的特点：1.可监控文件描述符个数sizeof(fd_set)的值 ，每个比特位表示监控一个文件描述符。2.将fd加入select监控集的同时还要使用一个数据结构array保存放到select监控集中的fd.用于返回数据与源数据比较，二是select返回会将没事发生的文件描述符删除，但每次开始select需要重新设置，扫描array取得fd最大值maxfd，用于select的第一个参数。 Select的缺点：1.每次调用select都需要手动设置fd集合，从接口使用角度来说也非常不便。2.每次调用select，都需要从用户态拷贝到内核态，这个开销在fd很大时会很大。3.每次的调用传入的select都需要在内核遍历传进来的所有fd，这个开销在fd很大时会很大。 poll123456789int poll(struct poll* fds，nfds_t nfds，int timeout);//pollfd结构struct pollfd&#123;int fd;short events;short revents; &#125; 参数说明：fds是一个poll函数监听的结构列表，每一个元素中，包含了三部分内容：文件描述符，监听的事件、返回事件的集合。ndfs表示fds数组的长度。timeout表示poll函数的超时时间，单位是毫秒（ms)。 返回值：小于0表示出错，等于0表示等待超时，大于0表示poll由于监听的文件描述符就绪而返回。 poll的优点：1.不同与select使用3个位图来表示三个fd_set的方式，poll使用一个pollfd的指针实现。2.pollfd结构包含了要监视的event和发生的envent，不再使用select参数-值传递的方式，接口使用比select更方便。3.poll并没有最大数量限制。 poll的缺点：当poll中监听的文件描述符数目增多时：1.和select一样，poll返回后，需要轮询pollfd来获取就绪的描述符。2.每次调用poll都需要把大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视描述符数量上升，其效率也会线性下降。 epollepoll是为了处理大量句柄，而对poll的改进。epoll的相关调用.1234int epoll_create(int size);//创建一个epoll句柄int epoll_creat(int size)//size常忽略int epoll_ctl(int epfd,int op ,int fd,struct epoll_event *event);//epoll的时间注册函数 其中epoll_ctl第一个参数是 epoll_creat的返回值，第二个参数表示动作，用三个宏表示，第三个参数表示要监听的fd,第四个参数是要告诉内核需要监听什么事。 1int epoll_wait(int epfd,struct epoll_evnet* events,int maxevents,int timeout ); 1.参数events是分配好的epoll_event数组。2.epoll将会把发生的时间赋值到events数组中（events不可以是空指针，内核只负责把数据复制到这个events数组中，不会去帮我们在用户态中分配内存）。3.maxevents告诉enents有多大，这个maxevents的值不能大于创建epoll_creat()时的size。4.参数timeout是超时时间。5.如果调用函数成功，返回对应I/O上已经准备好的文件描述符数目，如果返回0表示已超时，返回小于0表示函数失败。 因此使用epoll的过程就是三部曲：1.调用epoll_creat创建一个epoll句柄。2.调用epoll_ctr,将要监控的文件描述符进行注册3.调用epoll_wait,等待文件描述符就绪。 epoll的优点：1.文件描述符数目无上限。2.基于事件就绪通知方式：一旦被监听的某个文件描述符就绪，内核会采用类似于回掉函数，迅速激活文件描述符。3.维护就绪队列：当文件描述符就绪，就会被放到把内核中的一个就绪队列，这样调用epoll_wait就绪文件描述符的时候，只取队列元素即可，操作的时间复杂度是O(1)。4.内存映射机制：内核直接将就绪队列通过mmap的方式映射到用户态，避免了拷贝内存的开销。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针和引用的区别]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[指针和引用的定义指针：指针是一个变量，储存着指向变量的地址，通过对地址的解引用实现对变量的读取或者更改。引用：引用是一个变量的别名，本质上和变量是一个东西.12int *p=&amp;a;int &amp;b=a; 这里定义了一个指针p保存了a的地址，而定义了一个引用b，给a取了一个别名。a和b是一个东西在空间上占用同一个地址。 一些其他的不同１.引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。 ２.可以有const指针，但是没有const引用。 3.指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）。 4.指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化。 5.指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。 6.sizeof引用得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小。 7.指针和引用的自增(++)运算意义不一样。 8.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏。 指针值传递123456789101112131415void ptr(int *p)&#123; int a=1; p=&amp;a; cout&lt;&lt;p&lt;&lt;" "&lt;&lt;*p&lt;&lt;endl;&#125;int main(void)&#123; int *p=NULL; ptr(p); if(p!=NULL) cout&lt;&lt;"指针p为NULL"&lt;&lt;endl; system("pause");&#125; 输出：0x6fc12e 1 指针p为NULL 因为这里传递的指针也是对p的一份临时拷贝，你不能通过形参而改变实参。要解决这种问题你只能传二级指针或者传引用 1234567891011121314void ptr(int *&amp;a)&#123; int b=2; a=&amp;b; cout&lt;&lt;a&lt;&lt;" "&lt;&lt;*a&lt;&lt;endl;&#125;int main(void)&#123; int a=1; int*p=&amp;a; ptr(p); cout&lt;&lt;p&lt;&lt;" "&lt;&lt;*p&lt;&lt;endl; system("pause");&#125; 输出结果： 0x12ff44 2 0x12ff44 2]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的拥塞控制和流量控制]]></title>
    <url>%2F2018%2F08%2F10%2FTCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[TCP的的流量控制1.利用滑动窗口实现流量控制&emsp;&emsp;一般来说我们希望发送方的发送速率越高，这样数据的传输率可能就变得高一点，但是如果发送方数据传输的过快，接受方可能来不及接收，这就会造成数据的丢失。，所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接受。利用TCP的滑动窗口可以很方便的对流量进行控制 &emsp;&emsp;现在假设A向B发送消息，在连接建立时B告诉A我的接收窗口是400，因此发送方的发送窗口不能超过接收方的接受窗口的数值，注意TCP的滑动窗口是字节为单位并不是报文段，现在假设每个报文段大小为100字节。并且数据段报文序号初始值为1。&emsp;&emsp;我们因该注意到上图接受主机进行了3次流量控制，第一次把窗口减小到rwnd=300,第二次又减小到rwnd=100,第三次减小到0，即不予许再发送了。这种发送暂停的等待状态会持续到主机A收到B新的确认报文，三个确认报文都设置了ACK=1，切记当ACK=1时确认才有意义。现在我们考虑另一种情况，现假设B给A发送0窗口报文后，现在又有了新的缓存空间。所以给A发送窗口值=400的报文段，可此报文段由于网络问题丢失了，此时B在等待A发数据，A在等待B发窗口值改变的报文。如果没有其他措施这种死锁局面就会一直延续下去。为了解决这种问题TCP为每个连接都设置了一个持续计时器，只要对方设置了0窗口，就启动持续计时器开始计时，若果超时就会发送一个零窗口探测报文（只携带一个字节），对方收到探测报文就会给出现在的窗口值，若窗口依然是0，就继续等待，若不是则打破僵局。 考虑传输效率&emsp;&emsp;前面已经讲过,应用进程把数据传送到TCP的发送缓存后,剩下的发送任务就由TCP来控制了。可以用不同的机制来控制TCP报文段的发送时机。例如,第一种机制是TCP维持一个变量,它等于最大报文段长度MSS。只要缓存中存放的数据达到MsS字节时,就组装成一个TCP报文段发送出去。第二种机制是由发送方的应用进程指明要求发送报文段即TCP支持的推送(push)操作。第三种机制是发送方的一个计时器期限到了,这时就把当前已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。&emsp;&emsp;但是,如何控制TCP发送报文段的时机仍然是一个较为复杂的问题。例如,一个交互式用户使用一条 TELNET连接(运输层为TCP协议)。假设用户只发1个字符。加上20字节的首部后,得到21字节长的TCP报文段。再加上20字节的IP首部,形成41字节长的IP数据报。在接收方TCP立即发出确认,构成的数据报是40字节长(假定没有数据发送)。若用户要求远地主机回送这一字符,则又要发回41字节长的IP数据报和40字节长的确认IP数据报。这样,用户仅发1个字符时线路上就需传送总长度为162字节共4个报文段。当线路带宽并不富裕时,这种传送方法的效率的确不高。因此应适当推迟发回确认报文,并尽量使用捎带确认的方法在TCP的实现中广泛使用 Nagle算法。算法如下:若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存,则发送方就把第一个数据字节先发送出去,把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后,再把发送缓存中的所有数据组装成一个报文段发送出去,同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时,用这样的方法可明显地减少所用的网络带宽。 Nagle算法还规定,当到达的数据已达到发送窗口大小的半或已达到报文段的最大长度时,就立即发送一个报文段。这样做,就可以有效地提高网络的吞吐量。&emsp;&emsp;另一个问题叫做糊涂窗口综合症( silly window syndrome)RFC813],有时也会使TCP的性能变坏。设想一种情况:TCP接收方的缓存已满,而交互式的应用进程一次只从接收缓存中读取1个字节(这样就使接收缓存空间仅腾出1个字节),然后向发送方发送确认,并把窗口设置为1个字节(但发送的数据报是40字节长)。接着,发送方又发来1个字节的数据(请注意,发送方发送的IP数据报是41字节长)。接收方发回确认,仍然将窗口设置为1个字节。这样进行下去,使网络的效率很低。&emsp;&emsp;要解决这个问题,可以让接收方等待一段时间,使得或者接收缓存已有足够空间容纳一个最长的报文段,或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一,接收方就发出确认报文,并向发送方通知当前的窗口大小。此外,发送方也不要发送太小的报文段,而是把数据积累成足够大的报文段,或达到接收方缓存的空间的一半大小。上述两种方法可配合使用。使得在发送方不发送很小的报文段的同时,接收方也不要在缓存刚刚有了一点小的空间就急忙把这个很小的窗口大小信息通知给发送方。 TCP的拥塞控制&emsp;&emsp;计算机里的链路容量，交换节点的缓存，处理机等这些都是有限的网络资源，若某段时间对资源的需求大于本身资源的负载，就会使网络性能变坏，这时就出现了拥塞。我们可以发现以下条件拥塞=对资源的需求&gt;可用资源&emsp;&emsp;若网络中有许多资源同时呈现供应不足,网络的性能就要明显变坏,整个网络的吞吐量将随输入负荷的增大而下降。有人可能会说:“只要任意增加一些资源,例如,把结点缓存的存储空间扩大,或把链路更换为更高速率的链路,或把结点处理机的运算速度提高,就可以解决网络拥塞的问题。”其实不然。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法,在许多情况下,不但不能解决拥塞问题,而且还可能使网络的性能更坏。&emsp;&emsp;网络拥塞往往是由许多因素引起的。例如,当某个结点缓存的容量太小时,到达该结点的分组因无存储空间暂存而不得不被丢弃。现在设想将该结点缓存的容量扩展到非常大。于是凡到达该结点的分组均可在结点的缓存队列中排队,不受任何限制。由于输出链路的容量和处理机的速度并未提高,因此在这队列中的绝大多数分组的排队等待时间将会大大增加,结果上层软件只好把它们进行重传(因为早就超时了)。由此可见,简单地扩大缓存的存储空间同样会造成网络资源的严重浪费,因而解决不了网络拥塞的问题。&emsp;&emsp;又如,处理机处理的速率太慢可能引起网络的拥塞。简单地将处理机的速率提高,可能会使上述情况缓解一些,但往往又会将瓶颈转移到其他地方。问题的实质往往是整个系统的各个部分不匹配。只有所有的部分都平衡了,问题才会得到解决。拥塞常常趋于恶化。如果一个路由器没有足够的缓存空间,它就会丢弃一些新到的分组。但当分组被丢弃时,发送这一分组的源点就会重传这一分组,甚至可能还要重传多次这样会引起更多的分组流入网络和被网络中的路由器丢弃。可见拥塞引起的重传并不会缓解网络的拥塞,反而会加剧网络的拥塞。&emsp;&emsp;拥塞控制与流量控制的关系密切,它们之间也存在着一些差别。所谓拥塞控制就是防止过多的数据注入到网络中,这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提,就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程,涉及到所有的主机、所有的路由器,以及与降低网络传输性能有关的所有因素。但TCP连接的端点只要迟迟不能收到对方的确认信息,就猜想在当前网络中的某处很可能发生了拥塞,但这时却无法知道拥塞到底发生在网络的何处,也无法知道发生拥塞的具体原因(是访问某个服务器的通信量过大?还是在某个地区出现了自然灾害)。&emsp;&emsp;相反,流量控制往往指点对点通信量的控制,是个端到端的问题(接收端控制发送端)。流量控制所要做的就是抑制发送端发送数据的速率,以便使接收端来得及接收。可以用个简单例子说明这种区别。设某个光纤网络的链路传输速率为1000Gb/s。有一个巨型计算机向一个PC机以1Gb/s的速率传送文件。显然,网络本身的带宽是足够大的,因而不存在产生拥塞的问题。但流量控制却是必需的,因为巨型计算机必须经常停下来,以便使PC机来得及接收。&emsp;&emsp;但如果有另一个网络,其链路传输速率为1Mb/s,而有1000台大型计算机连接在这个网络上。假定其中的500台计算机分别向其余的500台计算机以100kb/s的速率发送文件。那么现在的问题已不是接收端的大型计算机是否来得及接收,而是整个网络的输入负载是否超过网络所能承受的。拥塞控制和流量控制之所以常常被弄混,是因为某些拥塞控制算法是向发送端发送控制报文,并告诉发送端,网络已出现麻烦,必须放慢发送速率。这点又和流量控制是很相似的。&emsp;&emsp;进行拥塞控制需要付出代价。这首先需要获得网络内部流量分布的信息。在实施拥塞控制时,还需要在结点之间交换信息和各种命令,以便选择控制的策略和实施控制。这样就产生了额外开销。拥塞控制有时需要将一些资源(如缓存、带宽等)分配给个别用户(或些类别的用户)单独使用,这样就使得网络资源不能更好地实现共享。十分明显,在设计拥塞控制策略时,必须全面衡量得失。&emsp;&emsp;在图中的横坐标是提供的负载( offered load),代表单位时间内输入给网络的分组数目。因此提供的负载也称为输入负载或网络负载。纵坐标是吞吐量( throughput),代表单位时间从网络输出的分组数目。具有理想拥塞控制的网络,在吞吐量饱和之前,网络吞吐量应等于提供的负载,故吞吐量曲线是45°的斜线。但当提供的负载超过某一限度时,由于网络资源受限,吞吐量不再增长而保持为水平线,即吞吐量达到饱和。这就表明提供的负载中有一部分损失掉了(例如,输入到网络的某些分组被某个结点丢弃了)。虽然如此,在这种理想的拥塞控制作用下,网络的吞吐量仍然维持在其所能达到的最大值但在实际的情况下无拥塞控制计划，随着网络吞吐量增长速率减小，网络会轻度拥塞，继续负载则会死锁。 拥塞控制方法慢开始和拥塞避免&emsp;&emsp;慢开始并不是指窗口值增长速率慢，而是指TCP最开始将窗口值设置为1，然后逐渐增长，这样的方式使得并不是一开始就将过量数据注入网络，先试探一下你，网络是否拥堵，然后在进行逐步增大。为了防止拥塞窗口cwnd增长过大引起网络拥塞,还需要设置一个慢开始门限 ssthresh状态变量(如何设置 ssthresh,后面还要讲)。慢开始门限 ssthresh的用法如下:当cwnd&lt; ssthresh时,使用上述的慢开始算法。当cwnd&gt; ssthresh时,停止使用慢开始算法而改用拥塞避免算法。当cwnd= ssthresh时,既可使用慢开始算法,也可使用拥塞避免算法。&emsp;&emsp;拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大,即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1,而不是加倍。这样,拥塞窗口cwnd按线性规律缓慢增长,比慢开始算法的拥塞窗口增长速率缓慢得多。无论在慢开始阶段还是在拥塞避免阶段,只要发送方判断网络出现拥塞(其根据就是没有按时收到确认),就要把慢开始门限 ssthresh设置为出现拥塞时的发送方窗口值的一半(但不能小于2)。然后把拥塞窗口cwnd重新设置为1,执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数,使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。&emsp;&emsp;下图用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。&emsp;&emsp;在执行慢开始算法时,拥塞窗口cwnd的初始值为1。以后发送方每收到一个对新报文段的确认ACK,就把拥塞窗口值加1,然后开始下一轮的传输(请注意,图的横坐标是传输轮次)。因此拥塞窗口cwd随着传输轮次按指数规律增长。当拥塞窗口cwd增长到慢开始门限值 ssthresh时(即当cwnd=16时),就改为执行拥塞避免算法,拥塞窗口按线性规律增长。 快重传和快恢复&emsp;&emsp;上面讲的慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法。1990年又增加了两个新的拥塞控制算法。这就是快重传和快恢复提出这两个算法是基于如下的考虑:如果发送方设置的超时计时器时限已到但还没有收到确认,那么很可能是网络出现了拥塞,致使报文段在网络中的某处被丢弃。在这种情况下,TCP马上把拥塞窗口cwnd减小到1,并执行慢开始算法,同时把慢开始门限值 ssthresh减半,如前图所示。这是不使用快重传的情况。那快重传是怎么样的呢，快重传中如某次发送方发送数据丢失，接收方由于后续确认只能确认收到的最低序号确认则会对没收到的序号-1，进行确认并希望收到缺失的序号，如果，发送方连续三次收到了B对某数据的缺失确认则立即发送此数据报文，而不用等待此数据的重传计时器。因此使用传重传能使网络吞吐量提高20%。&emsp;&emsp;与快重传配合使用的还有快恢复算法,其过程有以下两个要点:(1)当发送方连续收到三个重复确认时,就执行“乘法减小”算法,把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意,接下去不执行慢开始算法。(2)由于发送方现在认为网络很可能没有发生拥塞(如果网络发生了严重的拥塞,就不会一连有好几个报文段连续到达接收方,也就不会导致接收方连续发送重复确认),因此与慢开始不同之处是现在不执行慢开始算法(即拥塞窗口cwd现在不设置为1),而是把cwnd值设置为慢开始门限ssthresh减半后的数值,然后开始执行拥塞避免算法(“加法增大”),使拥塞窗口缓慢地线性增大,下图给出了快重传和快恢复的示意图,并标明了“ TCPReno版本”,这是目前使用得很广泛的版本。图中还画出了已经废弃不用的虚线部分( TCP Tahoe版本)。请注意它们的区别就是:新的 TCP Reno版本在快重传之后采用快恢复算法而不是采用慢开始算法&emsp;&emsp;请注意,也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一些(增大3个报文段的长度),即等于 ssthresh+3×MSS。这样做的理由是:既然发送方收到三个重复的确认,就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中(接收方发送出三个重复的确认就证明了这个事实)。可见现在网络中并不是堆积了三个分组，而是减少了三个分组，此时可适当加大拥塞窗口。&emsp;&emsp;在采用快恢复算法时,慢开始算法只是在TCP连接建立时和网络岀现超时时才使用釆用这样的拥塞控制方法使得TCP的性能有明显的改进在里开始我们就假定了接收方总是有足够大的缓存空间,因而发送窗口的大小由网络的拥塞程度来决定。但实际上接收方的缓存空间总是有限的。接收方根据自己的接收能力设定了接收窗口rwnd,并把这个窗口值写入TCP首部中的窗口字段,传送给发送方。因此,接收窗口又称为通知窗口( advertised window)。因此,从接收方对发送方的流量控制的角度考虑,发送方的发送窗口一定不能超过对方给出的接收窗口值rwnd。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP可靠传输的实现]]></title>
    <url>%2F2018%2F08%2F09%2FTCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[TCP可靠传输的原理 我们都知道，TCP发送的报文段是交付给IP层传送的。但IP层只提供尽最大努力传输，因此是不可靠的，因此TCP必须采用适当的措施才能使两个运输层之间通信变得可靠。 理想的传输条件有以下两个特点： 1.传输信道无差错 2.不管发送方以什么样的发送速率，接收方都能来得及处理发送方发送的消息。然而实际上并不存在这样理想的传输条件，因此我们必须采用一些必要的措施保证实现可靠传输。 停止等待协议这里我们讨论单方向的发送和接受，设A为发送方B为接收方。A每发完一个分组就等待B收到分组的确认，然后才发送下一个分组。上图a介绍了无差错的情况，b图展示若出现差错的应对机制，若B发给A的确认报文在途中丢失，B对于自己的报文丢没有并不清楚，它只等待A传入下个数据包，而A也在等B的确认报文，发现这种情况怎么办呢。超时重传了解一下，超时重传就是为了解决这个问题，当A在一定时间内没有收到B的确认，就认为自己发送的数据报文B没有收到，并且重发这段数据，如果这计时器规定时间内收到了A的确认就撤销计时器。应当注意以下三点：1.A没有收到B的确认报文时，必须暂时的保留已发送的分组副本，以便于超时重传。2.分组和确认必须编码，这样才能知道哪些分组收到了确认，哪些没有收到。3.超时计时器应当设计的比数据在分组传输的平均往返时间要长一些，如果重传时间过长会严重影响效率，但如果过短也会有不必要的重传，浪费资源。 确认丢失和确认迟到若A没有收到B的确认报文，A并不知道是自己的分组丢失还是B的确认丢失，所以重传计时器超时就会重传分组。此时B又收到了分组此时B有两个行动：1.丢弃重复的M1，不向上层交付。2.对A发送确认。可是试想有这样一种可能如图b，B的确认并没有丢失而是由于网络延迟滞留在网络中。此时A会受到重复的确认，处理也很简单。A对重复的=确认并不处理，B依旧会收到重复的分组，然后丢弃重复的M1，并给A发送确认。使用以上的确认重传机制就能在不可靠的网络上实现可靠的通信。 TCP的滑动窗口实际上为了提高信道利用率，分组传输并没有每次只发送一个分组，然后等待确认。（这样实在效率太低）。为了提高传输效率，我们必须采用流水线传输，流水线传输使得发送方可以连续发送多个分组，不必每发完一个分组，就停下来等待，显然这样就能获得较高的信道利用率。 使用流水线传输就要介绍TCP的滑动窗口，现在假定A发送数据B接收数据来讨论TCP的滑动窗口。TCP的滑动窗口是以字节为单位的，现假设A收到了来自B的确认报文，其中窗口大小为20字节，确认号为31，而序号30以前的数据都被完好的接受了。我们先说A的发送窗口，发送窗口表示在没有收到B的确认之前窗口里的数据都能持续的发送出去，但这些数据在没有收到B的确认时都必须保留下来，以便于超时重传。显然窗口越大发送方就能在收到确认之前持续发送更多的数据，可以获得更高的传输效率，前提是对方来得及处理这些数据。滑动窗口后沿部分表示已发送并且已经确认的报文，这些可以不用在保留，而前沿部分表示不允许发送的，发送窗口由前沿和后沿共同决定，发送窗口的后沿就两种变化情况不动（没有收到确认），向前移动（收到确认）。发送窗口的前沿一般都是向前移动的，当然也可能不动（没收到确认，窗口值也不变，或者收到确认，窗口值变小）发送窗口前沿也可能向后收缩，这发生在对方通知窗口变小，TCP强烈不推荐这样做。因为可能已经发送了这些数据，但现在又不让发送，可能会产生错误。现在假设A发送了31-41的数据，这时窗口未改变。灰色的小方框表示已经发送但没有收到确认的，而发送窗口后九个字节42-50表示没有发送但允许发送的。从上图看出要描述一个发送窗口需要三个指针：p1,p2,p3.小于p1表示已经发送成功的，大于p3表示不可发送的1.p3-p1表示发送窗口2.p2-p1表示已发送尚未确认3.p3-p2表示尚未发送的再看B的接收窗口，接收窗口大小为20字节，B收到了32、33号的数据，没有收到31号所以B只能给出收到的数据最高序号加1，也就是31，期望下次收到31号数据。现假定B收到了31号数据并对A确认，窗口依然是20，此时A可以向前移动3个字节，此时A的可发送窗口变大，发送范围为42-53. A在继续发送完数据，p2指针p3指针重合此时发送窗口已满，但B的确认并没有到达（丢失或者滞留），等到重传计时器超时，就必须重传这部分数据。直到收到B的确认，然后继续滑动窗口。 TCP的缓存与窗口的关系： 小思考，若收到的报文段无差错只是没有按序号到达，中间还缺少数据，能否只重传缺少的数据而不用重传已经收到的数据？答案是可以的，选择确定（SACK）是一种可行的办法。要使用选择确认，双方必须商定好，必须在TCP首部增加SOCK选项，以便报告收到不连续的字节块的边界以便于重传。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP报文段的首部格式]]></title>
    <url>%2F2018%2F08%2F09%2FTCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[TCP报文段的首部格式TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段，一个TCP报文段分为首部和数据两部分，TCP的全部功能体现在首部各字段作用。TCP报文段的前20个字节是固定的，后面有4n个字节根据需要而增加的选项（n为整数）。所以TCP首部最小长度为20字节。 首部固定字段意义如下：1.源端口和目的端口：各占两个字节，分别写入源端口号和目的端口号。 2.序号：占4字节，序号范围是[0，2^32-1]一共是4294967296个序号，当序号用完以后，下一个序号就又回到0.在TCP连接中所有字节按序号编号首部中的字段序号标记本报文段所发送的第一个字节的序号。例如本报文段序号为201，携带有100字节的数据，那么最后一个字节数据为300，并且下个报文段数据应当从301开始发送。 3.确认号：占4个字节 ，是期望收到对方下一个报文段的第一个字节序号，一般由接收方发给发送方的确认报文中将确认号改为期望收到的数据字节编号，总之若确认号为N，则表示N-1之前的数据都已经正确的接接收了。 4.数据偏移：占4位，表示数据到TCP数据包头部的长度，其实就是表明TCP头部的长度，因为TCP头部固定20字节加上不确定的部分，但4位2进制能最大表示十进制数15，但应注意数据偏移的单位是32位字所以数据偏移最大能表示60字节，因此TCP首部最大为60字节，即选项长度不能超过40字节。 5.保留：占6位，作为以后使用，目前应该置0 6.六个控制位：1）紧急URG:当URG置为1时表示此报文段为紧急报文，应当尽快送达，拥有较高的优先级，不需要排队传送。发送方会把经济数据插入到本报文数据的最前面发送，需要注意的是需要和紧急指针配合使用。2）确认ACK：当ACK=1时，确认号才有效，当连接建立时，所有报文段ACK都必须置为1.3）推送PSH：当两个应用交互式通信，有一段应用可能需要对方应用及时的响应，这种情况下可以将PSH位置为1，表示收到消息不用等待缓存区满才向上交付，而是尽快直接交付。4）复位RST： 当RST置为1，表示TCP连接出现严重错误，需要断开并重新建立连接。5）同步SYN:在建立连接用来同步序号，当SYN=1，ACK等于0，标指这是一个请求连接的报文段，如果对方同意连接就将SYN=1,ACK=1。6）终止FIN：用来释放一个连接，当FIN置为1表示已经没有数据发送，已经发送完毕。并要求释放连接。 7.窗口：占2字节窗口值是[0-2^16-1]之间的整数，窗口告诉发送方从本报文段首部的确认号算起还能接受的数据量，而此窗口值作为发送端设置发送端口的依据。 8.检验和：占2个字节，用来检验首部和数据这两部分是否出现差错。 9.紧急指针：占2个字节，紧急指针只有在标志位URG=1时候才有用，它指出紧急数据的字节数，因为紧急数据后面就是普通数据，紧急指针给出了紧急数据在报文段末尾的位置。 10.选项：长度可变，最大40字节，如果不使用选项，TCP首部大小就为20字节。TCP最开始就只规定了一种选项就是MSS最大报文段长度，但MSS的意思是每个报文中数据字段的最大长度（即报文长度减去TCP首部长度），MSS默认长度位536字节，因此在所有计算机上都能支持的报文段长度为536+20=556字节.随着英特网的发展后来又增加了几个选项：窗口扩大、时间戳等。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的三次握手四次挥手]]></title>
    <url>%2F2018%2F08%2F09%2FTCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[TCP的三次握手TCP的连接的建立采用客户服务器方式。主动发起连接建立的应用进程称为客户端，被动的等待连接建立的应用进程叫做服务器。先假定主机A运行的是客户端程序，而B运行的是服务器程序。最初两端的TCP进程都处于CLISED状态。建立三次握手过程如下图：A主动打开连接，B被动打开连接 连接过程1.首先两端都处于CLOSED状态，B的TCP服务器首先创建传输控制块TCB准备接受客户端的连接请求，然后服务器进程就处于LISTEN状态，等待客户的连接请求，如果有就及时做出反应。2.A的TCP进程也是首先创建传输控制模块TCB，然后向B发送连接请求，同时初始化序号seq=x，并将SYN标志位置为1，此阶段为SYN报文段规定并不能携带数据，但也会消耗一个序号，此时TCP客户进程进入SYN-SENT（同步已发送）状态。3.B如果接受连接请求就将确认报文中的ACK，SYN置为1，同时初始化自己的序号seq=y，确认号为ack=x+1.同样的这个报文也不能携带数据，并且也要消耗一个序号，然后B进入SYN-RCVD状态（同步收到）。4.A收到B的确认后还需要再次向B给出确认，确认ACK置1，确认号ack=y+1,而自己的序号为seq=x+1,TCP规定ACK报文可以携带信息，但是如果不携带则不用消耗一个序号，这种情况下下次发送的序号仍然为seq=x+1。这时连接已经建立，A进入ESTAB-LISHED(已建立连接)状态。当B收到A的确认后也进入ESTAB-LISHED状态。 至此三次握手到此结束 小思考，为什么要A还要给B发一次确认呢？或者说两次握手不就建立好了吗？ 答：这样是为了防止已经失效的的连接请求再次传送到B,从而产生错误。我们现在试着想一下这样一种正常的情况，A向B发送连接请求，但因为某种原因请求丢失了，A超时重传再次发送连接请求，传输完毕释放连接，A一共发送了两个请求，第一个丢失第二个正常收到，没有失效的连接请求报文段。但我们试想另一种极端的情况，那就是A第一次发送的请求并没有丢失而是因为网络延迟而滞留了，此时滞留的请求被B收到，B会以为这是A的新的一次请求，然后B进行确认应答然后进入连接状态（假设没有三次握手，两次握手就连接），可是B的确认传达到A，由于A并没有申请连接B，所以A不会理睬B的确认应答，也并不会给B发数据。可B一直在等A给他发消息，于是B的服务器资源被白白浪费。 而采用了三次握手，发生上述情况，由于A不会向B发送确认应当，B也就知道A没有连接的请求。 TCP的四次挥手TCP的连接释放过程分为四个步骤，称为四次挥手，我们仍结合双方状态来探究释放的过程 1.在数据传输完成后双方都可以释放连接，现在双方都处于ESTAB-LISHED状态,现在由A首先先向其TCP发出释放连接报文段，并停止发送数据，主动关闭TCP连接。其通过将FIN位置1，seq=u（等于最后传送成功数据序号+1），同时A进入FIN-WAIT-1状态，等待B的确认。注意FIN报文段不携带数据也会占用一个序号。2.B收到连接释放报文段后发出确认，ACK=1，ack=u+1,自身序号seq=x,同时B进入CLOSE-WAIT(关闭等待状态)，这时TCP服务器通知上层进程，因此从A到B方向的连接就释放了，但由B到A还能发送信息。A收到B的确认应答进入FIN-WAIT-2状态等待B释放自己的报文段。这个状态可能持续一段时间。3.若B没有数据要发送给A，B就会通知A断开连接，此时B的序号为最后发送的数据序号+1，seq=w，ack=u+1,并将FIN置为1，然后进入LAST-ACK(最后确认状态)，并等待A的确认。4.A收到B的连接释放报文段后必须对此发出确认，将ACK置为1，seq=u+1，ack=w+1.此时还并没有释放完毕，A会进入TIME-WAIT（时间等待状态），必须经过时间等待计时器设置的时间2MSL后A才进入CLOSED状态，可能对于现在的网络2分钟可能有点长，因此TCP允许不同实现的具体情况使用更小的MSL值，当时间等待结束，A回收x相应的传输控制块TCB后就结束了此次TCP连接，而B收到A的确认会立即进入CLOSED状态。 至此四次挥手结束！ 小思考，为什么客户机A需要等待2MSL？答：在这里有两个理由：1.为了保证A发送的确认能够到达B，因为这个报文可能会丢失，而丢失了A可以重传确认并重新启动TIME-WAIT，如果A发送了确认不进行等待而立即释放，会导致B无法收到A的ACK确认从而无法完成B的释放。2。为了防止前面提到的已失效连接请求报文段。A在发送完成最后一个ACK报文段后，在经历2MSL后，可以使所有本连接连续产生的所有报文段从网络中消失，这样使得下一次的新连接中不会出现这种就的请求报文。 保活计时器上面介绍了TCP的正常断开步骤，可日常情况下可能有一些特殊的情况，比如意外的断电使得客户断不能告诉服务端自己断开链接了，此时应当有措施使得服务器不必白白等下去，因此设计了保活计时器，当服务端每次收到客户端数据都会重置保活计时器。，时间的设置通常是两个小时，如果两个小时都没有收到客户的数据，服务器就会发送一个探测报文，以后会间隔75分钟发一次，若连续10次仍然没有客户端的消息，服务器就认为客户端故障，接着关闭这个连接。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚函数和纯虚函数]]></title>
    <url>%2F2018%2F07%2F31%2F%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[虚函数在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数，用法格式为：virtual 函数返回类型 函数名（参数表） {函数体}；实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。 简单地说，那些被virtual关键字修饰的成员函数，就是虚函数。虚函数的作用，用专业术语来解释就是实现多态性（Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异，而采用不同的策略。下面来看一段简单的代码。 纯虚函数1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;class A&#123; public: void print() &#123; cout&lt;&lt;"This is A"&lt;&lt;endl; &#125;&#125;;class B : public A&#123; public: void print() &#123; cout&lt;&lt;"This is B"&lt;&lt;endl; &#125;&#125;;int main()&#123; //为了在以后便于区分，我这段main()代码叫做main1 A a; B b; a.print(); b.print(); return 0;&#125; 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;class A&#123;public: virtual void print() &#123; cout &lt;&lt; "This is A" &lt;&lt; endl; &#125; virtual ~ A() &#123;&#125;&#125;;class B : public A&#123;public: void print() &#123; cout &lt;&lt; "This is B" &lt;&lt; endl; &#125;&#125;;int main()&#123; B b; A *a = &amp;b; a-&gt;print(); b.print(); system("pause"); return 0;&#125; 这里通常将基类的析构函数也声明为虚函数。避免内存泄漏。 纯虚函数纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。 123456//纯虚函数是一种特殊的虚函数，它的一般格式如下：class &lt;类名&gt;&#123;virtual &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=0;…&#125;; 在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。一般而言纯虚函数的函数体是缺省的，但是也可以给出纯虚函数的函数体（此时纯虚函数变为虚函数），这一点经常被人们忽视，调用纯虚函数的方法为baseclass::virtual function. 123456789101112131415161718192021222324252627#include&lt;iostream&gt; using namespace std; class base &#123; public: virtual void Demon() = 0; virtual void Base() &#123; cout &lt;&lt; "this is farther class" &lt;&lt; endl; &#125; &#125;; class SubVirtual :public base &#123; public: void Demon() &#123; cout &lt;&lt; " this is SubVirtual!" &lt;&lt; endl; &#125; void Base() &#123; cout &lt;&lt; "this is subclass Base" &lt;&lt; endl; &#125; &#125;; void main() &#123; base* inst = new SubVirtual(); inst-&gt;Demon(); inst-&gt;Base(); system("pause"); return; &#125;]]></content>
      <tags>
        <tag>-C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的的三大特性的总结]]></title>
    <url>%2F2018%2F07%2F29%2F%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承继承是一指一个对象从另一个对象获得功能的过程，它提供了一种明确表述共性的方法。是一个不断向上抽取的过程。单继承中，一个类只能继承一个类，但一个类可以被多个类所继承。一共有3种不同权限的继承，分别是public、protect、private继承。继承优点：1.提高了代码的复用性。2.让类与类之间产生了关系。有了这个关系，才有了多态的特性。 封装什么是封装？封装指隐藏对象的属性和实现细节，仅仅对外提供接口和方法。举一个生动的例子：电视遥控器，就是对电视机操作方法的一种封装，遥控器上的各种按键就是给出的接口，我们用户通过这些接口来控制电视机，但是我们对遥控器实际控制并不清楚，它的原理，或者具体细节，都对我们用户隐藏，这就是一种封装。而在C++中将一个类具体封装起来，只暴露接口函数。能够提高代码重用性，便于使用，当然也更安全。但这样做同时也暴露了缺点，那就是代码不能轻易地去维护，而且封装了过多层会影响效率。 多态什么是多态？c++中一共有两种多态，一种是静态的多态，一种是动态的多态。动多态称为运行时多态，而静多态称为编译时多态。静多态大多由模板实现或者是宏，而动多态大多由虚函数来实现，动多态的函数调用机制是执行期才能进行确定，所以它是动态的。总之多态的意义在于让基类的指针指向派生类，从而实现派生类的不同功能。如果你还是不太明白多态的意义，我可以举一个简单的例子。龙生九子，子子不同，龙的九个儿子就是龙的不同表现，同一个模板下，实现不同的形态或者功能就称之为多态。 多态的实现：函数重载：必须在同一个类中进行 子类无法重载父类的函数，父类同名函数将被名称覆盖，重载是在编译期间根据参数类型和个数决定函数调用函数重写：必须发生于父类与子类之间 并且父类与子类中的函数必须有完全相同的原型 ，使用virtual关键字声明之后能够产生多态(如果不使用virtual，那叫重定义) 多态是在运行期间根据具体对象的类型决定函数调用（注意：基类的析构函数通常建议声明为虚函数，不然容易内存泄漏。 多态的优势和弊端：优点：多态的出现大大的提高程序的扩展性，以及代码的复用性，减少了编程中编码量，提高了代码的可维护性。缺点：在大工程里如果多态使用大量，编译时过程会极其缓慢。同时多态使得代码的可读性并不那么良好，同时调式起来也比较困难。]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的成员函数]]></title>
    <url>%2F2018%2F07%2F18%2F%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[六大成员函数一、构造函数特点：与类名相同、没有返回值、可以重载、在有效的生命周期只会调用一次、缺省的构造函数不能用Virtual/const修饰，构造函数有自己的初始化列表。初始化列表完成类中非静态成员变量的初始化，尽量避免用成员初始化成员。初始化中，用const类型成员必须初始化。 二、拷贝构造函数特点：用对象创建对象 参数为类类型的引用，这里必须用引用传递，不然会无限循环递归。而用引用的另一个原因是效率很高。 三、析构函数特点：形式为~类名，没有参数和返回值，不能重载，在实现多态时最好在基类将构造函数声明为虚函数。四、赋值运算符重载常见可重载的运算符：++、– 、 、-&gt;、=不可重载的运算符： 、::、？：、sizeof 五、取地址运算符重载 1234Test * operator&amp;()&#123; return this;&#125; 六、const修饰的取地址操作符的重载12345const Test * operator&amp;() const&#123; return this;&#125;]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的层序遍历]]></title>
    <url>%2F2018%2F07%2F16%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[层序遍历算法二叉树的层序遍历：从根开始，依次向下，对于每一层从左向右遍历。同二叉树的前中后序遍历不同的是，前中后序采用的是堆，而二叉树层序遍历采用的是队列。因此前中后序遍历可以采用递归算法，而层序遍历却不行！ 层序遍历的模拟实现1234567891011121314151617181920212223242526272829303132struct BinaryTree//二叉树结构 &#123; int vec; BinaryTree* left; BinaryTree* right; &#125;; vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) //返回为一个数组 &#123; queue&lt;TreeNode*&gt; ret; ret.push(root); vector&lt;int&gt; result; if (root == NULL) return result; while (!ret.empty()) &#123; TreeNode*tmp= ret.front(); result.push_back(tmp-&gt;val); ret.pop(); if (tmp-&gt;left != nullptr) &#123; ret.push(tmp-&gt;left); &#125; if (tmp-&gt;right!=nullptr) &#123; ret.push(tmp-&gt;right); &#125; &#125; return result; &#125;]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的链式存储实现]]></title>
    <url>%2F2018%2F07%2F15%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[二叉链表数组表示法用于完全二叉树的存储表示非常有效，但表示一般二叉树则不是很理想。此外，在一棵树中进行插入和删除操作时，为了反应结点层次的变动，可能需要移动许多的结点，这样降低了算法的效率，而使用了链表表示可以克服这样的缺点。根据二叉树的定义，可以设计出二叉树节点的构造。二叉树的每一个结点至少应该包括三个域：数据、左孩子、右孩子。这种链表结构一般被叫做二叉链表。使用这种链表可以很方便的表示和找到它的子女，但找到它的双亲却很困难。为了便于查找双亲，我们还可以增加一个双亲指针域，这种结构被称为三叉链表。结构如下： 二叉链表的类定义三叉链表和二叉链表类似，本文只讨论二叉链表。下面给出二叉链表的类定义。 123456789101112131415161718192021222324252627282930313233343536373839404142#ifndef _HEAD_#define _HEAD_#include &lt;iostream&gt;typedef int DataType;typedef struct BinTreeNode&#123; DataType data; BinTreeNode *leftchild, *righutchild;&#125;Binarynode;class BinaryTree&#123;public: BinaryTree() :root(NULL)&#123;&#125; BinaryTree(BinaryTree&amp; s); ~BinaryTree(); void creatBinTree(Binarynode*&amp;subTree); void ceratBinTree(); bool IsEmpty() &#123; return root == NULL ? 1 : 0; &#125; Binarynode *find();//搜索 void PreOrder(); void PreOrder(Binarynode *subTree);//前序遍历 void InOrder(); void InOrder(Binarynode *subTree);//中序 void PostOrder(); void PostOrder(Binarynode *subTree);//后序 int count(Binarynode* subTree);//统计节点个数 int count(); int Hight(); int Hight(Binarynode* subTree);//求树高度 void copy(); BinaryTree* copy(Binarynode*&amp;Tree);//复制二叉树private: Binarynode *root;&#125;;#endif 二叉链表的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#include &lt;iostream&gt;using namespace std;typedef char DataType;DataType RefValue = '#';//输入结束符typedef struct BinTreeNode&#123; DataType data; BinTreeNode *leftchild, *rightchild;&#125;Binarynode;class BinaryTree&#123;public: BinaryTree() :root(NULL)&#123;&#125; BinaryTree(BinaryTree&amp; s); ~BinaryTree(); bool IsEmpty(); Binarynode *find(DataType &amp;item);//搜索 void creatBinTree(); void creatBinTree(Binarynode*&amp;subTree); void PreOrder(); void PreOrder(Binarynode *subTree);//前序遍历 void InOrder(); void InOrder(Binarynode *subTree);//中序 void PostOrder(); void PostOrder(Binarynode *subTree);//后序 int count(Binarynode* subTree);//统计节点个数 int count(); int Hight(); int Hight(Binarynode* subTree);//求树高度 void copy(); Binarynode* copy(Binarynode*&amp;Tree);//复制二叉树 void destory(Binarynode*&amp;Tree);//销毁private: Binarynode *root;&#125;;bool BinaryTree::IsEmpty()&#123; return root == NULL ? 1 : 0;&#125;Binarynode* BinaryTree::find(DataType&amp; item)&#123; if (item != NULL) &#123; Binarynode *tmp = root; Binarynode*tmpl = tmp-&gt;leftchild; Binarynode*tmpr = tmp-&gt;rightchild; DataType temp = root-&gt;data; while (tmpl) &#123; if (temp != item) &#123; tmpl = tmpl-&gt;leftchild; &#125; cout &lt;&lt; "i find it"; return tmpl; &#125; while (tmpr) &#123; if (temp != item) &#123; tmpr = tmpr-&gt;rightchild; &#125; cout &lt;&lt; "i find it "; return tmpr; &#125; &#125; cout &lt;&lt; "can't find it"; return NULL;&#125;void BinaryTree::PreOrder()&#123; PreOrder(root);&#125;void BinaryTree::PreOrder(Binarynode*subTree)&#123; if (subTree != NULL) &#123; cout &lt;&lt; subTree-&gt;data; PreOrder(subTree-&gt;leftchild); PreOrder(subTree-&gt;rightchild); &#125;&#125;void BinaryTree::InOrder()&#123; InOrder(root);&#125;void BinaryTree::InOrder(Binarynode* subTree)&#123; if (subTree != NULL) &#123; InOrder(subTree-&gt;leftchild); cout &lt;&lt; subTree-&gt;data; InOrder(subTree-&gt;rightchild); &#125;&#125;void BinaryTree::PostOrder()&#123; PostOrder(root);&#125;void BinaryTree::PostOrder(Binarynode*subTree)&#123; if (subTree != NULL) &#123; PostOrder(subTree-&gt;leftchild); PostOrder(subTree-&gt;rightchild); cout &lt;&lt; subTree-&gt;data; &#125;&#125;int BinaryTree::Hight()&#123; return Hight(root);&#125;int BinaryTree::Hight(Binarynode* subTree)&#123; if (subTree == NULL) &#123; return 0; &#125; else &#123; int dep1 = Hight(subTree-&gt;leftchild); int dep2 = Hight(subTree-&gt;rightchild); if (dep1&gt;dep2) &#123; return dep1 + 1; &#125; else &#123; return dep2 + 1; &#125; &#125;&#125;int BinaryTree::count()&#123; return count(root);&#125;int BinaryTree::count(Binarynode*subTree)&#123; if (subTree != NULL) &#123; return 1 + count(subTree-&gt;leftchild) + count(subTree-&gt;rightchild); &#125; return 0;&#125;void BinaryTree::copy()&#123; copy(root);&#125;Binarynode* BinaryTree::copy(Binarynode*&amp;Tree)&#123; if (Tree == NULL) &#123; return NULL; &#125; else &#123; Binarynode *tmp = new Binarynode; tmp-&gt;data = Tree-&gt;data; tmp-&gt;leftchild = copy(Tree-&gt;leftchild); tmp-&gt;rightchild = copy(Tree-&gt;rightchild); return tmp; &#125;&#125;void BinaryTree::creatBinTree(Binarynode*&amp;subTree)&#123; DataType item; cin &gt;&gt; item; if (item != RefValue) &#123; subTree = new Binarynode; subTree-&gt;data = item; if (subTree == NULL) &#123; cout &lt;&lt; "存储分配错误"; exit(1); &#125; creatBinTree(subTree-&gt;leftchild); creatBinTree(subTree-&gt;rightchild); &#125; else &#123; subTree = NULL; &#125;&#125;void BinaryTree::creatBinTree()&#123; creatBinTree(root);&#125;void BinaryTree::destory(Binarynode*&amp;Tree)&#123; if (Tree != NULL) &#123; return; &#125; destory(Tree-&gt;leftchild); destory(Tree-&gt;rightchild); delete Tree;&#125;BinaryTree::~BinaryTree()&#123; destory(root);&#125;BinaryTree::BinaryTree(BinaryTree &amp;s)&#123; root = copy(s.root);&#125;int main()&#123; BinaryTree subTree; cout &lt;&lt; "输入节点，空结点以#代替:"; subTree.creatBinTree(); cout &lt;&lt; "前序遍历："; subTree.PreOrder(); cout &lt;&lt; endl&lt;&lt;"中序遍历："; subTree.InOrder(); cout &lt;&lt; endl &lt;&lt; "后序遍历："; subTree.PostOrder(); cout&lt;&lt;endl&lt;&lt;"结点个数："&lt;&lt;subTree.count()&lt;&lt;endl; cout &lt;&lt; "树的高度："&lt;&lt;subTree.Hight()&lt;&lt;endl; system("pause"); return 0;&#125; 运行结果 关于链表的输入]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pairs-对组介绍]]></title>
    <url>%2F2018%2F07%2F12%2FPairs-%E5%AF%B9%E7%BB%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[队组class Pair 可以将两个值视作一个单元。C++标准库库内多处使用了这个Class，尤其是容器map和multimap，就是使用了Pairs来管理键值对，任何函数返回两个值也需要pair.1234567891011121314namespace std&#123; template&lt;class T1,class T2&gt; struct Pair&#123; typedef T1 first_type; typedef T2 second_type; pair() :first(T1(),second(T2)) &#123;&#125; pair(const pair&lt;U,V&gt;&amp;p) :first (p.first),second(p.second)&#123;&#125; &#125;&#125;; 注意，pair被定义为struct，而不是class，这样所有成员都是public,因此可以直接存储pair的个别值。1std:pair&lt;int,float&gt;p; 上述defalut构造函数生成一个pair时，以int（）和float（）来初始化p,这两个构造函数为0值；如果pair对象被复制，调用的是由系统隐式生成的的哪个copy构造函数，例如：1234567void f(std:：pair&lt;int,const char*&gt;);void f(std::pair&lt;const int,std::string&gt;);void foo&#123; std::pair&lt;int,const char*&gt;p(42,"hello"); f(p); g(p);&#125; pair之间的比较为了比较两个pair对象，C++标准程序库提供了大家惯用的操作符。如果两个pair对象内的所有元素相等，这两个pair对象就被视为相等。123456namespace std&#123; template&lt;class T ,class T2&gt; bool operator==(const pair&lt;T,T2&gt;&amp;X,const pair &lt;T,T2&gt;&amp;y)&#123; return x.first==y.first&amp;&amp;x.second==y.second; &#125;&#125; 当两个pairs相互比较时，第一元素具有较高的优先级，所以如果两个pairs的第一元素不相等，其比较结果就称为整个比较行为的结果。如果第一元素相等，才继续比较第二元素，并把比较结果当作整体比较结果。1234567namespace std&#123; template&lt;class T1,class T2&gt;bool operator&lt;const pair&lt;T1,T2&gt;&amp;X,const pair&lt;T1,T2&gt;&amp;y)&#123; return x.first&lt;y.first||(!(y.first/,x.first)&amp;&amp;x.second&lt;y.second);&#125;&#125; 其他的比较操作符，也差不多相似。]]></content>
      <tags>
        <tag>C++标准程序库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2018%2F07%2F09%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为log2(n+1)。深度为k的完全二叉树，至少有2^(k-1)个节点，至多有2^k-1个节点。 二叉树相关知识满二叉树：在一棵二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层，则这样的二叉树称作满二叉树。完全二叉树：如果一颗具有n个节点的二叉树的结构与满二叉树的前n个节点的结构相同，这样的二叉树称为完全二叉树。 二叉树性质1:若规定根节点的层数为0，则一棵非空二叉树的第i层上最多有2^i(i&gt;=0)个节点。2: 若规定只有根节点的二叉树的深度为0，则深度为k的二叉树的最大节点数是2^(k+1)-1(k&gt;=-1)。3:对于一棵非空的二叉树，如果叶节点个数为n0，度为2的节点个数为n2，则有n0=n2+1。4:具有n个节点的完全二叉树的深度k为大于或等于ln(n+1)-1的最小整数。5:对于具有n个节点的完全二叉树，如果按照从上至下和从左至右的顺序对所有节点序号从0开始顺序编号，则对于序号为i(0&lt;=i&lt;n)的节点有： 1)如果i〉0，则序号为i节点的双亲节点的序号为(i-1)/2(/为整除)；如果i=0，则序号为i节点为根节点，无双亲节点。 2)如果2i+1&lt;n,则序号为i节点的左孩子节点的序号为2i+1；如果2i+1&gt;=n,则序号为i节点无左孩子。 3)如果2i+2&lt;n,则序号为i节点的右孩子节点的序号为2i+2;如果2i+2&gt;=n，则序号为i节点无右孩子。 二叉树的存储方式1.二叉树的顺序存储结构 利用性质5，对于完全二叉树可以利用一维数组存储，如果不是完全二叉树，则可以补空节点，使成为完全二叉树在进行存储， 但是对于非完全二叉树，可能要浪费很多的空间。所以并不是很理想。2.二叉树的链式存储结构 二叉树的链式存储结构就是用指针建立二叉树中节点之间的关系，二叉树最常用的链式存储结构是二叉链表。二叉树的二叉链表存储结构是一种常用的二叉树存储结构。二叉链表存储结构的优点是结构简单，可以方便的构造任何形状的二叉树，并可以方便的实现二叉树的大多数操作。 二叉链表存储结构的缺点是，查找当前节点的双亲节点操作实现比较麻烦。]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单UDP网络程序]]></title>
    <url>%2F2018%2F07%2F07%2F%E7%AE%80%E5%8D%95UDP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[实现简单UDP客户端和服务器端实现简单的基于UDP协议的客户端和服务器端聊天小程序。 服务器端：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; typedef struct sockaddr sockaddr; typedef struct sockaddr_in sockaddr_in; int main(int argc,char* argv[]) &#123; int sock = socket(AF_INET,SOCK_DGRAM,0); if (sock&lt;0) &#123; perror("socket"); return 2; &#125; struct sockaddr_in local; local.sin_family=AF_INET; local.sin_port=htons(atoi(argv[1])); local.sin_addr.s_addr=htonl(INADDR_ANY); if (bind(sock,(struct sockaddr*)&amp;local,sizeof(local))&lt;0) &#123; perror("bind"); return 3; &#125; char buf[1024]; struct sockaddr_in client; while(1) &#123; socklen_t len= sizeof(client); ssize_t s=recvfrom(sock,buf,sizeof(buf)-1,0,(struct sockaddr*)&amp;client,&amp;len); if(s&gt;0) &#123; buf[s]=0; printf("[%s:%d]: %s\n",inet_ntoa(client.sin_addr),ntohs(client.sin_port),buf); sendto(sock,buf,strlen(buf),0,(struct sockaddr*)&amp;client,sizeof(client)); &#125; &#125; return 0; &#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; typedef struct sockaddr sockaddr; typedef struct sockaddr_in sockaddr_in; int main(int argc,char* argv[]) &#123; int sock=socket(AF_INET,SOCK_DGRAM,0); if (sock&lt;0) &#123; perror("socket"); return 2; &#125; struct sockaddr_in server; server.sin_family=AF_INET; server.sin_port=htons(atoi(argv[2])); server.sin_addr.s_addr=inet_addr(argv[1]); char buff[1024]; struct sockaddr_in peer; while(1) &#123; socklen_t len =sizeof(peer); printf("please enter： "); fflush(stdout); ssize_t s=read(0,buff,sizeof(buff)-1); if(s&gt;0) &#123; buff[s-1]=0; sendto(sock,buff,strlen(buff),0,(struct sockaddr*)&amp;server,sizeof(server)); ssize_t _s=recvfrom(sock,buff,sizeof(buff)-1,0,(struct sockaddr*)&amp;peer,&amp;len); if (_s&gt;0) &#123; buff[_s]=0; printf("server echo %s\n",buff); &#125; &#125; &#125; return 0; &#125; 测试1.运行服务器2.检查端口 3.运行客户端 4.查看服务器端]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2F2018%2F07%2F01%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[模板模板是实现代码重用机制的一种工具，它可以实现数据类型的参数化，即将数据类型定义为参数，而由编译系统在处理具体函数调用时，根据实参类型来匹配函数模板中的对应形参并在确认后生成一个重载函数，从而真正实现代码重用。 C++中，允许用户构造函数模板，创建支持多种不同数据类型的形参但却具有通用功能的函数；也允许构造类模板，使的类中某些数据成员，成员函数的参数和返回值可以是任意数据类型。使用模板可以从一个函数生成多个函数或者从一个类模板生成多个类，建立一个模板后，编译器将根据使用时的实际数据类型使其实例化，生成可执行的代码，实例化的函数模板称为模板函数；实例化的类称为模板类。模板、模板函数、模板类以及对象关系如下：模板使用方法：templete&lt;&lt;类型形参表》 &lt;返回类型&gt;&lt;函数名&gt;(模板形参表){...} 模板函数的使用#include&lt;iostream&gt; using namespace std; template &lt;typename T&gt; T Power(T base,int exponent) { T value =base; while(--exponent&gt;0) { value*=base; return value; } } int main() { cout&lt;&lt;"18^1="&lt;&lt;Power(18,1)&lt;&lt;endl; cout&lt;&lt;"5^3="&lt;&lt;Power(5,3)&lt;&lt;endl; cout&lt;&lt;"2.6^7="&lt;&lt;Power(2.6,7)&lt;&lt;endl; return 0; } 结果：]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vector]]></title>
    <url>%2F2018%2F06%2F29%2FVector%2F</url>
    <content type="text"><![CDATA[Vector名词解释：vector 是同一种类型的对象的集合,每个对象都有一个对应的整数索引值 。和 string 对象一样,标准库将负责管理与存储元素相关的内存。我们把 vector称为容器,是因为它可以包含其他对象，能够存放任意类型的动态数组，增加和压缩数据。一个容器中的所有对象都必须是同一种类型的 。vector 是一个类模板(class template)。使用模板可以编写一个类定义或函数定义,而用于多个不同的数据类型。因此,我们可以定义保存 string 对象的 vector,或保存 int 值的 vector,又或是保存自定义的类类型对象(如Sales_items 对象)的 vector。vector 不是一种数据类型,而只是一个类模板,可用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。 vectors运用实例1234567891011121314151617181920212223242526272829#include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; #include&lt;algorithm&gt; using namespace std;int main()&#123; vector&lt;string&gt; sentence; sentence.reserve(5); sentence.push_back("hello,"); sentence.push_back("how"); sentence.push_back("are"); sentence.push_back("you"); sentence.push_back("？"); copy(sentence.begin(), sentence.end(), ostream_iterator&lt;string&gt;(cout, " ")); cout &lt;&lt; endl; cout &lt;&lt; "max_size():" &lt;&lt; sentence.max_size() &lt;&lt; endl; cout &lt;&lt; "size():" &lt;&lt; sentence.size() &lt;&lt; endl; cout &lt;&lt; "capacity():" &lt;&lt; sentence.capacity() &lt;&lt; endl; swap(sentence[1], sentence[3]); sentence.insert(find(sentence.begin(), sentence.end(), "？"), "always"); sentence.back() = "!"; copy(sentence.begin(), sentence.end(), ostream_iterator&lt;string&gt;(cout, " ")); cout &lt;&lt; endl; cout &lt;&lt; "max():" &lt;&lt; sentence.max_size() &lt;&lt; endl; cout &lt;&lt; "size();" &lt;&lt; sentence.size() &lt;&lt; endl; cout &lt;&lt; "capacity()" &lt;&lt; sentence.capacity() &lt;&lt; endl;&#125; 结果 实验结果可能如此，注意我说的是“可能”，是的当max_size()和capacity（）的结果由实作版本决定，从这个例子中你可以看到，当容量不足时，此一实作版本将容量扩充1。所以你可以试着运行一下看看有没有和我不同。]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F06%2F28%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown编辑器写博客新功能： Markdown和扩展Markdown简洁的语法 代码块高亮 图片链接和图片上传 LaTex数学公式 UML序列图和流程图 离线写博客 导入导出Markdown文件 丰富的快捷键 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等。12345678910### 表格**Markdown Extra** 表格语法：项目 | 价格-------- | ---Computer | $1600Phone | $12Pipe | $1 项目 价格 Computer $1600 Phone $12 Pipe $1 1234567可以使用冒号来定义对齐方式：| 项目 | 价格 | 数量 || :-------- | --------:| :--: || Computer | 1600 元 | 5 || Phone | 12 元 | 12 || Pipe | 1 元 | 234 | 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 ###定义列表 Markdown Extra 定义列表语法： 1234567891011项目１项目２: 定义 A: 定义 B项目３: 定义 C: 定义 D &gt; 定义D内容 项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 代码块代码块语法遵循标准markdown代码，例如： 12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' ###脚注12生成一个脚注[^footnote].[^footnote]: 这里是 **脚注** 的 *内容*. 生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式123456使用MathJax渲染*LaTex* 数学公式，详见[math.stackexchange.com][1]. - 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。 - 块级公式：$$ x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$ 使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com. 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。 块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ ` 更多LaTex语法请参考 这儿. UML 图:可以渲染序列图：sequence 张三-&gt;李四: 嘿，小四儿, 写博客了没? Note right of 李四: 李四愣了一下，说： 李四--&gt;张三: 忙得吐血，哪有时间写。 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： flowst=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？ st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 这儿, 关于 流程图 语法，参考 这儿.]]></content>
      <tags>
        <tag>实用知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉诺塔]]></title>
    <url>%2F2018%2F06%2F27%2F%E6%B1%89%E8%AF%BA%E5%A1%94%2F</url>
    <content type="text"><![CDATA[汉诺塔汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 由来及传说由来：法国数学家爱德华·卢卡斯曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。不管这个传说的可信度有多大，如果考虑一下把64片金片，由一根针上移到另一根针上，并且始终保持上小下大的顺序。这需要多少次移动呢?这里需要递归的方法。假设有n片，移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7，且f(k+1)=2*f(k)+1。此后不难证明f(n)=2^n-1。n=64时，假如每秒钟一次，共需多长时间呢？一个平年365天有31536000 秒，闰年366天有31622400秒，平均每年31556952秒，计算一下：18446744073709551615秒这表明移完这些金片需要5845.54亿年以上，而地球存在至今不过45亿年，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，不说太阳系和银河系，至少地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。 印度传说：和汉诺塔故事相似的，还有另外一个印度传说：舍罕王打算奖赏国际象棋的发明人──宰相西萨·班·达依尔。国王问他想要什么，他对国王说：“陛下，请您在这张棋盘的第1个小格里赏给我一粒麦子，在第2个小格里给2粒，第3个小格给4粒，以后每一小格都比前一小格加一倍。请您把这样摆满棋盘上所有64格的麦粒，都赏给您的仆人吧！”国王觉得这个要求太容易满足了，就命令给他这些麦粒。当人们把一袋一袋的麦子搬来开始计数时，国王才发现：就是把全印度甚至全世界的麦粒全拿来，也满足不了那位宰相的要求。那么，宰相要求得到的麦粒到底有多少呢？总数为1+2+2^2 + … +2^63=2^64-1等于移完汉诺塔所需的步骤数。我们已经知道这个数字有多么大了。人们估计，全世界两千年也难以生产这么多麦子！ C语言汉诺塔的实现12345678910111213141516171819202122232425#include&lt;stdio.h&gt; 2 void move(int n,char form,char to) 3 &#123; 4 printf("%d号盘从%c移到%c\n",n,form,to); 5 &#125; 6 7 void hanoi(int n,int p1,int p2,int p3) 8 &#123; 9 if (n==1) &#123; 10 move(n,p1,p3); 11 &#125; 12 else&#123; 13 hanoi(n-1,p1,p3,p2); 14 move(n,p1,p3); 15 hanoi(n-1,p2,p1,p3); 16 &#125; 17 &#125; 18 int main() 19 &#123; 20 printf("请输入盘子的数量!\n"); 21 int num=0; 22 scanf("%d",&amp;num); 23 hanoi(num,'A','B','C'); 24 return 0; 25 &#125; 结果]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串中第一个只出现两次的字符]]></title>
    <url>%2F2018%2F06%2F26%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目找到字符串中第一个只出现两次的字符例 字符串”abbcdefacdefba”第一个只出现一次的字符是c 分析设置两个指针分别遍历数组若指针1等于指针2则计数器加1，遍历完后若计数器为1则输出字符，并结束遍历 实现1234567891011121314151617181920212223242526272829303132333435void findstr(char* str) &#123; char tmp = 'a'; char*src = str+1; int count = 0; while (*str != '\0') &#123; count = 0; src = str+1; while (*src != '\0') &#123; if (*str == *src) &#123; count++; tmp = *src; &#125; src++; &#125; if (count == 1) &#123; printf("找到字符是：%c\n",tmp); return; &#125; str++; &#125; printf("没找到"); &#125;int main()&#123; char* str = "abacdebaf"; findstr(str); return 0;&#125; 结果]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2018%2F06%2F24%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序名词解释：选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。 算法思想设置双重循环第一重循环从数组第一个元素开始，第二重循环从数组第二个元素开始，然后找出第二重循环中小于第一重循环的最小数，然后与第一重循环的首元素之交换。图解： 算法说明时间复杂度：O（n2)空间复杂度：O(1)算法稳定性：不稳定算法 算法实现12345678910111213141516171819202122232425262728293031323334353637383940void Selectionsort(int arr[], int size)&#123; if (size &lt;= 0) &#123; return; &#125; int max; int i, j; for (i = 0; i &lt; size - 1; i++) &#123; max = i; for (j = i + 1; j &lt; size; j++) &#123; if (arr[max]&gt;arr[j]) max = j; &#125; if (i != max) &#123; int tmp = arr[i]; arr[i] = arr[max]; arr[max] = tmp; &#125; &#125;&#125;int main()&#123; int array[] = &#123;1,3,6,2,5,8,7,9,4,6,12,30,300&#125;; const int num = sizeof(array) / sizeof(array[0]); Selectionsort(array,num); for (int i = 0; i &lt;sizeof(array) / sizeof(array[0]); i++) &#123; cout &lt;&lt; array[i] &lt;&lt; " "; &#125; delete[] p; return 0;&#125; 结果]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基数排序]]></title>
    <url>%2F2018%2F06%2F23%2F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基数排序名词解释：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。历史渊源：基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机(Tabulation Machine)上的贡献。它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。 第一步以LSD为例，假设原来有一串数值如下所示：73, 22, 93, 43, 55, 14, 28, 65, 39, 81首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：01 812 223 73 93 434 145 55 65678 289 39第二步接下来将这些桶子中的数值重新串接起来，成为以下的数列：81, 22, 73, 93, 43, 14, 55, 65, 28, 39接着再进行一次分配，这次是根据十位数来分配：01 142 22 283 394 435 556 657 738 819 93第三步接下来将这些桶子中的数值重新串接起来，成为以下的数列：14, 22, 28, 39, 43, 55, 65, 73, 81, 93这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。 图解： 算法分析时间效率 ：设待排序列为n个记录，d个关键码，关键码的取值范围为radix，则进行链式基数排序的时间复杂度为O(d(n+radix))，其中，一趟分配时间复杂度为O(n)，一趟收集时间复杂度为O(radix)，共进行d趟分配和收集。空间效率：需要2*radix个指向队列的辅助空间，以及用于静态链表的n个指针故为O(2*radix) 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int Maxbit(int arr[], int size)&#123; int p = 1; int count = 0; for (int i = 0; i &lt; size; i++) &#123; while (arr[i]&gt;p) &#123; p *= 10; count++; &#125; &#125; return count;&#125;void bucketsort(int arr[], int num)&#123; int max = Maxbit(arr, num); int i = 0; int j = 0; int k = 0; int index = 1; int *tmp = new int[num]; int *count = new int[10]; for (i = 0; i &lt; max; i++) &#123; for (j = 0;j &lt; 10; j++) &#123; count[j] = 0; &#125; for (j = 0; j &lt; num; j++) &#123; k = (arr[j] / index) % 10; count[k]++; &#125; for (j = 1; j &lt; 10; j++) &#123; count[j] = count[j - 1] + count[j]; &#125; for (j = num - 1; j &gt;= 0; j--) &#123; k = (arr[j] / index) % 10; tmp[count[k] - 1] = arr[j]; count[k]--; &#125; index *= 10; for (j = 0; j &lt; num; j++) &#123; arr[j] = tmp[j]; &#125; &#125; delete[] tmp; delete[] count;&#125;int main()&#123; int array[] = &#123;1,3,6,2,5,8,7,9,4,6,12,30,300&#125;; const int num = sizeof(array) / sizeof(array[0]); bucketsort(array,num); for (int i = 0; i &lt;sizeof(array) / sizeof(array[0]); i++) &#123; cout &lt;&lt; array[i] &lt;&lt; " "; &#125; return 0;&#125; 结果]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2018%2F06%2F21%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序（Mergesort)名词解释 ：归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 算法原理归并排序采用分而治之思想将数组内容划分成许多个单位，使每个单位内序列为有序再合并各个有序的序列。图解如下： 算法描述:时间复杂度:O(n log n)空间复杂度:O（n)算法稳定性：稳定 算法实现步骤：第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置。第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾。 算法实现实现归并排序首先要实现两个有序数组的合并：算法如下: 12345678910111213141516171819void MemeryArray(int a[], int n, int b[], int m, int c[]) &#123; int i, j, k; i = j = k = 0; while (i &lt; n &amp;&amp; j &lt; m) &#123; if (a[i] &lt; b[j]) c[k++] = a[i++]; else c[k++] = b[j++]; &#125; while (i &lt; n) c[k++] = a[i++]; while (j &lt; m) c[k++] = b[j++]; &#125; 有了合并以后就完成了算法的主体，全部实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void mergetarr(int arr[], int left, int right, int tmp[])//合并算法&#123; int i, j, k; i = left; k = 0; int mid = (left + right) / 2; j = mid+1; while (i&lt;=mid&amp;&amp;j&lt;=right ) &#123; if (arr[i]&lt;=arr[j]) &#123; tmp[k++]=arr[i++]; &#125; else &#123; tmp[k++] = arr[j++]; &#125; &#125; while (i&lt;=mid) &#123; tmp[k++] = arr[i++]; &#125; while (j&lt;=right) &#123; tmp[k++] = arr[j++]; &#125; for (i = 0; i &lt; k; i++) arr[left + i] = tmp[i];&#125;void mergetsort(int arr[], int left, int right,int tmp[])//归并排序&#123; if (left&lt;right ) &#123; int mid = (right + left) / 2; mergetsort(arr,left,mid,tmp);//左边归并 mergetsort(arr, mid+1, right,tmp);//右边归并 mergetarr(arr, left, right, tmp);//合并左右 &#125;&#125;int main()&#123; int array[] = &#123;1,3,6,2,5,8,7,9,4,6,12,16,13,25,14,26,25,28,29,31,89,56,14,25,58,78,36,14,17,22&#125;; const int num = sizeof(array) / sizeof(array[0]); int *p = new int[num]; mergetsort(array, 0, sizeof(array) / sizeof(array[0])-1,p); for (int i = 0; i &lt;sizeof(array) / sizeof(array[0]); i++) &#123; cout &lt;&lt; array[i] &lt;&lt; " "; &#125; delete[] p; return 0;&#125; 结果：]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法的稳定性]]></title>
    <url>%2F2018%2F06%2F21%2F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%2F</url>
    <content type="text"><![CDATA[排序算法的稳定性名词解释：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。 判断方法对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。举例：123456789101112131415161718192021void BubbleSort(int *arr, int n)&#123; int i, j, flag = 1; int temp; for (i = 1; i &lt; n &amp;&amp; flag == 1; i++) &#123; flag = 0; for (j = 0; j &lt; n - i; j++) &#123; if (arr[j] &gt;arr[j + 1]) &#123; flag = 1; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125;&#125;/*此算法本来是稳定的但是如果将判断条件改为a[j].key &gt;=a[j+1].key，则会影响原来数值相同数据的的位置，就会变成不稳定的排序方法*/ 常见算法的稳定性分析堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。 其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就 是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。 八大排序分析：(1)冒泡排序冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无 聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。(2)选择排序选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。(3)插入排序插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。(4)快速排序快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。(5)归并排序归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。(6)基数排序基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。(7)希尔排序(shell)希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。(8)堆排序我们知道堆的结构是节点i的孩子为2i和2i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。 稳定性的意义不需要用到稳定性： 如果只是简单的进行数字的排序，那么稳定性将毫无意义，如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧将毫无意义，如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧将毫无意义。需要用到稳定性： 排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法，例如要排序的内容是一组原本按照价格高低排序的货物，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的货物依旧保持着价格高低的排序，只有销量不同的才会重新排序，因此如果需求不需要保持初始的排序意义，那么使用稳定性算法和不稳定算法是一样的。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[希尔排序（Shell’s Sort)名词解释：希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 希尔排序是基于插入排序的以下两点性质而提出改进方法的：1.插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。2.但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 算法思想教科书表达：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2(小于d1）重复上述的分组和排序，直至所取的增量 =1( &lt; …&lt; &lt; d2 &lt; d1)，即所有记录放在同一组中进行直接插入排序为止。简单来说：一个书架放着一排书，现在从第一本书起每数X本书，就在那本书上贴红色贴纸，贴完红色贴纸后，再次从第二本书起每数X本书就贴上蓝色贴纸（跟之前颜色不同即可），重复贴纸过程，直到所有书都贴满贴纸。接着对有相同颜色贴纸的书做插入排序。然后撕掉所有贴纸后重新对书进行贴纸，这次则每数Y本书就贴纸（Y &lt; X）,所有书贴满后再进行插入排序。重复贴纸排序、贴纸排序这个过程，直到最后每数1本书就贴纸（也就是每本书都贴同样颜色贴纸），再插入排序为止。话不多说，看图 算法分析稳定性：由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。时间复杂度：O(n^2)空间复杂度：O(1) 常见排序算法一般按平均时间复杂度分为两类：O(n^2)：冒泡排序、选择排序、插入排序O(nlogn)：归并排序、快速排序、堆排序1w和10w数据效率如下： 算法效率正如我们所知道的希尔排序的增量序列是影响希尔排序效率的最关键因素，至今为止还没有一个最完美的增量序列公式。可究竟应该选取什么样的增量才是最好，目前还是一个数学难题。看如下两个增量序列：n/2、n/4、n/8…11、3、7…2^k-1第一个序列称为希尔增量序列，使用希尔增量时，希尔排序在最坏情况下的时间复杂度为O(n*n)。第二个序列称为Hibbard增量序列，使用Hibbard增量时，希尔排序在最坏情况下的时间复杂度为O(n^3/2)。 10w数据对比如下图： 算法实现12345678910111213141516171819202122232425262728293031323334353637383940void shellsort(int* arr, int size)//希尔排序&#123; if(size&lt;=0||arr==NULL) &#123; return; &#125; int div = 0; int i, j, k = 0; for (div = size / 2; div &gt;= 1; div /= 2)//定义增量 &#123; for (i = 0; i &lt; div; i++)//分成div组 &#123; for (j = i; j &lt; size; j += div)//对数据插入排序 &#123; for (k = i; k &lt; size - div; k += div)&#123; if (arr[j] &lt; arr[k]) &#123; swap(arr[j], arr[k]);//交换数据的值 &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; int array[] = &#123;1,3,6,2,5,8,7,9,4,6,12,16,13,25,14,26,25,28,29,31,22&#125;; shellsort(array, sizeof(array)/sizeof(array[0])); /*for (auto it: array) &#123; cout &lt;&lt; it; &#125;*/ for (int i = 0; i &lt;sizeof(array) / sizeof(array[0]); i++) &#123; cout &lt;&lt; array[i] &lt;&lt; " "; &#125; return 0;&#125; 截图]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2018%2F06%2F18%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序（ Heap Sort )堆排序要用到堆，那什么是堆呢？可以参考我的一博客什么是堆？ 名词解释：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd）和威廉姆斯(J．Williams）在1964年共同发明了著名的堆排序算法。 算法分析堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用Heapify实现的。平均性能：O(N*logN) 其他性能:由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。堆排序是就地排序，辅助空间为O(1)。堆排序是不稳定的排序方法（当数组中有相等元素时，堆排序算法对这些元素的处理方法不止一种）。（排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前 和排序后他们的相对位置不发生变化）。 一般步骤1.将无序序列构建成一个堆，根据升序降序需求选择大顶堆（升序）或小顶堆（降序）。2.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端。3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 将堆化为数组： 具体实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041void adjust(int arr[], int len, int index)//调整&#123; int left = 2 * index + 1; int right = 2 * index + 2; int maxIdx = index; if (left&lt;len &amp;&amp; arr[left] &gt; arr[maxIdx]) maxIdx = left; if (right&lt;len &amp;&amp; arr[right] &gt; arr[maxIdx]) maxIdx = right; // maxIdx是3个数中最大数的下标 if (maxIdx != index) // 如果maxidx被更新 &#123; swap(arr[maxIdx], arr[index]);//交换 adjust(arr, len, maxIdx); // 递归调整其他不满足堆性质的部分 &#125;&#125;void heapSort(int arr[], int size)//堆排序&#123; for (int i = size / 2 - 1; i &gt;= 0; i--) // 对每一个非叶结点进行堆调整(从最后一个非叶结点开始) &#123; adjust(arr, size, i); &#125; for (int i = size - 1; i &gt;= 1; i--) &#123; swap(arr[0], arr[i]); // 将当前最大的放置到数组末尾 adjust(arr, i, 0); // 将未完成排序的部分继续进行堆排序 &#125;&#125;int main()&#123; int array[8] = &#123; 5, 1, 6, 3, 8, 4, 7, 10 &#125;; heapSort(array, 8); /*for (auto it: array) &#123; cout &lt;&lt; it; &#125;*/ for (int i = 0; i &lt;sizeof(array)/sizeof(array[0]); i++) &#123; cout &lt;&lt; array[i] &lt;&lt;" "; &#125; return 0;&#125; 结果]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是堆]]></title>
    <url>%2F2018%2F06%2F17%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%2F</url>
    <content type="text"><![CDATA[堆(heap)堆是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆的性质：1.堆中某个节点的值总是不大于或不小于其父节点的值。2.堆总是一棵完全二叉树。 堆的分类将根节点最大的堆叫做最大堆或大顶堆，根节点最小的堆叫做最小堆或小顶堆。常见的堆有二叉堆、斐波那契堆等。堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)若将和此次序列对应的一维数组（即以一维数组作此序列的存储结构）看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。由此，若序列{k1,k2,…,kn}是堆，则堆顶元素（或完全二叉树的根）必为序列中n个元素的最小值（或最大值）。每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：大堆：小堆： 堆的操作build:建立一个空堆；insert:向堆中插入一个新元素；update：将新元素提升使其符合堆的性质；get：获取当前堆顶元素的值；delete：删除堆顶元素；heapify：使删除堆顶元素的堆再次成为堆。某些堆实现还支持其他的一些操作，如斐波那契堆支持检查一个堆中是否存在某个元素。 建堆效率n个结点的堆，高度d =log2n。根为第0层，则第i层结点个数为2i，考虑一个元素在堆中向下移动的距离。大约一半的结点深度为d-1，不移动（叶）。四分之一的结点深度为d-2，而它们至多能向下移动一层。树中每向上一层，结点的数目为前一层的一半，而子树高度加一。这种算法时间代价为Ο（n)由于堆有log n层深，插入结点、删除普通元素和删除最小元素的平均时间代价和时间复杂度都是Ο（log n）。 关于堆的操作实现在程序中，堆用于动态分配和释放程序所使用的对象。在以下情况中调用堆操作：1.事先不知道程序所需对象的数量和大小。2.对象太大，不适合使用堆栈分配器。堆使用运行期间分配给代码和堆栈以外的部分内存。传统上，操作系统和运行时库随附了堆实现。当进程开始时，操作系统创建称为进程堆的默认堆。如果没有使用其他堆，则使用进程堆分配块。语言运行时库也可在一个进程内创建单独的堆。（例如，C 运行时库创建自己的堆。）除这些专用堆外，应用程序或许多加载的动态链接库 (DLL) 之一也可以创建并使用单独的堆。Win32 提供了一组丰富的 API用于创建和使用专用堆。有关堆函数的优秀教程，请参阅 MSDN 平台 SDK 节点。当应用程序或 DLL 创建专用堆时，这些堆驻留于进程空间中并且在进程范围内是可访问的。某一给定堆分配的任何数据应为同一堆所释放。（从一个堆分配并释放给另一个堆没有意义。）在所有虚拟内存系统中，堆位于操作系统的虚拟内存管理器之上。语言运行时堆也驻留在虚拟内存之上。某些情况下，这些堆在操作系统堆的上层，但语言运行时堆通过分配大的块来执行自己的内存管理。绕开操作系统堆来使用虚拟内存函数可使堆更好地分配和使用块。典型的堆实现由前端分配器和后端分配器组成。前端分配器维护固定大小块的自由列表。当堆收到分配调用后，它尝试从前端列表中查找自由块。如果此操作失败，则堆将被迫从后端（保留和提交虚拟内存）分配一个大块来满足请求。通常的实现具有每个块分配的开销，这花费了执行周期，也减少了可用存储区。单个全局锁可防止多线程同时使用堆。此锁主要用于保护堆数据结构不受多线程的任意访问。当堆操作过于频繁时，此锁会对性能造成负面影响。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#pragma oncetemplate&lt;class T&gt;class JBMinHeap&#123;private: //申请堆空间 T *_minHeap = NULL; int _index,_maxSize;public: JBMinHeap(int maxSize) &#123; _maxSize = maxSize; _minHeap = new T[_maxSize]; _index = -1; &#125; JBMinHeap(JBMinHeap &amp;h) &#123; _index = h._index; _maxSize = h._maxSize; _minHeap = new T[_maxSize]; for (int i = 0;i&lt;_maxSize) &#123; *_minHeap[i] = *h._minHeap[i]; &#125; &#125; ~JBMinHeap() &#123; delete[]_minHeap; &#125; //获取整个最小堆的头部指针 T * getMinHeap() &#123; return _minHeap; &#125; //判断堆是不是空的 bool isEmpty() &#123; return _index == -1; &#125; bool add(T x) &#123; if (isFull()) &#123; return false; &#125; _index++; _minHeap[_index] = x; return true; &#125; bool isFull() &#123; return _index == _maxSize; &#125; //堆进行向下调整 void adjustDown(int index); //队进行向上调整 void adjustUp(int index); //建堆运算 void createMinHeap() &#123; if (isEmpty()) &#123; return; &#125; for (int i = (_index-1)/2;i &gt;-1;i--) &#123;//直接从倒数第二层 逐层向下调整 adjustDown(i); &#125; &#125;&#125;;template&lt;class T&gt;void JBMinHeap&lt;T&gt;::adjustDown(int index) &#123; if (isEmpty()) &#123; return; &#125; while (index&lt;_index) &#123; T temp = _minHeap[index];//将当前索引的位置的值保存下来 int oneC = 2 * index + 1;//获取到两个孩子的位置 int twoC = 2 * index + 2; if (oneC == _index) &#123;//若第一个孩子是整个堆最后一个位置 则直接执行交换操作并结束执行 _minHeap[index] = _minHeap[oneC]; _minHeap[oneC] = temp; return; &#125; if (twoC &gt;_index) &#123;//如果第二个孩子的索引位置越界 结束执行 return; &#125; if (_minHeap[oneC] &lt;= _minHeap[twoC]) &#123;//正常情况的数据交互执行 if (temp &gt; _minHeap[oneC]) &#123; _minHeap[index] = _minHeap[oneC]; _minHeap[oneC] = temp; index = oneC; &#125; else &#123;//如果该处索引值已经是比两个孩子小 则结束循环 index = _index; &#125; &#125; else &#123; if (temp &gt; _minHeap[twoC]) &#123; _minHeap[index] = _minHeap[twoC]; _minHeap[twoC] = temp; index = twoC; &#125; else &#123; index = _index; &#125; &#125; &#125;&#125;template&lt;class T&gt;void JBMinHeap&lt;T&gt;::adjustUp(int index) &#123; if (index &gt; _index) &#123;//大于堆的最大值直接return return; &#125; while (index&gt;-1) &#123; T temp = _minHeap[index]; int father = (index - 1) / 2; if (father &gt;= 0) &#123;//若果索引没有出界就执行想要的操作 if (temp &lt; _minHeap[father]) &#123; _minHeap[index] = _minHeap[father]; _minHeap[father] = temp; index=father; &#125; else &#123;//若果已经是比父亲大 则直接结束循环 index = -1; &#125; &#125; else//出界就结束循环 &#123; index = -1; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空间复杂度]]></title>
    <url>%2F2018%2F06%2F15%2F%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[空间复杂度 前面刚讲了时间复杂度，有兴趣的去看看什么是时间复杂度？ 名词解释：空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。 度量方法 类似于 时间复杂度的讨论，一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。空间复杂度(SpaceComplexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\”进行的，是节省存储的算法，有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。 分析方法分析一个算法所占用的存储空间要从各方面综合考虑。如对于递归算法来说，一般都比较简短，算法本身所占用的存储空间较少，但运行时需要一个附加堆栈，从而占用较多的临时工作单元；若写成非递归算法，一般可能比较长，算法本身占用的存储空间较多，但运行时将可能需要较少的存储单元。一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。若一个算法为 [2] 递归算法，其空间复杂度为递归所使用的堆栈空间的大小，它等于一次调用所分配的临时存储空间的大小乘以被调用的次数(即为递归调用的次数加1，这个1表示开始进行的一次非递归调用)。算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)；当一个算法的空间复杂度与n成线性比例关系时，可表示为O(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。故一个算的空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。所以它强调的是使用的辅助空间的的大小，而不是指所有的数据所占用的空间。以斐波那契算法为例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152long long* fib(long long n) &#123; assert(n&gt;=0); long long* ptr=new long long[n+1]; ptr[0]=0; ptr[1]=1; for(int i=2;i&lt;=n;++i) &#123; ptr[i]=ptr[i-1]+ptr[i-2]; &#125; return ptr; &#125; /*对于这种算法，函数真正执行次数为n-1,所以忽略常数后，时间复杂度为O(n);因为开辟了n+1个空间，有n+1个辅助空间，所以空间复杂度为O(n).*/long long fib(long long n) &#123; assert(n&gt;=0); long long first=0; long long second=1; long long ret=0; for(int i=2;i&lt;=n;i++) &#123; ret=first+second; first=second; second=ret; &#125; return ret; &#125; /*这是非递归的另一种算法，函数真正执行次数依然为n-1,所以忽略常数后，时间复杂度还是O(n);由于采用变量交换的方式，所以在这里辅助空间个数为一个常数，空间复杂度为O(1).*///递归写法#include&lt;assert.h&gt; #include&lt;iostream&gt; using namespace std; long long fib(long long n) &#123; assert(n&gt;=0); return (n&lt;2)?(n):(fib(n-1)+fib(n-2)); &#125; /*递归算法的时间复杂度计算方法是:递归总次数*每次递归次数；递归算法的时间复杂度计算方法是：递归深度*每次递归所需的辅助空间个数.可以得出斐波那契递归算法时间复杂度：O（2^N），空间复杂度为:O(N)*/int main() &#123; long long value=fib(15); cout&lt;&lt; value &lt;&lt;endl; system("pause"); return 0; &#125; 时间复杂度与空间复杂度的联系对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。算法的时间复杂度和空间复杂度合称为算法的复杂度。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间复杂度]]></title>
    <url>%2F2018%2F06%2F15%2F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[算法复杂度算法复杂度分为时间复杂度和空间复杂度。其作用： 时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。（算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度）。 时间复杂度时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。 时间复杂度计算方法1.一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。分析：随着模块n的增大，算法执行的时间的增长率和 f(n) 的增长率成正比，所以 f(n) 越小，算法的时间复杂度越低，算法的效率越高。2.在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级（它的同数量级有以下：1，log2n，n，n log2n ，n的平方，n的三次方，2的n次方，n!），找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数c，则时间复杂度T(n) = O(f(n))。 举例循环如下： 12345678910111213141516171819202122232425262728293031for(i=1; i&lt;=n; ++i)&#123; for(j=1; j&lt;=n; ++j) &#123; c[i][j] = 0;//该步骤属于基本操作执行次数：n的平方次 for(k=1; k&lt;=n; ++k) c[i][j] += a[i][k] * b[k][j];//该步骤属于基本操作执行次数：n的三次方次 &#125;&#125;//则有，根据上面括号里的同数量级，我们可以确定n的三次方为T（n）的同数量级。//则有，然后根据 T(n)/f(n) 求极限可得到常数c。//则该算法的时间复杂度：T(n) = O(n^3) 注：n^3即是n的3次方。例2://如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，//则将并列循环的时间复杂度相加。 for (i=1; i&lt;=n; i++) &#123; x++; &#125; for (i=1; i&lt;=n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; x++; &#125; &#125; //第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)， //则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!) 注意Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。Ο(log2n)、Ο(n)、Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者是有效算法，把这类问题称为P类问题，而把后者称为NP问题。但这也只能计算基本的计算时间复杂度，具体的运行还会与硬件有关。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基本操作]]></title>
    <url>%2F2018%2F06%2F13%2Fmysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Mysql安装mysql 是一个小型的数据库安装过程参考：MySQL安装过程1.首先登入数据库（在cmd窗口进行操作）输入：-u root -p```123456&lt;!--more--&gt;![这里写图片描述](https://img-blog.csdn.net/20180613225925564?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)2.建立一个数据库```create datebase lala；(数据库名，可以根据实际项目取名） 2.使用本数据库table1；```12输入此条语句数据库才能进行操作4.数据库的增删改查操作 增：insert into table(表名） value（);（“()”中数据类型与表单的元素一一对应）删：delete from table where la=1;改：update table set la=1 where dada=”haha”;查：select *(显示全部符号，也可以指定显示内容如dada） from table;125.删除表```drop table tb1; 约束1.空值与非空约束table tb2 (user_name not null,user_age null);```12345678910112.自增约束自动编号 起始为1自动编号的字段必须设置为主键（primary key）例如create table tb2 (user_name auto_increment primary key);auto_increment 必须定义为主键 而主键不一定要是auto increment 3.主键约束primary key主键必须为not null主键会保证唯一性4.唯一约束unique key 保证唯一性### 数据表列操作 1.添加列alter tbale tb1 column a varchar;新增列名为a的字段2.删除列alter table tb1 column x;删除列名为x的字段3.查询表中的所有列名 show columns from 表名;ex:show columns from tb1;4.调整字段的位置(first,last) alter table tb1 modify y int first;将该字段放到最前面去了；5.修改字段的数据类型alter table tb1 modify x smallint;由大类型改到小类型可能会造成数据的丢失；6.修改字段的名称alter table tb1 change x xx int;将x字段更名为xx字段，其类型为int 型该语句修改数据表中字段的名称和数据类型7.查看表中的所有列show columns from tb1;8.输出所有列select from tb1;select from tb1\G 以网格形式输出所有列`]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻转字符串]]></title>
    <url>%2F2018%2F06%2F11%2F%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目输入：i am a student.输出：student.a am i 分析先总体反转，然后逐个单词反转，首先，将字符串完全翻转一次，得到.tneduts a ma i。然后设置两个指针，对单词进行翻转，也就是局部翻转. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void AllReverse(char *pStart, char *pEnd)//全反转&#123; char pTemp; if (pStart == NULL || pEnd == NULL) return; while (pStart &lt; pEnd) &#123; pTemp = *pStart; *pStart = *pEnd; *pEnd = pTemp; pStart++; pEnd--; &#125;&#125;char *Reverse(char *pData)//单词反转&#123; if (pData == NULL) &#123; return NULL; &#125; char *pStart = pData; char *pEnd = pData; while (*pEnd != '\0') &#123; pEnd++; &#125; pEnd--; AllReverse(pStart, pEnd);//全反转 pStart = pEnd = pData; while (*pStart != '\0') &#123; if (*pStart == ' ') &#123; pStart++; pEnd++; &#125; else if (*pEnd == ' ' || *pEnd == '\0') &#123; AllReverse(pStart, --pEnd); pStart = ++pEnd; &#125; else &#123; pEnd++; &#125; &#125; return pData;&#125;int main()// 主函数&#123; char a_arr[100]; char * str = NULL; gets_s(a_arr); str = Reverse(a_arr); cout &lt;&lt; str; return 0;&#125;]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找到数组第一个相同的数]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定一个数组，然找到数组里第一个重复的数字。例： arr[]={1,2,4,3,6,5,6,5,8,9}找到5。 代码1234567891011121314151617181920212223void checknum(int arr[], int num) &#123; int key = arr[0]; int i = 0; for (int j = 0; j &lt; num; j++) &#123; key = arr[j]; for (i = j + 1; i &lt; num; i++) &#123; if (arr[i] == key) &#123; cout &lt;&lt; "该数组有重复数字,数字是：" &lt;&lt; key &lt;&lt; endl; return; &#125; &#125; &#125; cout &lt;&lt; "没有重复的数字"; &#125; int main() &#123; int arr[] = &#123; 1, 2, 3, 4, 5, 4, 7, 8, 9 &#125;; checknum(arr, 9); return 0; 结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[寻找两个链表公共节点]]></title>
    <url>%2F2018%2F06%2F06%2F%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目两个单向链表，找出它们的第一个公共结点。数据类型如下： 12345typedef struct Node&#123; int data; Node* next;&#125;Node; 分析如果两个单向链表有公共的结点，也就是说两个链表从某一结点开始，它们的Next都指向同一个结点。但由于是单向链表的结点，每个结点只有一个Next，因此从第一个公共结点开始，之后它们所有结点都是重合的，不可能再出现分叉。所以，两个有公共结点而部分重合的链表，拓扑形状看起来像一个Y，而不可能像X。看到这个题目，第一反应就是蛮力法：在第一链表上顺序遍历每个结点。每遍历一个结点的时候，在第二个链表上顺序遍历每个结点。如果此时两个链表上的结点是一样的，说明此时两个链表重合，于是找到了它们的公共结点。如果第一个链表的长度为m，第二个链表的长度为n，显然，该方法的时间复杂度为O(mn)。接 下来我们试着去寻找一个线性时间复杂度的算法。我们先把问题简化：如何判断两个单向链表有没有公共结点？前面已经提到，如果两个链表有一个公共结点，那么 该公共结点之后的所有结点都是重合的。那么，它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分，只要分别遍历两个链表到最后一 个结点。如果两个尾结点是一样的，说明它们用重合；否则两个链表没有公共的结点。在上面的思路中，顺序遍历两个链表到尾结点的时候，我们不能保证在两个链表上同时到达尾结点。这是因为两个链表不一定长度一样。但如果假设一个链表比另一个长l个结点，我们先在长的链表上遍历l个结点，之后再同步遍历，这个时候我们就能保证同时到达最后一个结点了。由于两个链表从第一个公共结点考试到链表的尾结点，这一部分是重合的。因此，它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。在这个思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历若干次之后，再同步遍历两个链表，知道找到相同的结点，或者一直到链表结束。此时，如果第一个链表的长度为m，第二个链表的长度为n，该方法的时间复杂度为O(m+n)。 基于这个思路，我们不难写出如下的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;iostream&gt;#include&lt;assert.h&gt;using namespace std;typedef struct Node//数据结构体&#123; int data; Node* next;&#125;Node;Node* findnode(Node* head, int n);Node* init_list(int n)//初始化链表&#123; Node* head = NULL; if (n &lt; 0) &#123; cout &lt;&lt; "链表数目个数有问题" &lt;&lt; endl; &#125; else if (n == 0) &#123; head = NULL; return head; &#125; else &#123; cout &lt;&lt; "请输入 " &lt;&lt; n &lt;&lt; "个数据" &lt;&lt; endl; while (n-- &gt; 0) &#123; Node* ptr = new Node; cin &gt;&gt; ptr-&gt;data; ptr-&gt;next = head; head = ptr; &#125; &#125; return head;&#125;void show(Node *head)//打印链表&#123; if (head == NULL) &#123; cout &lt;&lt; "这是一个空链表" &lt;&lt; endl; &#125; while (head != NULL) &#123; cout &lt;&lt; head-&gt;data &lt;&lt; "-&gt;"; head = head-&gt;next; &#125; cout &lt;&lt; "NULL" &lt;&lt; endl;&#125;int sort_list(Node* head)//遍历链表&#123; int count = 0; if (head == NULL) &#123; cout &lt;&lt; "链表为空" &lt;&lt; endl; &#125; while (head) &#123; head = head-&gt;next; count++; &#125; return count;&#125;Node* findnode(Node* head, int n)&#123; Node* ptr = head; if (NULL == head) &#123; return NULL; &#125; else &#123; while (n--) &#123; ptr = ptr-&gt;next; &#125; &#125; return ptr;&#125;void FindFirstCommonNode(Node* head1, Node* head2)//寻找公共节点&#123; assert(head1); assert(head2); int len1 = sort_list(head1); int len2 = sort_list(head2); int tmp = 0; if (len1 &gt; len2) &#123; tmp = len1 - len2; for (int i = 0; i &lt; tmp; i++) &#123; head1 = head1-&gt;next; &#125; &#125; else &#123; tmp = len2 - len1; for (int i = 0; i &lt; tmp; i++) &#123; head2 = head2-&gt;next; &#125; &#125; while ((head1 != NULL) &amp;&amp; (head2 != NULL) &amp;&amp; (head1 != head2)) &#123; head1 = head1-&gt;next; head2 = head2-&gt;next; &#125; Node* key = head1; cout &lt;&lt; "公共节点为" &lt;&lt; key-&gt;data &lt;&lt; endl;&#125;int main()&#123; int n; int m; cout &lt;&lt; "请输入你想要创建的链表节点个数" &lt;&lt; endl; cin &gt;&gt; n; Node* ptr = init_list(n); show(ptr); cout &lt;&lt; "请输入你想要创建的链表节点个数" &lt;&lt; endl; cin &gt;&gt; m; Node* ptr1 = init_list(m); findnode(ptr1,m-1)-&gt;next = findnode(ptr, 3); show(ptr1); FindFirstCommonNode(ptr, ptr1); return 0;&#125; 截图]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言注释转C++注释]]></title>
    <url>%2F2018%2F06%2F04%2FC%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A%E8%BD%ACC%2B%2B%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[题目要求int a = 10;// 1.一般情况int num = 0;/_ int i = 0; _/ // 2.换行问题/_ int i = 0; /int j = 0;/ int i = 0; _/int j = 0; // 3.匹配问题/_int i = 0;/_xxxxx*/ // 4.多行注释问题/_int i=0;int j = 0;int k = 0;_/int k = 0; // 5.连续注释问题/int a=0;//int b=0;/ // 6.连续的/问题/*/ // 7.C++注释问题// /xxxxxxxxxxxx/ 问题分析 代码片头文件12345678910111213141516171819202122#ifndef __COMMENTCONVERT_HEADFILE__ #define __COMMENTCONVERT_HEADFILE__#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; enum STATE &#123;NUL,C,CPP,END&#125;;void CommentConvert(FILE *pfin, FILE * pfout);void DoNULConvert(FILE *pfin, FILE * pfout, enum STATE * state); void DoCConvert(FILE *pfin, FILE * pfout, enum STATE * state);void DoCPPConvert(FILE *pfin, FILE * pfout, enum STATE * state);#endif 源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include"标头.h"#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void CommentConvert(FILE *pfin, FILE * pfout)&#123; enum STATE state = NUL;//初始化状态 为 无注释状态 while (state != END) &#123; switch (state) &#123; case NUL: &#123; DoNULConvert(pfin, pfout, &amp;state); &#125; break; case C: &#123; DoCConvert(pfin, pfout, &amp;state); &#125; break; case CPP: &#123; DoCPPConvert(pfin, pfout, &amp;state); &#125; break; default: break; &#125; &#125;&#125;void DoNULConvert(FILE *pfin, FILE * pfout, enum STATE * state)&#123; int start = 0; int next = 0; start = fgetc(pfin); switch (start) &#123; case '/': &#123; next = fgetc(pfin); switch (next) &#123; case '*':// 表示进入C语言注释状态 &#123; fputc('/', pfout); fputc('/', pfout); *state = C;//状态转换为 C注释状态 &#125; break; case '/':// 表示进入C++注释状态 &#123; fputc(start, pfout); fputc(next, pfout); *state = CPP; //状态转换为 C++注释状态 &#125; break; default: &#123; fputc(start, pfout); fputc(next, pfout); &#125; break; &#125; &#125; break; case EOF: &#123; fputc(start, pfout); *state = END; &#125; break; default://表示遇到的不是注释 ，状态不变 &#123; fputc(start, pfout); //将读取的字符输出到文件 &#125; break; &#125;&#125;//c状态转换 void DoCConvert(FILE *pfin, FILE * pfout, enum STATE * state)&#123; int start = 0; int next = 0; int then = 0; start = fgetc(pfin); switch (start) &#123; case '*'://遇到'*'表示C语言注释状态 &#123; next = fgetc(pfin); switch (next) &#123; case '/': &#123; then = fgetc(pfin); if (then == '\n') &#123; fputc(then, pfout); &#125; else &#123; fputc('\n', pfout); ungetc(then, pfin); &#125; *state = NUL; &#125; break; default: &#123; fputc(start, pfout); ungetc(next, pfin); &#125; break; &#125; &#125; break; case '\n': &#123; fputc(start, pfout); fputc('/', pfout); fputc('/', pfout); &#125; break; default: fputc(start, pfout); break; &#125;&#125;//c++状态转换void DoCPPConvert(FILE *pfin, FILE * pfout, enum STATE * state)&#123; int start = 0; int next = 0; int then = 0; start = fgetc(pfin); switch (start) &#123; case '\n': &#123; fputc(start, pfout); *state = NUL; &#125; break; default: fputc(start, pfout); break; &#125;&#125; 测试文件123456789101112131415161718192021222324252627#include "标头.h"int main()&#123; FILE *pfin = NULL; FILE *pfout = NULL; pfin = fopen("input.c", "r"); if (pfin == NULL) &#123; perror("input file open:"); exit(EXIT_FAILURE); &#125; pfout = fopen("output.c", "w"); if (pfout == NULL) &#123; perror("output file open:"); fclose(pfin); exit(EXIT_FAILURE); &#125; CommentConvert(pfin, pfout); printf("注释转换成功\n"); fclose(pfin); fclose(pfout); system("pause"); return 0;&#125;]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“链表倒数第K个节点”]]></title>
    <url>%2F2018%2F06%2F03%2F%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，输出该链表中倒数第k个结点。思路：设置两个指针指向头节点分别为p，和ptr；让p指针先走k-1次，然后让ptr跟着p指针一直遍历下去直到遍历完整个链表，这时ptr指针就指向倒数第k个节点了。有些兴趣的同学可以仔细琢磨。很有意思。附上我的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;using namespace std;typedef struct Node//链表结构&#123; int data; Node* next; &#125;Node;Node* init_list( int n)//初始化链表&#123; Node* head = NULL; if (n &lt; 0) &#123; cout &lt;&lt; "链表数目个数有问题" &lt;&lt; endl; &#125; else if(n == 0) &#123; head = NULL; return head; &#125; else &#123; cout&lt;&lt; "请输入 " &lt;&lt; n &lt;&lt; "个数据"&lt;&lt;endl; while (n-- &gt; 0) &#123; Node* ptr = new Node; cin &gt;&gt; ptr-&gt;data; ptr-&gt;next = head; head= ptr; &#125; &#125; return head;&#125;void show(Node *head)//打印链表 &#123; if (head == NULL) &#123; cout &lt;&lt; "这是一个空链表" &lt;&lt; endl; &#125; while (head!=NULL) &#123; cout &lt;&lt; head-&gt;data &lt;&lt; "-&gt;"; head = head-&gt;next; &#125; cout &lt;&lt; "NULL"&lt;&lt;endl; &#125; Node* FindKthToTail(Node* head, int k)//链表节点 &#123; if (NULL == head&amp;&amp;k&lt;=0) &#123; return NULL; &#125; Node* p = head, *ptr = head; for (int i = 0; i &lt; k-1; i++) &#123; if (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; &#125; while (p-&gt;next) &#123; ptr = ptr-&gt;next; p = p-&gt;next; &#125; return ptr; &#125;int main() //主函数 &#123; // Node*ptr3= create_list(); // show(ptr3); int n; cout &lt;&lt; "请输入你想要创建的链表节点个数" &lt;&lt; endl; cin &gt;&gt; n; Node* ptr=init_list(n); show(ptr); //insert(ptr,4,5); // show(ptr); //Node* ptr2=resevertlist(ptr); //show(ptr2); // minus_point(ptr2, 2); // show(ptr2); // Node*ptr3= minus_point(ptr2, 1); // show(ptr3); //int count= sort_list(ptr3); //cout &lt;&lt; count &lt;&lt; endl; Node*ptr4 = FindKthToTail(ptr, 3); cout &lt;&lt; ptr4-&gt;data; return 0; &#125; 运行结果：]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组的查找]]></title>
    <url>%2F2018%2F06%2F01%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目分析矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，因此从左下角开始查找，当要查找数字比左下角数字大时。右移要查找数字比左下角数字小时，上移。例矩阵： 1 2 3 4 5 6 7 8 9 具体算法如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt; using namespace std; int main() &#123; int i, j; int key = 0; int const row = 3; int const col = 3; int arr[row][col] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; cout &lt;&lt; "输入要查找的值" &lt;&lt; endl; cin &gt;&gt; key; /* for (i = 0; i &lt; row; i++) &#123; for (j = 0; j &lt; col; j++) &#123; cin &gt;&gt; arr[row][col]; &#125; &#125;*/ for (i = row - 1, j = 0;(i &gt;= 0 )&amp;&amp; (j &lt; col);) &#123; if (arr[i][j] == key) &#123; cout &lt;&lt; "该数存在!" &lt;&lt; endl; return 0; &#125; if (arr[i][j]&gt;key) &#123; i--; continue; &#125; if (arr[i][j] &lt; key) &#123; j++; &#125; &#125; cout &lt;&lt; "该数不存在" &lt;&lt; endl; return 0; &#125;]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求二进制中1的个数]]></title>
    <url>%2F2018%2F05%2F31%2F%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[方法一：思路：如果一个数与1作与运算则可以发现该数最后一位数为1，否则为0.按照此思路可以有以下代码： 12345678910111213141516171819202122#include &lt;iostream&gt; using namespace std; int main() &#123; int n = 0; cout &lt;&lt; "输入一个数"; cin &gt;&gt; n; int count = 0; while (n) &#123; if (n &amp; 1) &#123; count++; &#125; n &gt;&gt;= 1; &#125; cout &lt;&lt; "1的个数为"&lt;&lt;count&lt;&lt;endl; return 0; &#125; 但是此方法存在缺陷如果输入的数为负数则会无限死循环 方法二：首先把n与1做与运算，判断n的最低位是不是为1。接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1….这样反复左移，每次能判断n的其中一位是不是1.这个解法中循环的次数等于整数二进制的位数，32位的整数需要循环32次 1234567891011121314151617181920212223#include &lt;iostream&gt; using namespace std; int main() &#123; int n = 0; int key = 1; cout &lt;&lt; "输入一个数"; cin &gt;&gt; n; int count = 0; while (key) &#123; if (n &amp; key) &#123; count++; &#125; key &lt;&lt;= 1; &#125; cout &lt;&lt; "1的个数为"&lt;&lt;count&lt;&lt;endl; return 0; &#125; 方法三思路：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0，那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。 12345678910111213141516171819#include &lt;iostream&gt; using namespace std; int main() &#123; int n = 0; cout &lt;&lt; "输入一个数"; cin &gt;&gt; n; int count = 0; while (n) &#123; n = ((n - 1)&amp; n); count++; &#125; cout &lt;&lt; "1的个数为"&lt;&lt;count&lt;&lt;endl; return 0; &#125;]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程第一课]]></title>
    <url>%2F2018%2F05%2F30%2F%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[第一题有一组数，对于其中任意两个数组，若前面一个大于后面一个数字，则这两个数字组成一个逆序对。请设计一个高效的算法，计算给定数组中的逆序对个数。 给定一个int数组A和它的大小n，请返回A中的逆序对个数。保证n小于等于5000。测试样例：[1,2,3,4,5,6,7,0],8返回：7答案如下： 123456789101112131415161718192021/*冒泡排序时做了多少次交换就有多少个逆序*/class AntiOrder &#123;public: int count(vector&lt;int&gt; A, int n) &#123; // write code here int count = 0; int i,j; if(n &lt; 2) return n; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n-i-1;j++)&#123; if(A[j]&gt;A[j+1])&#123; swap(A[j],A[j+1]); count++; &#125; &#125; &#125; return count; &#125;&#125;; 第二题：写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。例如输入：1abcd 输出1dcba 答案如下： 12345678910//最简洁#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; for(int i = str.size()-1; i &gt;=0;i--) cout &lt;&lt; str[i];&#125; 方法二：利用栈 12345678910111213141516171819//这样的输出可以利用栈后进先出的结构#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main(void)&#123; char ch; stack&lt;char&gt; ch_stack; while(cin&gt;&gt;ch) &#123; ch_stack.push(ch); &#125; while(!ch_stack.empty()) &#123; cout&lt;&lt;ch_stack.top(); ch_stack.pop(); &#125; return 0;&#125; 方法三： 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; reverse(str.begin(), str.end()); cout &lt;&lt; str; return 0;&#125;]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2F2018%2F05%2F29%2F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件操作C++ 通过以下几个类支持文件的输入输出：ofstream: 写操作（输出）的文件类 (由ostream引申而来)ifstream: 读操作（输入）的文件类(由istream引申而来)fstream: 可同时读写操作的文件类 (由iostream引申而来) 打开文件1.建立联系1ofstream examplefile(&quot;example.txt&quot;);//声明类example并与创建的文件example.txt联系 其中examplefile是ofstream的对象，对象（examplefile）第一个操作通常与一个真正的文件（example.txt）联系起来，改文件由一个流对象（该例子为examplefile）来表示（这些类的一个实例），对改对象进行的操作就是对该对象联系的文件操作。2.判断文件是否打开 1examplefile.is_open()//检查一个文件（examplefile对象所联系的文件）是否被顺利打开 3.向文件中写入数据，并关闭文件 123examplefile &lt;&lt; &quot;This is a line.\n&quot;;examplefile &lt;&lt; &quot;This is another line.\n&quot;;examplefile.close(); ps:为防止流对象被销毁时还联系着打开的文件，析构函数一般将会自动调用关闭函数close 代码示例 123456789101112131415//建立一个文件并写入内容 #include &lt;fstream&gt; using namespace std; int main() &#123; ofstream examplefile("example.txt"); if (examplefile.is_open()) &#123; examplefile &lt;&lt; "This is a line.\n"; examplefile &lt;&lt; "This is another line.\n"; examplefile.close(); &#125; return 0; &#125; 1examplefile.eof();//eof ，它是ifstream 从类 ios 中继承过来的，当到达文件末尾时返回true 文件读取： 12examplefile.getline(buffer,100);//getline，读取一行字符，直到遇见换行符。getline具有返回值：成功：返回读取的字节数 失败：返回-1。 代码示例： 1234567891011121314151617181920//对文件的读取示例 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;cstdlib&gt; using namespace std; int main () &#123; char buffer[256]; //定义一个数组，用来存放字符 ifstream examplefile("example.txt"); //声明一个对象与要读的文件联系 if (! examplefile.is_open()) //判断是否打开&#123; cout &lt;&lt; "Error opening file"; exit (1); &#125; while (!examplefile.eof()) &#123; examplefile.getline(buffer,100); cout&lt;&lt;buffer&lt;&lt; endl; &#125; return 0; &#125; read和write函数分别为istream和ostream的成员函数，前者被ifstream所继承，后者被ostream所继承。 代码示例：123456789101112131415161718#include &lt;fstream&gt; #include &lt;iostream&gt; using namespace std; int main () &#123; const char * filename = "example.txt"; char * buffer;//buffer是一块内存地址，用来存储或读取数据 long size;//size 是一个整数值，表示要从缓存（buffer）中读出或写入的字符数 ifstream file(filename, ios::in|ios::binary|ios::ate); size = file.tellg(); file.seekg(0, ios::beg); buffer = new char [size]; file.read(buffer, size); file.close(); cout &lt;&lt;"the complete file is in a buffer"; delete[] buffer; return 0; &#125; 具体read，write可参照CSDN专门有一篇博客专门介绍。]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++输入流]]></title>
    <url>%2F2018%2F05%2F28%2FC%2B%2B%E8%BE%93%E5%85%A5%E6%B5%81%2F</url>
    <content type="text"><![CDATA[CINcin是C++编程语言中的标准输入流对象，即istream类的对象。cin主要用于从标准输入读取数据，这里的标准输入，指的是终端的键盘。此外，cout是流的对象，即ostream类的对象，cerr是标准错误输出流的对象，也是ostream 类的对象。这里的标准输出指的是终端键盘，标准错误输出指的是终端的屏幕。在理解cin功能时，不得不提标准输入缓冲区。当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键(\r)会被转换为一个换行符\n，这个换行符\n也会被存储在cin的缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了123456这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。cin读取数据也是从缓冲区中获取数据，缓冲区为空时，cin的成员函数会阻塞等待数据的到来，一旦缓冲区中有数据，就触发cin的成员函数去读取数据。 使用cin从标准输入读取数据时，通常用到的方法有cin&gt;&gt;，cin.get，cin.getlinecin&gt;&gt;&lt;变量1&gt;[&gt;&gt;&lt;变量2&gt;&gt;&gt;…&gt;&gt;&lt;变量n&gt;]; 其中“&gt;&gt;”称为提取运算符，用于读取用户输入的数据，赋给变量。在cin之后“&gt;&gt;&lt;变量&gt;”可重复多次。输入多个数据时数据之间要用空格、TAB、或者ENTER键隔开，系统会自动跳过空格和回车符，将输入的数据赋给各提取运算符的变量。回车符有两个作用一个是分隔符另一个是刷新缓冲区，并通知cin已经输入一行数据。12345678910111213141516#include &lt;iostream&gt;using namespace std;int main()&#123; char a; int b; float c; string cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 但如果提取运算符的&lt;&lt;后面的变量是字符型，则必须输入字符。单当要获取输入的空格或ENTER键，直接用”&lt;&lt;”不能实现，必须借助于cin.get函数,其一般形式为:123456789101112131415cin.get([&lt;字符型变量])#include &lt;iostream&gt;using namespace std;int main()&#123; char a; char b; a=cin.get(); cin.get(b); cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 输入一个空格,一个Enter:注意：（1）从结果可以看出，cin.get()从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取，就出现了如上情况，将换行符读入变量b，输出时换行两次，一次是变量b，一次是endl。（2）cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c) gets读取一行gets是C中的库函数，在&lt; stdio.h&gt;申明，从标准输入设备读字符串，可以无限读取，不会判断上限，以回车结束或者EOF时停止读取，所以程序员应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。 函数原型：123456789101112char *gets( char *buffer );#include &lt;iostream&gt;using namespace std;int main()&#123; char array[20]=&#123;NULL&#125;; gets(array); cout&lt;&lt;array&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 由于此函数是C的库函数,所以不建议使用,在C++中使用会报警告.]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟实现atoi函数]]></title>
    <url>%2F2018%2F05%2F27%2Fatoi%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[atoi函数 atoi函数是把字符串转换成整型数的一个函数，应用在计算机程序和办公软件中。int atoi(const char *nptr) 函数会扫描参数 nptr字符串，跳过前面的空白字符（例如空格，tab缩进）等，可以通过isspace( )函数来检测），直到遇上数字或正负符号才开始做转换，而在遇到非数字或字符串结束符(‘\0’)才结束转换，并将结果返回。如果 nptr不能转换成 int 或者 nptr为空字符串，那么将返回 0 。12345678910#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; int n; char *str = "12345"; n = atoi(str); printf("n=%d\n",n); return 0;&#125; 输出n=123456 模拟实现atoi 代码实现 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt; int StrToInt(char *str) &#123; long number = 0; int flag = 1; //判断符号位 if (NULL == str) &#123; printf("str is NULL"); return 0; &#125; while (*str == ' ') //空格 &#123; str++; &#125; if (*str == '-') //符号位 &#123; flag = -1; str++; //后移3移位 &#125; while ((*str &gt;= '0') &amp;&amp; (*str &lt;= '9'))//转化 &#123; number = number * 10 + *str - '0'; str++; &#125; return flag*number; &#125; int main() &#123; char* str = "-123456"; int tmp = StrToInt(str); cout &lt;&lt; tmp&lt;&lt;endl; &#125;]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针数组和数组指针的区别]]></title>
    <url>%2F2018%2F05%2F26%2F%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88-md%2F</url>
    <content type="text"><![CDATA[昨天聊了常量指针和指针常量的区别，今天继续一个比较容易混淆的话题，指针数组和数组指针=.=! 数组指针含义：指向数组的的指针(1)数组在内存中的表示创建一个数组就是在内存里面开辟一块连续的空间，比如int a[4];就是在内存里面开辟了一个大小为4*sizeof(int)字节的内存空间。而二维数组是特殊的一维数组。1234567#include&lt;stdio.h&gt;void main() &#123; int a[2][2]=&#123;1,2,3,4&#125;;//这是一个2*2的二维数组 int (*p)[2];//数组指针 p=a;//令p指向数组a &#125; 这里p是一个指向数组的指针。 让我们理解数组名和数组指针变量：a,a[0],a[1],p,a+1,a[0]+1,p+1这些分别代表什么意思呢？答案：a是一个数组名，类型是指向一维数组的指针，不是变量，a的值是指针常量，即不能有a++或者a=p这些操作。a指向这块连续空间的首地址，值是&amp;a[0][0]。 a[0]是一维数组名，类型是指向整型的指针，值是&amp;a[0][0]，这个值是一个常量。 a[1]是一维数组名，类型是指向整型的指针，值是&amp;a[1][0]，这个值是一个常量。 p是一个数组指针变量，指向一维数组的指针变量，值是&amp;a[0][0]。可以执行p++;p=a等操作。a+1表示指向下一行元素，也可以理解为指向下一个一维数组。 (a+1)是取出第一行的首地址。 a[0]+1是指向第0行第1个元素，也可以理解为指向一维数组a[0]的第一个元素。 p+1同a+1 (p+1)同_(a+1) 虽然a跟a[0]值是一样，但类型不一样，表示的意义不一样。通过分析就不难理解为什么_(*(a+i)+j)和a[i][j]等效了。 数组名与数组指针变量的区别区别：数组名是指针，类型是指向元素类型的指针，但值是指针常量，声明数组时编译器会为声明所指定的元素数量保留内存空间。数组指针是指向数组的指针，声明指针变量时编译器只为指针本身保留内存空间。 指针数组（存放指针的数组）指针数组：一个存放int类型的数组称为整型数组，那么存放指针的数组就叫指针数组。 #include&lt;stdio.h&gt; void main() { int i=1,j=2;//p先跟[]结合，然后再跟*结合 int *p[2];//指针数组,存放指针的数组 p[0]=&amp;i; p[1]=&amp;j; printf("%d",sizeof(p)); } 此例数组p就两个元素，p[0]是指向i的指针，p[1]是指向j的指针。这两个指针都是int型指针，所以p是存放int型指针的数组。sizeof(p)返回数组占用的总空间，所以程序输出是8 常用举例字符排序，可以用指针数组指向不字符串，排序时改变指针指向就避免了大量文本数据的移动。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F05%2F25%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序（Quicksort）是对冒泡排序的一种改进。快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 原理官方解释：设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。一趟快速排序的算法是：1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。尼玛，这都是啥，想必没有见过这个算法的小可爱，对这个官方解释可能是一脸懵逼。所以我就把这个算法通俗的讲一讲。首先要对一堆数字排序我们必须找到一个基准数。而这个基准数可以是这一堆数字中的任意一个，我们定义两个移动的变量从数组的两头向中间检索。从右往左走的变量找到一个小于基准数后停止，从左往右的的变量找到一个大余基准数后停止然后这两个数就交换一下，直到两个变量相遇后就遍历了整个数组，这时候数字的左边都小于基准数，右边大于基准数。然后把数组分成两部分在执行遍历交换后，就完成排序了。 具体实例： 1234567891011121314151617181920212223242526272829303132333435363738394041void quicksort(int* a, int left, int right) &#123; int i, j, t, temp; if (left&gt;right) return; temp = a[left]; //temp中存的就是基准数 i = left; j = right; while (i != j) &#123; //顺序很重要，要先从右边开始找 while (a[j] &gt;= temp &amp;&amp; i&lt;j) j--; //再找右边的 while (a[i] &lt;= temp &amp;&amp; i&lt;j) i++; //交换两个数在数组中的位置 if (i&lt;j) &#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; //最终将基准数归位 a[left] = a[i]; a[i] = temp; quicksort(a, left, i - 1);//继续处理左边的，这里是一个递归的过程 quicksort(a, i + 1, right);//继续处理右边的 ，这里是一个递归的过程 &#125; int main()&#123; int arr[10] = &#123; 8, 2, 3, 1, 6, 5, 4, 7, 0, 9 &#125;; quicksort(arr, 0, 9); for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; arr[i]&lt;&lt;endl; &#125; return 0; &#125; 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针常量和常量指针的区别]]></title>
    <url>%2F2018%2F05%2F24%2F%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在面试中我们经常会被面试官问到什么是常量指针，什么又是指针常量。可能第一次被问到都会有些懵逼（大神略过）。我今天就来讲一讲这二者的区别。下面开始正题。。。。 指针常量指针常量：顾名思义它就是一个常量，但是是指针修饰的。格式为： 1int * const p //指针常量 在这个例子下定义以下代码： 12345int a，b；int * const p=&amp;a //指针常量//那么分为一下两种操作*p=9;//操作成功p=&amp;b;//操作错误 因为声明了指针常量，说明指针变量不允许修改。如同次指针指向一个地址该地址不能被修改，但是该地址里的内容可以被修改 常量指针常量指针：如果在定义指针变量的时候，数据类型前用const修饰，被定义的指针变量就是指向常量的指针变量，指向常量的指针变量称为常量指针，格式如下 1const int *p = &amp;a; //常量指针 在这个例子下定义以下代码： 12345int a，b； const int *p=&amp;a //常量指针//那么分为一下两种操作*p=9;//操作错误p=&amp;b;//操作成功 因为常量指针本质是指针，并且这个指针是一个指向常量的指针，指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变。 附加题指向常量的指针常量该怎么写？答案： 1const int * const b = &amp;a;//指向常量的指针常量]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数源码]]></title>
    <url>%2F2018%2F05%2F23%2F%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2-md%2F</url>
    <content type="text"><![CDATA[strcpy源码：12345678910 char *strcpy(char *strDes, const char *strSrc) &#123; assert((strDes != NULL) &amp;&amp; (strSrc != NULL)); char *address = strDes; while ((*strDes ++ = *strSrc ++) != '\0') NULL; return address; 注意：strcpy只是复制字符串，但不限制复制的数量。很容易造成缓冲溢出，也就是说，不过dest有没有足够的空间来容纳src的字符串，它都会把src指向的字符串全部复制到从dest开始的内存&lt;!-- more --&gt; strcmp源码：123456789101112int strcmp(const char *s, const char *t) &#123; assert(s != NULL &amp;&amp; t != NULL); while (*s &amp;&amp; *t &amp;&amp; *s == *t) &#123; ++ s; ++ t; &#125; return (*s - *t); &#125; strcat源码：12345678910111213char *strcat(char *strDes, const char *strSrc) &#123; assert((strDes != NULL) &amp;&amp; (strSrc != NULL)); char *address = strDes; while (*strDes != '\0') ++ strDes; while ((*strDes ++ = *strSrc ++) != '\0') NULL; return address; &#125; 注意：1.不能向形参传递指向字符串常量的指针（本题中dst和src都是指向串常量的指针，字符串常量存储在常量区不能被修改 2.传递的字符数组前一个实参的所分配的内存空间必须足够大 strlen源码：12345678910int strlen(const char *str) &#123; assert(str != NULL); int len = 0; while (*str ++ != '\0') ++ len; return len; &#125; strstr源码：1234567891011121314151617char *strstr(const char *strSrc, const char *str) &#123; assert(strSrc != NULL &amp;&amp; str != NULL); const char *s = strSrc; const char *t = str; for (; *t != '\0'; ++ strSrc) &#123; for (s = strSrc, t = str; *t != '\0' &amp;&amp; *s == *t; ++s, ++t) NULL; if (*t == '\0') return (char *) strSrc; &#125; return NULL; &#125; strchr源码：1234567891011121314char * __cdecl strchr ( constchar * string, int ch )&#123; while (*string &amp;&amp; *string != (char)ch) string++; if (*string == (char)ch) return((char *)string); return(NULL);&#125; 断言：assert（表达式）如果表达式的值为假，整个程序将退出，并输出一条错误信息。如果表达式的值为真则继续执行后面的语句，使用这个宏前需要包含头文件assert.h结语：函数就向一个黑盒一样，调用它的人给他输入（调用它本身就是一种输入），然后等待一个理想中的输出或者是相应的操作。调用者是希望我们的这个函数能够非常健壮的让他们利用，那么为了使我们的函数拥有一定的鲁棒性。]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
        <tag>程序源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2018%2F05%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[测试博客这是一篇测试博客 第一次使用github+hexo搭建属于自己的博客.日经过不懈的努力终于搭建好了，我非常开心！！ 2018.5.23 邓铭]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
