<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>指针和引用的区别</title>
      <link href="/2018/08/14/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/08/14/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>TCP的拥塞控制和流量控制</title>
      <link href="/2018/08/10/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
      <url>/2018/08/10/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="TCP的的流量控制"><a href="#TCP的的流量控制" class="headerlink" title="TCP的的流量控制"></a>TCP的的流量控制</h3><p>1.利用滑动窗口实现流量控制<br>&emsp;&emsp;一般来说我们希望发送方的发送速率越高，这样数据的传输率可能就变得高一点，但是如果发送方数据传输的过快，接受方可能来不及接收，这就会造成数据的丢失。，所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接受。<br>利用TCP的滑动窗口可以很方便的对流量进行控制</p><p>&emsp;&emsp;现在假设A向B发送消息，在连接建立时B告诉A我的接收窗口是400，因此发送方的发送窗口不能超过接收方的接受窗口的数值，注意TCP的滑动窗口是字节为单位并不是报文段，现在假设每个报文段大小为100字节。<br>并且数据段报文序号初始值为1。<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" alt="404"><br>&emsp;&emsp;我们因该注意到上图接受主机进行了3次流量控制，第一次把窗口减小到rwnd=300,第二次又减小到rwnd=100,第三次减小到0，即不予许再发送了。这种发送暂停的等待状态会持续到主机A收到B新的确认报文，三个确认报文都设置了ACK=1，切记当ACK=1时确认才有意义。<br>现在我们考虑另一种情况，现假设B给A发送0窗口报文后，现在又有了新的缓存空间。所以给A发送窗口值=400的报文段，可此报文段由于网络问题丢失了，此时B在等待A发数据，A在等待B发窗口值改变的报文。如果没有其他措施这种死锁局面就会一直延续下去。<br>为了解决这种问题TCP为每个连接都设置了一个持续计时器，只要对方设置了0窗口，就启动持续计时器开始计时，若果超时就会发送一个零窗口探测报文（只携带一个字节），对方收到探测报文就会给出现在的窗口值，若窗口依然是0，就继续等待，若不是则打破僵局。</p><h3 id="考虑传输效率"><a href="#考虑传输效率" class="headerlink" title="考虑传输效率"></a>考虑传输效率</h3><p>&emsp;&emsp;前面已经讲过,应用进程把数据传送到TCP的发送缓存后,剩下的发送任务就由TCP来控制了。可以用不同的机制来控制TCP报文段的发送时机。例如,第一种机制是TCP维持一个变量,它等于最大报文段长度MSS。只要缓存中存放的数据达到MsS字节时,就组装成一个TCP报文段发送出去。第二种机制是由发送方的应用进程指明要求发送报文段即TCP支持的推送(push)操作。第三种机制是发送方的一个计时器期限到了,这时就把当前已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。<br>&emsp;&emsp;但是,如何控制TCP发送报文段的时机仍然是一个较为复杂的问题。例如,一个交互式用户使用一条 TELNET连接(运输层为TCP协议)。假设用户只发1个字符。加上20字节的首部后,得到21字节长的TCP报文段。再加上20字节的IP首部,形成41字节长的IP数据报。在接收方TCP立即发出确认,构成的数据报是40字节长(假定没有数据发送)。若用户要求远地主机回送这一字符,则又要发回41字节长的IP数据报和40字节长的确认IP数据报。这样,用户仅发1个字符时线路上就需传送总长度为162字节共4个报文段。当线路带宽并不富裕时,这种传送方法的效率的确不高。因此应适当推迟发回确认报文,并尽量使用捎带确认的方法在TCP的实现中广泛使用 Nagle算法。算法如下:若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存,则发送方就把第一个数据字节先发送出去,把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后,再把发送缓存中的所有数据组装成一个报文段发送出去,同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时,用这样的方法可明显地减少所用的网络带宽。 Nagle算法还规定,当到达的数据已达到发送窗口大小的半或已达到报文段的最大长度时,就立即发送一个报文段。这样做,就可以有效地提高网络的吞吐量。<br>&emsp;&emsp;另一个问题叫做糊涂窗口综合症( silly window syndrome)RFC813],有时也会使TCP的性能变坏。设想一种情况:TCP接收方的缓存已满,而交互式的应用进程一次只从接收缓存中读取1个字节(这样就使接收缓存空间仅腾出1个字节),然后向发送方发送确认,并把窗口设置为1个字节(但发送的数据报是40字节长)。接着,发送方又发来1个字节的数据(请注意,发送方发送的IP数据报是41字节长)。接收方发回确认,仍然将窗口设置为1个字节。这样进行下去,使网络的效率很低。<br>&emsp;&emsp;要解决这个问题,可以让接收方等待一段时间,使得或者接收缓存已有足够空间容纳一个最长的报文段,或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一,接收方就发出确认报文,并向发送方通知当前的窗口大小。此外,发送方也不要发送太小的报文段,而是把数据积累成足够大的报文段,或达到接收方缓存的空间的一半大小。<br>上述两种方法可配合使用。使得在发送方不发送很小的报文段的同时,接收方也不要在缓存刚刚有了一点小的空间就急忙把这个很小的窗口大小信息通知给发送方。</p><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><p>&emsp;&emsp;计算机里的链路容量，交换节点的缓存，处理机等这些都是有限的网络资源，若某段时间对资源的需求大于本身资源的负载，就会使网络性能变坏，这时就出现了拥塞。我们可以发现以下条件<br><code>拥塞=对资源的需求&gt;可用资源</code><br>&emsp;&emsp;若网络中有许多资源同时呈现供应不足,网络的性能就要明显变坏,整个网络的吞吐量将随输入负荷的增大而下降。有人可能会说:“只要任意增加一些资源,例如,把结点缓存的存储空间扩大,或把链路更换为更高速率的链路,或把结点处理机的运算速度提高,就可以解决网络拥塞的问题。”其实不然。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法,在许多情况下,不但不能解决拥塞问题,而且还可能使网络的性能更坏。<br>&emsp;&emsp;网络拥塞往往是由许多因素引起的。例如,当某个结点缓存的容量太小时,到达该结点的分组因无存储空间暂存而不得不被丢弃。现在设想将该结点缓存的容量扩展到非常大。于是凡到达该结点的分组均可在结点的缓存队列中排队,不受任何限制。由于输出链路的容量和处理机的速度并未提高,因此在这队列中的绝大多数分组的排队等待时间将会大大增加,结果上层软件只好把它们进行重传(因为早就超时了)。由此可见,简单地扩大缓存的存储空间同样会造成网络资源的严重浪费,因而解决不了网络拥塞的问题。<br>&emsp;&emsp;又如,处理机处理的速率太慢可能引起网络的拥塞。简单地将处理机的速率提高,可能会使上述情况缓解一些,但往往又会将瓶颈转移到其他地方。问题的实质往往是整个系统的各个部分不匹配。只有所有的部分都平衡了,问题才会得到解决。拥塞常常趋于恶化。如果一个路由器没有足够的缓存空间,它就会丢弃一些新到的分组。但当分组被丢弃时,发送这一分组的源点就会重传这一分组,甚至可能还要重传多次这样会引起更多的分组流入网络和被网络中的路由器丢弃。可见拥塞引起的重传并不会缓解网络的拥塞,反而会加剧网络的拥塞。<br>&emsp;&emsp;拥塞控制与流量控制的关系密切,它们之间也存在着一些差别。所谓拥塞控制就是防止过多的数据注入到网络中,这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提,就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程,涉及到所有的主机、所有的路由器,以及与降低网络传输性能有关的所有因素。但TCP连接的端点只要迟迟不能收到对方的确认信息,就猜想在当前网络中的某处很可能发生了拥塞,但这时却无法知道拥塞到底发生在网络的何处,也无法知道发生拥塞的具体原因(是访问某个服务器的通信量过大?还是在某个地区出现了自然灾害)。<br>&emsp;&emsp;相反,流量控制往往指点对点通信量的控制,是个端到端的问题(接收端控制发送端)。流量控制所要做的就是抑制发送端发送数据的速率,以便使接收端来得及接收。可以用个简单例子说明这种区别。设某个光纤网络的链路传输速率为1000Gb/s。有一个巨型计算机向一个PC机以1Gb/s的速率传送文件。显然,网络本身的带宽是足够大的,因而不存在产生拥塞的问题。但流量控制却是必需的,因为巨型计算机必须经常停下来,以便使PC机来得及接收。<br>&emsp;&emsp;但如果有另一个网络,其链路传输速率为1Mb/s,而有1000台大型计算机连接在这个网络上。假定其中的500台计算机分别向其余的500台计算机以100kb/s的速率发送文件。那么现在的问题已不是接收端的大型计算机是否来得及接收,而是整个网络的输入负载是否超过网络所能承受的。拥塞控制和流量控制之所以常常被弄混,是因为某些拥塞控制算法是向发送端发送控制报文,并告诉发送端,网络已出现麻烦,必须放慢发送速率。这点又和流量控制是很相似的。<br>&emsp;&emsp;进行拥塞控制需要付出代价。这首先需要获得网络内部流量分布的信息。在实施拥塞控制时,还需要在结点之间交换信息和各种命令,以便选择控制的策略和实施控制。这样就产生了额外开销。拥塞控制有时需要将一些资源(如缓存、带宽等)分配给个别用户(或些类别的用户)单独使用,这样就使得网络资源不能更好地实现共享。十分明显,在设计拥塞控制策略时,必须全面衡量得失。<br>&emsp;&emsp;在图中的横坐标是提供的负载( offered load),代表单位时间内输入给网络的分组数目。因此提供的负载也称为输入负载或网络负载。纵坐标是吞吐量( throughput),代表单位时间从网络输出的分组数目。具有理想拥塞控制的网络,在吞吐量饱和之前,网络吞吐量应等于提供的负载,故吞吐量曲线是45°的斜线。但当提供的负载超过某一限度时,由于网络资源受限,吞吐量不再增长而保持为水平线,即吞吐量达到饱和。这就表明提供的负载中有一部分损失掉了(例如,输入到网络的某些分组被某个结点丢弃了)。虽然如此,在这种理想的拥塞控制作用下,网络的吞吐量仍然维持在其所能达到的最大值<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" alt="404"><br>但在实际的情况下无拥塞控制计划，随着网络吞吐量增长速率减小，网络会轻度拥塞，继续负载则会死锁。</p><h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><p>&emsp;&emsp;慢开始并不是指窗口值增长速率慢，而是指TCP最开始将窗口值设置为1，然后逐渐增长，这样的方式使得并不是一开始就将过量数据注入网络，先试探一下你，网络是否拥堵，然后在进行逐步增大。<br>为了防止拥塞窗口cwnd增长过大引起网络拥塞,还需要设置一个慢开始门限 ssthresh状态变量(如何设置 ssthresh,后面还要讲)。慢开始门限 ssthresh的用法如下:<br>当cwnd&lt; ssthresh时,使用上述的慢开始算法。<br>当cwnd&gt; ssthresh时,停止使用慢开始算法而改用拥塞避免算法。<br>当cwnd= ssthresh时,既可使用慢开始算法,也可使用拥塞避免算法。<br>&emsp;&emsp;拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大,即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1,而不是加倍。这样,拥塞窗口cwnd按线性规律缓慢增长,比慢开始算法的拥塞窗口增长速率缓慢得多。无论在慢开始阶段还是在拥塞避免阶段,只要发送方判断网络出现拥塞(其根据就是没有按时收到确认),就要把慢开始门限 ssthresh设置为出现拥塞时的发送方窗口值的一半(但不能小于2)。然后把拥塞窗口cwnd重新设置为1,执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数,使得发生拥塞的路由器有足够时间把队列中积<br>压的分组处理完毕。<br>&emsp;&emsp;下图用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。<br><img src="http://pajznqooi.bkt.clouddn.com/%E6%85%A2%E5%BC%80%E5%A7%8B.jpg" alt="404"><br>&emsp;&emsp;在执行慢开始算法时,拥塞窗口cwnd的初始值为1。以后发送方每收到一个对新报文段的确认ACK,就把拥塞窗口值加1,然后开始下一轮的传输(请注意,图的横坐标是传输轮次)。因此拥塞窗口cwd随着传输轮次按指数规律增长。当拥塞窗口cwd增长到慢开始门限值 ssthresh时(即当cwnd=16时),就改为执行拥塞避免算法,拥塞窗口按线性规律增长。</p><h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p>&emsp;&emsp;上面讲的慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法。1990年又增加了两个新的拥塞控制算法。这就是快重传和快恢复<br>提出这两个算法是基于如下的考虑:<br>如果发送方设置的超时计时器时限已到但还没有收到确认,那么很可能是网络出现了拥塞,致使报文段在网络中的某处被丢弃。在这种情况下,TCP马上把拥塞窗口cwnd减小到1,并执行慢开始算法,同时把慢开始门限值 ssthresh减半,如前图所示。这是不使用快重传的情况。<br>那快重传是怎么样的呢，快重传中如某次发送方发送数据丢失，接收方由于后续确认只能确认收到的最低序号确认则会对没收到的序号-1，进行确认并希望收到缺失的序号，如果，发送方连续三次收到了B对某数据的缺失确认则立即发送此数据报文，而不用等待此数据的重传计时器。<br>因此使用传重传能使网络吞吐量提高20%。<br>&emsp;&emsp;与快重传配合使用的还有快恢复算法,其过程有以下两个要点:<br>(1)当发送方连续收到三个重复确认时,就执行“乘法减小”算法,把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意,接下去不执行慢开始算法。<br>(2)由于发送方现在认为网络很可能没有发生拥塞(如果网络发生了严重的拥塞,就不会一连有好几个报文段连续到达接收方,也就不会导致接收方连续发送重复确认),因此与慢开始不同之处是现在不执行慢开始算法(即拥塞窗口cwd现在不设置为1),而是把cwnd值设置为慢开始门限ssthresh减半后的数值,然后开始执行拥塞避免算法(“加法增大”),使拥塞窗口缓慢地线性增大,下图给出了快重传和快恢复的示意图,并标明了“ TCPReno版本”,这是目前使用得很广泛的版本。图中还画出了已经废弃不用的虚线部分( TCP Tahoe版本)。请注意它们的区别就是:新的 TCP Reno版本在快重传之后采用快恢复算法而不是采用慢开始算法<br>&emsp;&emsp;请注意,也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一些(增大3个报文段的长度),即等于 ssthresh+3×MSS。这样做的理由是:既然发送方收到三个重复的确认,就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方<br>的缓存中(接收方发送出三个重复的确认就证明了这个事实)。可见现在网络中并不是堆积了三个分组，而是减少了三个分组，此时可适当加大拥塞窗口。<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%BF%AB%E6%81%A2%E5%A4%8D.jpg" alt="404"><br>&emsp;&emsp;在采用快恢复算法时,慢开始算法只是在TCP连接建立时和网络岀现超时时才使用釆用这样的拥塞控制方法使得TCP的性能有明显的改进<br>在里开始我们就假定了接收方总是有足够大的缓存空间,因而发送窗口的大小由网络的拥塞程度来决定。但实际上接收方的缓存空间总是有限的。接收方根据自己的接收能力设定了接收窗口rwnd,并把这个窗口值写入TCP首部中的窗口字段,传送给发送方。因此,接收窗口又称为通知窗口( advertised window)。因此,从接收方对发送方的流量控制的角度考虑,发送方的发送窗口一定不能超过对方给出的接收窗口值rwnd。</p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP可靠传输的实现</title>
      <link href="/2018/08/09/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/08/09/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="TCP可靠传输的原理"><a href="#TCP可靠传输的原理" class="headerlink" title="TCP可靠传输的原理"></a>TCP可靠传输的原理</h3><p> 我们都知道，TCP发送的报文段是交付给IP层传送的。但IP层只提供尽最大努力传输，因此是不可靠的，因此TCP必须采用适当的措施才能使两个运输层之间通信变得可靠。<br> 理想的传输条件有以下两个特点：<br> 1.传输信道无差错<br> 2.不管发送方以什么样的发送速率，接收方都能来得及处理发送方发送的消息。<br>然而实际上并不存在这样理想的传输条件，因此我们必须采用一些必要的措施保证实现可靠传输。</p><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p>这里我们讨论单方向的发送和接受，设A为发送方B为接收方。A每发完一个分组就等待B收到分组的确认，然后才发送下一个分组。<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93.jpg" alt="404"><br>上图a介绍了无差错的情况，b图展示若出现差错的应对机制，若B发给A的确认报文在途中丢失，B对于自己的报文丢没有并不清楚，它只等待A传入下个数据包，而A也在等B的确认报文，发现这种情况怎么办呢。超时重传了解一下，超时重传就是为了解决这个问题，当A在一定时间内没有收到B的确认，就认为自己发送的数据报文B没有收到，并且重发这段数据，如果这计时器规定时间内收到了A的确认就撤销计时器。<br>应当注意以下三点：<br>1.A没有收到B的确认报文时，必须暂时的保留已发送的分组副本，以便于超时重传。<br>2.分组和确认必须编码，这样才能知道哪些分组收到了确认，哪些没有收到。<br>3.超时计时器应当设计的比数据在分组传输的平均往返时间要长一些，如果重传时间过长会严重影响效率，但如果过短也会有不必要的重传，浪费资源。</p><h3 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h3><p>若A没有收到B的确认报文，A并不知道是自己的分组丢失还是B的确认丢失，所以重传计时器超时就会重传分组。此时B又收到了分组<br>此时B有两个行动：<br>1.丢弃重复的M1，不向上层交付。<br>2.对A发送确认。<br>可是试想有这样一种可能如图b，B的确认并没有丢失而是由于网络延迟滞留在网络中。<br>此时A会受到重复的确认，处理也很简单。A对重复的=确认并不处理，B依旧会收到重复的分组，然后丢弃重复的M1，并给A发送确认。<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%931.jpg" alt="404"><br>使用以上的确认重传机制就能在不可靠的网络上实现可靠的通信。</p><h3 id="TCP的滑动窗口"><a href="#TCP的滑动窗口" class="headerlink" title="TCP的滑动窗口"></a>TCP的滑动窗口</h3><p>实际上为了提高信道利用率，分组传输并没有每次只发送一个分组，然后等待确认。（这样实在效率太低）。为了提高传输效率，我们必须采用流水线传输，流水线传输使得发送方可以连续发送多个分组，不必每发完一个分组，就停下来等待，显然这样就能获得较高的信道利用率。</p><p>使用流水线传输就要介绍TCP的滑动窗口，现在假定A发送数据B接收数据来讨论TCP的滑动窗口。<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%932.jpg" alt="404"><br>TCP的滑动窗口是以字节为单位的，现假设A收到了来自B的确认报文，其中窗口大小为20字节，确认号为31，而序号30以前的数据都被完好的接受了。<br>我们先说A的发送窗口，发送窗口表示在没有收到B的确认之前窗口里的数据都能持续的发送出去，但这些数据在没有收到B的确认时都必须保留下来，以便于超时重传。显然窗口越大发送方就能在收到确认之前持续发送更多的数据，可以获得更高的传输效率，前提是对方来得及处理这些数据。<br>滑动窗口后沿部分表示已发送并且已经确认的报文，这些可以不用在保留，而前沿部分表示不允许发送的，发送窗口由前沿和后沿共同决定，发送窗口的后沿就两种变化情况不动（没有收到确认），向前移动（收到确认）。发送窗口的前沿一般都是向前移动的，当然也可能不动（没收到确认，窗口值也不变，或者收到确认，窗口值变小）发送窗口前沿也可能向后收缩，这发生在对方通知窗口变小，TCP强烈不推荐这样做。因为可能已经发送了这些数据，但现在又不让发送，可能会产生错误。<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%933.jpg" alt="404"><br>现在假设A发送了31-41的数据，这时窗口未改变。灰色的小方框表示已经发送但没有收到确认的，而发送窗口后九个字节42-50表示没有发送但允许发送的。从上图看出要描述一个发送窗口需要三个指针：p1,p2,p3.<br>小于p1表示已经发送成功的，大于p3表示不可发送的<br>1.p3-p1表示发送窗口<br>2.p2-p1表示已发送尚未确认<br>3.p3-p2表示尚未发送的<br>再看B的接收窗口，接收窗口大小为20字节，B收到了32、33号的数据，没有收到31号所以B只能给出收到的数据最高序号加1，也就是31，期望下次收到31号数据。<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%934.jpg" alt="404"><br>现假定B收到了31号数据并对A确认，窗口依然是20，此时A可以向前移动3个字节，此时A的可发送窗口变大，发送范围为42-53.</p><p>A在继续发送完数据，p2指针p3指针重合此时发送窗口已满，但B的确认并没有到达（丢失或者滞留），等到重传计时器超时，就必须重传这部分数据。直到收到B的确认，然后继续滑动窗口。</p><p>TCP的缓存与窗口的关系：<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%935.jpg" alt="404"></p><p>小思考，若收到的报文段无差错只是没有按序号到达，中间还缺少数据，能否只重传缺少的数据而不用重传已经收到的数据？<br>答案是可以的，选择确定（SACK）是一种可行的办法。要使用选择确认，双方必须商定好，必须在TCP首部增加SOCK选项，以便报告收到不连续的字节块的边界以便于重传。</p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP报文段的首部格式</title>
      <link href="/2018/08/09/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/"/>
      <url>/2018/08/09/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段，一个TCP报文段分为首部和数据两部分，TCP的全部功能体现在首部各字段作用。<br>TCP报文段的前20个字节是固定的，后面有4n个字节根据需要而增加的选项（n为整数）。所以TCP首部最小长度为20字节。<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg" alt="404"></p><p>首部固定字段意义如下：<br>1.源端口和目的端口：各占两个字节，分别写入源端口号和目的端口号。</p><p>2.序号：占4字节，序号范围是[0，2^32-1]一共是4294967296个序号，当序号用完以后，下一个序号就又回到0.在TCP连接中所有字节按序号编号首部中的字段序号标记本报文段所发送的第一个字节的序号。例如本报文段序号为201，携带有100字节的数据，那么最后一个字节数据为300，并且下个报文段数据应当从301开始发送。</p><p>3.确认号：占4个字节 ，是期望收到对方下一个报文段的第一个字节序号，一般由接收方发给发送方的确认报文中将确认号改为期望收到的数据字节编号，总之若确认号为N，则表示N-1之前的数据都已经正确的接接收了。</p><p>4.数据偏移：占4位，表示数据到TCP数据包头部的长度，其实就是表明TCP头部的长度，因为TCP头部固定20字节加上不确定的部分，但4位2进制能最大表示十进制数15，但应注意数据偏移的单位是32位字所以数据偏移最大能表示60字节，因此TCP首部最大为60字节，即选项长度不能超过40字节。</p><p>5.保留：占6位，作为以后使用，目前应该置0</p><p>6.六个控制位：<br>1）紧急URG:当URG置为1时表示此报文段为紧急报文，应当尽快送达，拥有较高的优先级，不需要排队传送。发送方会把经济数据插入到本报文数据的最前面发送，需要注意的是需要和紧急指针配合使用。<br>2）确认ACK：当ACK=1时，确认号才有效，当连接建立时，所有报文段ACK都必须置为1.<br>3）推送PSH：当两个应用交互式通信，有一段应用可能需要对方应用及时的响应，这种情况下可以将PSH位置为1，表示收到消息不用等待缓存区满才向上交付，而是尽快直接交付。<br>4）复位RST： 当RST置为1，表示TCP连接出现严重错误，需要断开并重新建立连接。<br>5）同步SYN:在建立连接用来同步序号，当SYN=1，ACK等于0，标指这是一个请求连接的报文段，如果对方同意连接就将SYN=1,ACK=1。<br>6）终止FIN：用来释放一个连接，当FIN置为1表示已经没有数据发送，已经发送完毕。并要求释放连接。</p><p>7.窗口：占2字节窗口值是[0-2^16-1]之间的整数，窗口告诉发送方从本报文段首部的确认号算起还能接受的数据量，而此窗口值作为发送端设置发送端口的依据。</p><p>8.检验和：占2个字节，用来检验首部和数据这两部分是否出现差错。</p><p>9.紧急指针：占2个字节，紧急指针只有在标志位URG=1时候才有用，它指出紧急数据的字节数，因为紧急数据后面就是普通数据，紧急指针给出了紧急数据在报文段末尾的位置。</p><p>10.选项：长度可变，最大40字节，如果不使用选项，TCP首部大小就为20字节。TCP最开始就只规定了一种选项就是MSS最大报文段长度，但MSS的意思是每个报文中数据字段的最大长度（即报文长度减去TCP首部长度），MSS默认长度位536字节，因此在所有计算机上都能支持的报文段长度为536+20=556字节.随着英特网的发展后来又增加了几个选项：窗口扩大、时间戳等。</p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP的三次握手四次挥手</title>
      <link href="/2018/08/09/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2018/08/09/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      <content type="html"><![CDATA[<h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>TCP的连接的建立采用客户服务器方式。主动发起连接建立的应用进程称为客户端，被动的等待连接建立的应用进程叫做服务器。<br>先假定主机A运行的是客户端程序，而B运行的是服务器程序。最初两端的TCP进程都处于CLISED状态。建立三次握手过程如下图：<br><a id="more"></a><br>A主动打开连接，B被动打开连接<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="404"></p><h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><p>1.首先两端都处于CLOSED状态，B的TCP服务器首先创建传输控制块TCB准备接受客户端的连接请求，然后服务器进程就处于LISTEN状态，等待客户的连接请求，如果有就及时做出反应。<br>2.A的TCP进程也是首先创建传输控制模块TCB，然后向B发送连接请求，同时初始化序号seq=x，并将SYN标志位置为1，此阶段为SYN报文段规定并不能携带数据，但也会消耗一个序号，此时TCP客户进程进入SYN-SENT（同步已发送）状态。<br>3.B如果接受连接请求就将确认报文中的ACK，SYN置为1，同时初始化自己的序号seq=y，确认号为ack=x+1.同样的这个报文也不能携带数据，并且也要消耗一个序号，然后B进入SYN-RCVD状态（同步收到）。<br>4.A收到B的确认后还需要再次向B给出确认，确认ACK置1，确认号ack=y+1,而自己的序号为seq=x+1,TCP规定ACK报文可以携带信息，但是如果不携带则不用消耗一个序号，这种情况下下次发送的序号仍然为seq=x+1。这时连接已经建立，A进入ESTAB-LISHED(已建立连接)状态。<br>当B收到A的确认后也进入ESTAB-LISHED状态。</p><p>至此三次握手到此结束</p><p>小思考，为什么要A还要给B发一次确认呢？或者说两次握手不就建立好了吗？</p><p>答：这样是为了防止已经失效的的连接请求再次传送到B,从而产生错误。<br>我们现在试着想一下这样一种正常的情况，A向B发送连接请求，但因为某种原因请求丢失了，A超时重传再次发送连接请求，传输完毕释放连接，A一共发送了两个请求，第一个丢失第二个正常收到，没有失效的连接请求报文段。但我们试想另一种极端的情况，那就是A第一次发送的请求并没有丢失而是因为网络延迟而滞留了，此时滞留的请求被B收到，B会以为这是A的新的一次请求，然后B进行确认应答然后进入连接状态（假设没有三次握手，两次握手就连接），可是B的确认传达到A，由于A并没有申请连接B，所以A不会理睬B的确认应答，也并不会给B发数据。可B一直在等A给他发消息，于是B的服务器资源被白白浪费。</p><p>而采用了三次握手，发生上述情况，由于A不会向B发送确认应当，B也就知道A没有连接的请求。</p><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p>TCP的连接释放过程分为四个步骤，称为四次挥手，我们仍结合双方状态来探究释放的过程</p><p><img src="http://pajznqooi.bkt.clouddn.com/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B2.jpg" alt="404"><br>1.在数据传输完成后双方都可以释放连接，现在双方都处于ESTAB-LISHED状态,现在由A首先先向其TCP发出释放连接报文段，并停止发送数据，主动关闭TCP连接。其通过将FIN位置1，seq=u（等于最后传送成功数据序号+1），同时A进入FIN-WAIT-1状态，等待B的确认。注意FIN报文段不携带数据也会占用一个序号。<br>2.B收到连接释放报文段后发出确认，ACK=1，ack=u+1,自身序号seq=x,同时B进入CLOSE-WAIT(关闭等待状态)，这时TCP服务器通知上层进程，因此从A到B方向的连接就释放了，但由B到A还能发送信息。A收到B的确认应答进入FIN-WAIT-2状态等待B释放自己的报文段。这个状态可能持续一段时间。<br>3.若B没有数据要发送给A，B就会通知A断开连接，此时B的序号为最后发送的数据序号+1，seq=w，ack=u+1,并将FIN置为1，然后进入LAST-ACK(最后确认状态)，并等待A的确认。<br>4.A收到B的连接释放报文段后必须对此发出确认，将ACK置为1，seq=u+1，ack=w+1.此时还并没有释放完毕，A会进入TIME-WAIT（时间等待状态），必须经过时间等待计时器设置的时间2MSL后A才进入CLOSED状态，可能对于现在的网络2分钟可能有点长，因此TCP允许不同实现的具体情况使用更小的MSL值，当时间等待结束，A回收x相应的传输控制块TCB后就结束了此次TCP连接，而B收到A的确认会立即进入CLOSED状态。</p><p>至此四次挥手结束！</p><p>小思考，为什么客户机A需要等待2MSL？<br>答：在这里有两个理由：<br>1.为了保证A发送的确认能够到达B，因为这个报文可能会丢失，而丢失了A可以重传确认并重新启动TIME-WAIT，如果A发送了确认不进行等待而立即释放，会导致B无法收到A的ACK确认从而无法完成B的释放。<br>2。为了防止前面提到的已失效连接请求报文段。A在发送完成最后一个ACK报文段后，在经历2MSL后，可以使所有本连接连续产生的所有报文段从网络中消失，这样使得下一次的新连接中不会出现这种就的请求报文。</p><h3 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h3><p>上面介绍了TCP的正常断开步骤，可日常情况下可能有一些特殊的情况，比如意外的断电使得客户断不能告诉服务端自己断开链接了，此时应当有措施使得服务器不必白白等下去，因此设计了保活计时器，当服务端每次收到客户端数据都会重置保活计时器。，时间的设置通常是两个小时，如果两个小时都没有收到客户的数据，服务器就会发送一个探测报文，以后会间隔75分钟发一次，若连续10次仍然没有客户端的消息，服务器就认为客户端故障，接着关闭这个连接。</p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>虚函数和纯虚函数</title>
      <link href="/2018/07/31/%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2018/07/31/%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数，用法格式为：virtual 函数返回类型 函数名（参数表） {函数体}；实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。</p><p>简单地说，那些被virtual关键字修饰的成员函数，就是虚函数。虚函数的作用，用专业术语来解释就是实现多态性（Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异，而采用不同的策略。下面来看一段简单的代码。<br><a id="more"></a></p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is A"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is B"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//为了在以后便于区分，我这段main()代码叫做main1</span></span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    a.print();</span><br><span class="line">    b.print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://pajznqooi.bkt.clouddn.com/%E8%99%9A%E5%87%BD%E6%95%B0.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~ A()</span><br><span class="line"> &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  A *a = &amp;b;</span><br><span class="line">  a-&gt;print();</span><br><span class="line">  b.print();</span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://pajznqooi.bkt.clouddn.com/%E8%99%9A%E5%87%BD%E6%95%B02.jpg" alt=""><br> 这里通常将基类的析构函数也声明为虚函数。避免内存泄漏。</p><h3 id="纯虚函数-1"><a href="#纯虚函数-1" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//纯虚函数是一种特殊的虚函数，它的一般格式如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;类名&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">virtual</span> &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=<span class="number">0</span>;</span><br><span class="line">…</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。<br>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。<br>一般而言纯虚函数的函数体是缺省的，但是也可以给出纯虚函数的函数体（此时纯虚函数变为虚函数），这一点经常被人们忽视，调用纯虚函数的方法为baseclass::virtual function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Demon</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Base</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is farther class"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubVirtual</span> :</span><span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Demon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" this is SubVirtual!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"this is subclass Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">base* inst = <span class="keyword">new</span> SubVirtual();</span><br><span class="line">inst-&gt;Demon();</span><br><span class="line">inst-&gt;Base();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://pajznqooi.bkt.clouddn.com/%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B03.jpg" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> -C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类的的三大特性的总结</title>
      <link href="/2018/07/29/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/07/29/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是一指一个对象从另一个对象获得功能的过程，它提供了一种明确表述共性的方法。是一个不断向上抽取的过程。单继承中，一个类只能继承一个类，但一个类可以被多个类所继承。一共有3种不同权限的继承，分别是public、protect、private继承。<br>继承优点：<br>1.提高了代码的复用性。<br>2.让类与类之间产生了关系。有了这个关系，才有了多态的特性。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>什么是封装？<br>封装指隐藏对象的属性和实现细节，仅仅对外提供接口和方法。<br>举一个生动的例子：电视遥控器，就是对电视机操作方法的一种封装，遥控器上的各种按键就是给出的接口，我们用户通过这些接口来控制电视机，但是我们对遥控器实际控制并不清楚，它的原理，或者具体细节，都对我们用户隐藏，这就是一种封装。而在C++中将一个类具体封装起来，只暴露接口函数。能够提高代码重用性，便于使用，当然也更安全。但这样做同时也暴露了缺点，那就是代码不能轻易地去维护，而且封装了过多层会影响效率。<br><a id="more"></a></p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>什么是多态？<br>c++中一共有两种多态，一种是静态的多态，一种是动态的多态。动多态称为运行时多态，而静多态称为编译时多态。静多态大多由模板实现或者是宏，而动多态大多由虚函数来实现，动多态的函数调用机制是执行期才能进行确定，所以它是动态的。总之多态的意义在于让基类的指针指向派生类，从而实现派生类的不同功能。如果你还是不太明白多态的意义，我可以举一个简单的例子。龙生九子，子子不同，龙的九个儿子就是龙的不同表现，同一个模板下，实现不同的形态或者功能就称之为多态。</p><p>多态的实现：<br>函数重载：必须在同一个类中进行 子类无法重载父类的函数，父类同名函数将被名称覆盖，重载是在编译期间根据参数类型和个数决定函数调用<br>函数重写：必须发生于父类与子类之间 并且父类与子类中的函数必须有完全相同的原型 ，使用virtual关键字声明之后能够产生多态(如果不使用virtual，那叫重定义) 多态是在运行期间根据具体对象的类型决定函数调用（注意：基类的析构函数通常建议声明为虚函数，不然容易内存泄漏。</p><p>多态的优势和弊端：<br>优点：多态的出现大大的提高程序的扩展性，以及代码的复用性，减少了编程中编码量，提高了代码的可维护性。<br>缺点：在大工程里如果多态使用大量，编译时过程会极其缓慢。同时多态使得代码的可读性并不那么良好，同时调式起来也比较困难。</p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类的成员函数</title>
      <link href="/2018/07/18/%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>/2018/07/18/%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="六大成员函数"><a href="#六大成员函数" class="headerlink" title="六大成员函数"></a>六大成员函数</h2><p>一、构造函数<br>特点：与类名相同、没有返回值、可以重载、在有效的生命周期只会调用一次、缺省的构造函数不能用Virtual/const修饰，构造函数有自己的初始化列表。初始化列表完成类中非静态成员变量的初始化，尽量避免用成员初始化成员。<br>初始化中，用const类型成员必须初始化。</p><p>二、拷贝构造函数<br>特点：用对象创建对象 参数为类类型的引用，这里必须用引用传递，不然会无限循环递归。而用引用的另一个原因是效率很高。</p><p>三、析构函数<br>特点：形式为~类名，没有参数和返回值，不能重载，在实现多态时最好在基类将构造函数声明为虚函数。<br><a id="more"></a><br>四、赋值运算符重载<br>常见可重载的运算符：++、– 、<em> 、-&gt;、=<br>不可重载的运算符：</em> 、::、？：、sizeof</p><p>五、取地址运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test * <span class="keyword">operator</span>&amp;()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>六、const修饰的取地址操作符的重载<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test * <span class="keyword">operator</span>&amp;()  <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树的层序遍历</title>
      <link href="/2018/07/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2018/07/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<h3 id="层序遍历算法"><a href="#层序遍历算法" class="headerlink" title="层序遍历算法"></a>层序遍历算法</h3><p>二叉树的层序遍历：从根开始，依次向下，对于每一层从左向右遍历。<br>同二叉树的前中后序遍历不同的是，前中后序采用的是堆，而二叉树层序遍历采用的是队列。<br>因此前中后序遍历可以采用递归算法，而层序遍历却不行！<br><a id="more"></a></p><h3 id="层序遍历的模拟实现"><a href="#层序遍历的模拟实现" class="headerlink" title="层序遍历的模拟实现"></a>层序遍历的模拟实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTree</span>//二叉树结构</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> vec;</span><br><span class="line">  BinaryTree* left;</span><br><span class="line">  BinaryTree* right;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) <span class="comment">//返回为一个数组</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; ret;</span><br><span class="line">ret.push(root);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">while</span> (!ret.empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode*tmp= ret.front();</span><br><span class="line">result.push_back(tmp-&gt;val);</span><br><span class="line">ret.pop();</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret.push(tmp-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret.push(tmp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树的链式存储实现</title>
      <link href="/2018/07/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/07/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h2 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h2><p>数组表示法用于完全二叉树的存储表示非常有效，但表示一般二叉树则不是很理想。此外，在一棵树中进行插入和删除操作时，为了反应结点层次的变动，可能需要移动许多的结点，这样降低了算法的效率，而使用了链表表示可以克服这样的缺点。<br>根据二叉树的定义，可以设计出二叉树节点的构造。二叉树的每一个结点至少应该包括三个域：数据、左孩子、右孩子。这种链表结构一般被叫做二叉链表。使用这种链表可以很方便的表示和找到它的子女，但找到它的双亲却很困难。为了便于查找双亲，我们还可以增加一个双亲指针域，这种结构被称为三叉链表。<br>结构如下：<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A82.jpg" alt="这里写图片描述"></p><h3 id="二叉链表的类定义"><a href="#二叉链表的类定义" class="headerlink" title="二叉链表的类定义"></a>二叉链表的类定义</h3><p>三叉链表和二叉链表类似，本文只讨论二叉链表。下面给出二叉链表的类定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEAD_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEAD_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>  DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data;</span><br><span class="line">BinTreeNode *leftchild, *righutchild;</span><br><span class="line">&#125;Binarynode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinaryTree()</span><br><span class="line">:root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">BinaryTree(BinaryTree&amp; s);</span><br><span class="line">~BinaryTree();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatBinTree</span><span class="params">(Binarynode*&amp;subTree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ceratBinTree</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Binarynode *<span class="title">find</span><span class="params">()</span></span>;<span class="comment">//搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//中序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//后序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Binarynode* subTree)</span></span>;<span class="comment">//统计节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hight</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hight</span><span class="params">(Binarynode* subTree)</span></span>;<span class="comment">//求树高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BinaryTree* <span class="title">copy</span><span class="params">(Binarynode*&amp;Tree)</span></span>;<span class="comment">//复制二叉树</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Binarynode *root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="二叉链表的实现"><a href="#二叉链表的实现" class="headerlink" title="二叉链表的实现"></a>二叉链表的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>  DataType;</span><br><span class="line">DataType RefValue = <span class="string">'#'</span>;<span class="comment">//输入结束符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data;</span><br><span class="line">BinTreeNode *leftchild, *rightchild;</span><br><span class="line">&#125;Binarynode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinaryTree()</span><br><span class="line">:root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">BinaryTree(BinaryTree&amp; s);</span><br><span class="line">~BinaryTree();</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Binarynode *<span class="title">find</span><span class="params">(DataType &amp;item)</span></span>;<span class="comment">//搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatBinTree</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatBinTree</span><span class="params">(Binarynode*&amp;subTree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//中序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//后序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Binarynode* subTree)</span></span>;<span class="comment">//统计节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hight</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hight</span><span class="params">(Binarynode* subTree)</span></span>;<span class="comment">//求树高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Binarynode* <span class="title">copy</span><span class="params">(Binarynode*&amp;Tree)</span></span>;<span class="comment">//复制二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">(Binarynode*&amp;Tree)</span></span>;<span class="comment">//销毁</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Binarynode *root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> BinaryTree::IsEmpty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Binarynode* BinaryTree::find(DataType&amp; item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (item != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Binarynode *tmp = root;</span><br><span class="line">Binarynode*tmpl = tmp-&gt;leftchild;</span><br><span class="line">Binarynode*tmpr = tmp-&gt;rightchild;</span><br><span class="line">DataType temp = root-&gt;data;</span><br><span class="line"><span class="keyword">while</span> (tmpl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp != item)</span><br><span class="line">&#123;</span><br><span class="line">tmpl = tmpl-&gt;leftchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i find it"</span>;</span><br><span class="line"><span class="keyword">return</span> tmpl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (tmpr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp != item)</span><br><span class="line">&#123;</span><br><span class="line">tmpr = tmpr-&gt;rightchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i find it "</span>;</span><br><span class="line"><span class="keyword">return</span> tmpr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"can't find it"</span>;</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::PreOrder()</span><br><span class="line">&#123;</span><br><span class="line">PreOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::PreOrder(Binarynode*subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; subTree-&gt;data;</span><br><span class="line">PreOrder(subTree-&gt;leftchild);</span><br><span class="line">PreOrder(subTree-&gt;rightchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::InOrder()</span><br><span class="line">&#123;</span><br><span class="line">InOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::InOrder(Binarynode* subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">InOrder(subTree-&gt;leftchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; subTree-&gt;data;</span><br><span class="line">InOrder(subTree-&gt;rightchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">void</span> BinaryTree::PostOrder()</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::PostOrder(Binarynode*subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(subTree-&gt;leftchild);</span><br><span class="line">PostOrder(subTree-&gt;rightchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; subTree-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::Hight()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Hight(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::Hight(Binarynode* subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> dep1 = Hight(subTree-&gt;leftchild);</span><br><span class="line"><span class="keyword">int</span> dep2 = Hight(subTree-&gt;rightchild);</span><br><span class="line"><span class="keyword">if</span> (dep1&gt;dep2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dep1 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dep2 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::count()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> count(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::count(Binarynode*subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + count(subTree-&gt;leftchild) + count(subTree-&gt;rightchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BinaryTree::copy()</span><br><span class="line">&#123;</span><br><span class="line">copy(root);</span><br><span class="line">&#125;</span><br><span class="line">Binarynode* BinaryTree::copy(Binarynode*&amp;Tree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Binarynode *tmp = <span class="keyword">new</span> Binarynode;</span><br><span class="line">tmp-&gt;data = Tree-&gt;data;</span><br><span class="line">tmp-&gt;leftchild = copy(Tree-&gt;leftchild);</span><br><span class="line">tmp-&gt;rightchild = copy(Tree-&gt;rightchild);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::creatBinTree(Binarynode*&amp;subTree)</span><br><span class="line">&#123;</span><br><span class="line">DataType item;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; item;</span><br><span class="line"><span class="keyword">if</span> (item != RefValue)</span><br><span class="line">&#123;</span><br><span class="line">subTree = <span class="keyword">new</span> Binarynode;</span><br><span class="line">subTree-&gt;data = item;</span><br><span class="line"><span class="keyword">if</span> (subTree == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"存储分配错误"</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">creatBinTree(subTree-&gt;leftchild);</span><br><span class="line">creatBinTree(subTree-&gt;rightchild);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">subTree = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::creatBinTree()</span><br><span class="line">&#123;</span><br><span class="line">creatBinTree(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BinaryTree::destory(Binarynode*&amp;Tree)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Tree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">destory(Tree-&gt;leftchild);</span><br><span class="line">destory(Tree-&gt;rightchild);</span><br><span class="line"><span class="keyword">delete</span> Tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryTree::~BinaryTree()</span><br><span class="line">&#123;</span><br><span class="line">destory(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BinaryTree::BinaryTree(BinaryTree &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">root = copy(s.root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BinaryTree subTree;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入节点，空结点以#代替:"</span>;</span><br><span class="line">subTree.creatBinTree();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"前序遍历："</span>;</span><br><span class="line">subTree.PreOrder();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="string">"中序遍历："</span>;</span><br><span class="line">subTree.InOrder();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"后序遍历："</span>;</span><br><span class="line">subTree.PostOrder();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"结点个数："</span>&lt;&lt;subTree.count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"树的高度："</span>&lt;&lt;subTree.Hight()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.jpg" alt=""></p><h3 id="关于链表的输入"><a href="#关于链表的输入" class="headerlink" title="关于链表的输入"></a>关于链表的输入</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A83.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pairs-对组介绍</title>
      <link href="/2018/07/12/Pairs-%E5%AF%B9%E7%BB%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/07/12/Pairs-%E5%AF%B9%E7%BB%84%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="队组"><a href="#队组" class="headerlink" title="队组"></a>队组</h2><p>class Pair 可以将两个值视作一个单元。C++标准库库内多处使用了这个Class，尤其是容器map和multimap，就是使用了Pairs来管理键值对，任何函数返回两个值也需要pair.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>  <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">Pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    pair()</span><br><span class="line">    :first(T1(),second(T2))</span><br><span class="line">    &#123;&#125;</span><br><span class="line">      pair(<span class="keyword">const</span> pair&lt;U,V&gt;&amp;p)</span><br><span class="line">      :first (p.first),second(p.second)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>注意，pair被定义为struct，而不是class，这样所有成员都是public,因此可以直接存储pair的个别值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>:pair&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt;p;</span><br></pre></td></tr></table></figure></p><p>上述defalut构造函数生成一个pair时，以int（）和float（）来初始化p,这两个构造函数为0值；<br>如果pair对象被复制，调用的是由系统隐式生成的的哪个copy构造函数，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>:：pair&lt;<span class="keyword">int</span>,<span class="keyword">const</span> <span class="keyword">char</span>*&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;)</span></span>;</span><br><span class="line"><span class="keyword">void</span> foo&#123;</span><br><span class="line">  <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">const</span> <span class="keyword">char</span>*&gt;p(<span class="number">42</span>,<span class="string">"hello"</span>);</span><br><span class="line">  f(p);</span><br><span class="line">  g(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="pair之间的比较"><a href="#pair之间的比较" class="headerlink" title="pair之间的比较"></a>pair之间的比较</h2><p>为了比较两个pair对象，C++标准程序库提供了大家惯用的操作符。如果两个pair对象内的所有元素相等，这两个pair对象就被视为相等。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> ,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">pair</span>&lt;T,T2&gt;&amp;<span class="title">X</span>,<span class="title">const</span> <span class="title">pair</span> &lt;T,T2&gt;&amp;<span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.first==y.first&amp;&amp;x.second==y.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当两个pairs相互比较时，第一元素具有较高的优先级，所以如果两个pairs的第一元素不相等，其比较结果就称为整个比较行为的结果。如果第一元素相等，才继续比较第二元素，并把比较结果当作整体比较结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>&lt;const pair&lt;T1,T2&gt;&amp;X,const pair&lt;T1,T2&gt;&amp;y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">  return x.first&lt;y.first||(!(y.first/,x.first)&amp;&amp;x.second&lt;y.second);</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p><p>其他的比较操作符，也差不多相似。</p>]]></content>
      
      
        <tags>
            
            <tag> C++标准程序库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树</title>
      <link href="/2018/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。<br>二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。<br>一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为log2(n+1)。深度为k的完全二叉树，至少有2^(k-1)个节点，至多有2^k-1个节点。<br><a id="more"></a></p><h3 id="二叉树相关知识"><a href="#二叉树相关知识" class="headerlink" title="二叉树相关知识"></a>二叉树相关知识</h3><p>满二叉树：在一棵二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层，则这样的二叉树称作满二叉树。<br>完全二叉树：如果一颗具有n个节点的二叉树的结构与满二叉树的前n个节点的结构相同，这样的二叉树称为完全二叉树。</p><h3 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h3><p>1:若规定根节点的层数为0，则一棵非空二叉树的第i层上最多有2^i(i&gt;=0)个节点。<br>2: 若规定只有根节点的二叉树的深度为0，则深度为k的二叉树的最大节点数是2^(k+1)-1(k&gt;=-1)。<br>3:对于一棵非空的二叉树，如果叶节点个数为n0，度为2的节点个数为n2，则有n0=n2+1。<br>4:具有n个节点的完全二叉树的深度k为大于或等于ln(n+1)-1的最小整数。<br>5:对于具有n个节点的完全二叉树，如果按照从上至下和从左至右的顺序对所有节点序号从0开始顺序编号，则对于序号为i(0&lt;=i&lt;n)的节点有：<br> 1)如果i〉0，则序号为i节点的双亲节点的序号为(i-1)/2(/为整除)；如果i=0，则序号为i节点为根节点，无双亲节点。<br> 2)如果2i+1&lt;n,则序号为i节点的左孩子节点的序号为2i+1；如果2i+1&gt;=n,则序号为i节点无左孩子。<br> 3)如果2i+2&lt;n,则序号为i节点的右孩子节点的序号为2i+2;如果2i+2&gt;=n，则序号为i节点无右孩子。</p><h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h3><p>1.二叉树的顺序存储结构<br> 利用性质5，对于完全二叉树可以利用一维数组存储，如果不是完全二叉树，则可以补空节点，使成为完全二叉树在进行存储，<br> 但是对于非完全二叉树，可能要浪费很多的空间。所以并不是很理想。<br>2.二叉树的链式存储结构<br>  二叉树的链式存储结构就是用指针建立二叉树中节点之间的关系，二叉树最常用的链式存储结构是二叉链表。二叉树的二叉链表存储结构是一种常用的二叉树存储结构。二叉链表存储结构的优点是结构简单，可以方便的构造任何形状的二叉树，并可以方便的实现二叉树的大多数操作。<br>  二叉链表存储结构的缺点是，查找当前节点的双亲节点操作实现比较麻烦。</p>]]></content>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单UDP网络程序</title>
      <link href="/2018/07/07/%E7%AE%80%E5%8D%95UDP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F/"/>
      <url>/2018/07/07/%E7%AE%80%E5%8D%95UDP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="实现简单UDP客户端和服务器端"><a href="#实现简单UDP客户端和服务器端" class="headerlink" title="实现简单UDP客户端和服务器端"></a>实现简单UDP客户端和服务器端</h3><p>实现简单的基于UDP协议的客户端和服务器端聊天小程序。</p><a id="more"></a><h4 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                                                                                                                                     </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;                                                                                                                                </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;                                                                                                                                </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;                                                                                                                                 </span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">sockaddr</span>;</span>                                                                                                                      </span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockaddr_in</span>;</span>                                                                                                                </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;                                                                                                                      </span><br><span class="line">   <span class="keyword">int</span> sock = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);                                                                                                              </span><br><span class="line">   <span class="keyword">if</span> (sock&lt;<span class="number">0</span>)                                                                                                                                           </span><br><span class="line">   &#123;                                                                                                                                                     </span><br><span class="line">   perror(<span class="string">"socket"</span>);                                                                                                                                     </span><br><span class="line">   <span class="keyword">return</span> <span class="number">2</span>;                                                                                                                                             </span><br><span class="line">   &#125;                                                                                                                                                     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local</span>;</span>                                                                                                                            </span><br><span class="line">    local.sin_family=AF_INET;                                                                                                                            </span><br><span class="line">    local.sin_port=htons(atoi(argv[<span class="number">1</span>]));                                                                                                                 </span><br><span class="line">    local.sin_addr.s_addr=htonl(INADDR_ANY);                                                                                                             </span><br><span class="line">  <span class="keyword">if</span> (bind(sock,(struct sockaddr*)&amp;local,<span class="keyword">sizeof</span>(local))&lt;<span class="number">0</span>)                                                                                               </span><br><span class="line">  &#123;                                                                                                                                                      </span><br><span class="line">  perror(<span class="string">"bind"</span>);                                                                                                                                        </span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;                                                                                                                                              </span><br><span class="line">  &#125;                                                                                                                                                      </span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>];                                                                                                                                        </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span>                                                                                                                             </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)                                                                                                                                               </span><br><span class="line">  &#123;                                                                                                                                                      </span><br><span class="line">    <span class="keyword">socklen_t</span> len= <span class="keyword">sizeof</span>(client);                                                                                                                       </span><br><span class="line">    <span class="keyword">ssize_t</span> s=recvfrom(sock,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,<span class="number">0</span>,(struct sockaddr*)&amp;client,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(s&gt;<span class="number">0</span>)                                                                                                                                              </span><br><span class="line">    &#123;                                                                                                                                                    </span><br><span class="line">  buf[s]=<span class="number">0</span>;                                                                                                                                              </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[%s:%d]: %s\n"</span>,inet_ntoa(client.sin_addr),ntohs(client.sin_port),buf);                                                                         </span><br><span class="line">      sendto(sock,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>,(struct sockaddr*)&amp;client,<span class="keyword">sizeof</span>(client));                                                                           </span><br><span class="line">    &#125;                                                                                                                                                    </span><br><span class="line">  &#125;                                                                                                                                                      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                            </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                                                                                                                                     </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;                                                                                                                                </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;                                                                                                                                </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;                                                                                                                                 </span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">sockaddr</span>;</span>                                                                                                                      </span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockaddr_in</span>;</span>                                                                                                                </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;                                                                                                                      </span><br><span class="line">    <span class="keyword">int</span> sock=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);                                                                                                               </span><br><span class="line">   <span class="keyword">if</span> (sock&lt;<span class="number">0</span>) &#123;                                                                                                                                         </span><br><span class="line">     perror(<span class="string">"socket"</span>);                                                                                                                                   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">2</span>;                                                                                                                                           </span><br><span class="line"></span><br><span class="line">   &#125;                                                                                                                                                     </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span>                                                                                                                            </span><br><span class="line">   server.sin_family=AF_INET;                                                                                                                            </span><br><span class="line">   server.sin_port=htons(atoi(argv[<span class="number">2</span>]));                                                                                                                 </span><br><span class="line">   server.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);                                                                                                            </span><br><span class="line">  <span class="keyword">char</span> buff[<span class="number">1024</span>];                                                                                                                                       </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">peer</span>;</span>                                                                                                                               </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)                                                                                                                                               </span><br><span class="line">  &#123;                                                                                                                                                      </span><br><span class="line">  <span class="keyword">socklen_t</span> len =<span class="keyword">sizeof</span>(peer);                                                                                                                           </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter： "</span>);                                                                                                                                </span><br><span class="line">  fflush(<span class="built_in">stdout</span>);                                                                                                                                        </span><br><span class="line">  <span class="keyword">ssize_t</span> s=read(<span class="number">0</span>,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>);                                                                                                                 </span><br><span class="line">  <span class="keyword">if</span>(s&gt;<span class="number">0</span>)                                                                                                                                                </span><br><span class="line">  &#123;                                                                                                                                                      </span><br><span class="line">    buff[s<span class="number">-1</span>]=<span class="number">0</span>;                                                                                                                                         </span><br><span class="line">    sendto(sock,buff,<span class="built_in">strlen</span>(buff),<span class="number">0</span>,(struct sockaddr*)&amp;server,<span class="keyword">sizeof</span>(server));                                                                           </span><br><span class="line">    <span class="keyword">ssize_t</span> _s=recvfrom(sock,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>,<span class="number">0</span>,(struct sockaddr*)&amp;peer,&amp;len);</span><br><span class="line">    <span class="keyword">if</span> (_s&gt;<span class="number">0</span>) &#123;                                                                                                                                          </span><br><span class="line">      buff[_s]=<span class="number">0</span>;                                                                                                                                        </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"server echo %s\n"</span>,buff);                                                                                                                    </span><br><span class="line">    &#125;                                                                                                                                                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;                                                                                                                                                      </span><br><span class="line">  &#125;                                                                                                                                                      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                            </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>1.运行服务器<br><img src="http://pajznqooi.bkt.clouddn.com/UDP1.jpg" alt="404"><br>2.检查端口</p><p><img src="http://pajznqooi.bkt.clouddn.com/UDP2.jpg" alt="404"></p><p>3.运行客户端<br><img src="http://pajznqooi.bkt.clouddn.com/UDP3.jpg" alt="404"></p><p>4.查看服务器端<br><img src="http://pajznqooi.bkt.clouddn.com/UDP4.jpg" alt="404"></p>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模板</title>
      <link href="/2018/07/01/%E6%A8%A1%E6%9D%BF/"/>
      <url>/2018/07/01/%E6%A8%A1%E6%9D%BF/</url>
      <content type="html"><![CDATA[<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>模板是实现代码重用机制的一种工具，它可以实现数据类型的参数化，即将数据类型定义为参数，而由编译系统在处理具体函数调用时，根据实参类型来匹配函数模板中的对应形参并在确认后生成一个重载函数，从而真正实现代码重用。</p><p>C++中，允许用户构造函数模板，创建支持多种不同数据类型的形参但却具有通用功能的函数；也允许构造类模板，使的类中某些数据成员，成员函数的参数和返回值可以是任意数据类型。使用模板可以从一个函数生成多个函数或者从一个类模板生成多个类，建立一个模板后，编译器将根据使用时的实际数据类型使其实例化，生成可执行的代码，实例化的函数模板称为模板函数；实例化的类称为模板类。模板、模板函数、模板类以及对象关系如下：<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/%E6%A8%A1%E6%9D%BF.png" alt="404"><br>模板使用方法：<br><code>templete&lt;&lt;类型形参表》&lt;返回类型&gt;&lt;函数名&gt;(模板形参表){...}</code><br><!--more--></p><h3 id="模板函数的使用"><a href="#模板函数的使用" class="headerlink" title="模板函数的使用"></a>模板函数的使用</h3><pre><code class="c++"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;                                                                                                                                       </span></span><span class="keyword">using</span> <span class="keyword">namespace</span>  <span class="built_in">std</span>;                                                                                                                                    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                                                                                                       <span class="function">T <span class="title">Power</span><span class="params">(T base,<span class="keyword">int</span> exponent)</span>                                                                                                                             </span><span class="function"></span>{                                                                                                                                                         T value =base;                                                                                                                                           <span class="keyword">while</span>(--exponent&gt;<span class="number">0</span>)                                                                                                                                      {                                                                                                                                                       value*=base;                                                                                                                                             <span class="keyword">return</span> value;                                                                                                                                             }                                                                                                                                                       }                                                                                                                                                        <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                                                                                                                                               </span><span class="function"></span>{                                                                                                                                                          <span class="built_in">cout</span>&lt;&lt;<span class="string">"18^1="</span>&lt;&lt;Power(<span class="number">18</span>,<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;                                                                                                                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"5^3="</span>&lt;&lt;Power(<span class="number">5</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;                                                                                                                          <span class="built_in">cout</span>&lt;&lt;<span class="string">"2.6^7="</span>&lt;&lt;Power(<span class="number">2.6</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;                                                                                                                      <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                              }</code></pre><p>结果：<br><img src="http://pajznqooi.bkt.clouddn.com/%E6%A8%A1%E6%9D%BF1.jpg" alt="404"></p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vector</title>
      <link href="/2018/06/29/Vector/"/>
      <url>/2018/06/29/Vector/</url>
      <content type="html"><![CDATA[<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>名词解释：vector 是同一种类型的对象的集合,每个对象都有一个对应的整数索引值 。<br>和 string 对象一样,标准库将负责管理与存储元素相关的内存。我们把 vector称为容器,是因为它可以包含其他对象，能够存放任意类型的动态数组，增加和压缩数据。一个容器中的所有对象都必须是同一种类型的 。<br>vector 是一个类模板(class template)。使用模板可以编写一个类定义或函数定义,而用于多个不同的数据类型。因此,我们可以定义保存 string 对象的 vector,或保存 int 值的 vector,又或是保存自定义的类类型对象(如Sales_items 对象)的 vector。vector 不是一种数据类型,而只是一个类模板,可用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。<br><a id="more"></a></p><h3 id="vectors运用实例"><a href="#vectors运用实例" class="headerlink" title="vectors运用实例"></a>vectors运用实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;                                                                                                                                     </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;                                                                                                                                       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;                                                                                                                                       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;                                                                                                                                    </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sentence;</span><br><span class="line">sentence.reserve(<span class="number">5</span>);</span><br><span class="line">sentence.push_back(<span class="string">"hello,"</span>);</span><br><span class="line">sentence.push_back(<span class="string">"how"</span>);</span><br><span class="line">sentence.push_back(<span class="string">"are"</span>);</span><br><span class="line">sentence.push_back(<span class="string">"you"</span>);</span><br><span class="line">sentence.push_back(<span class="string">"？"</span>);</span><br><span class="line">copy(sentence.begin(), sentence.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size():"</span> &lt;&lt; sentence.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size():"</span> &lt;&lt; sentence.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity():"</span> &lt;&lt; sentence.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">swap(sentence[<span class="number">1</span>], sentence[<span class="number">3</span>]);</span><br><span class="line">sentence.insert(find(sentence.begin(), sentence.end(), <span class="string">"？"</span>), <span class="string">"always"</span>);</span><br><span class="line">sentence.back() = <span class="string">"!"</span>;</span><br><span class="line">copy(sentence.begin(), sentence.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"max():"</span> &lt;&lt; sentence.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size();"</span> &lt;&lt; sentence.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity()"</span> &lt;&lt; sentence.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/vector.jpg" alt="404"></p><p>实验结果可能如此，注意我说的是“可能”，是的当max_size()和capacity（）的结果由实作版本决定，从这个例子中你可以看到，当容量不足时，此一实作版本将容量扩充1。所以你可以试着运行一下看看有没有和我不同。</p>]]></content>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2018/06/28/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/06/28/Markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="Markdown编辑器写博客"><a href="#Markdown编辑器写博客" class="headerlink" title="Markdown编辑器写博客"></a>Markdown编辑器写博客</h2><p>新功能：</p><ul><li><strong>Markdown和扩展Markdown简洁的语法</strong></li><li><strong>代码块高亮</strong></li><li><strong>图片链接和图片上传</strong></li><li><strong><em>LaTex</em>数学公式</strong></li><li><strong>UML序列图和流程图</strong></li><li><strong>离线写博客</strong></li><li><strong>导入导出Markdown文件</strong></li><li><strong>丰富的快捷键</strong></li></ul><hr><a id="more"></a><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>加粗    <code>Ctrl + B</code></li><li>斜体    <code>Ctrl + I</code></li><li>引用    <code>Ctrl + Q</code></li><li>插入链接    <code>Ctrl + L</code></li><li>插入代码    <code>Ctrl + K</code></li><li>插入图片    <code>Ctrl + G</code></li><li>提升标题    <code>Ctrl + H</code></li><li>有序列表    <code>Ctrl + O</code></li><li>无序列表    <code>Ctrl + U</code></li><li>横线    <code>Ctrl + R</code></li><li>撤销    <code>Ctrl + Z</code></li><li>重做    <code>Ctrl + Y</code></li></ul><h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</a></p></blockquote><p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net" target="_blank" rel="noopener">链接</a>等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 表格</span><br><span class="line"></span><br><span class="line">**Markdown　Extra**　表格语法：</span><br><span class="line"></span><br><span class="line">项目     | 价格</span><br><span class="line">-------- | ---</span><br><span class="line">Computer | $1600</span><br><span class="line">Phone    | $12</span><br><span class="line">Pipe     | $1</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>项目</th><th>价格</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可以使用冒号来定义对齐方式：</span><br><span class="line"></span><br><span class="line">| 项目      |    价格 | 数量  |</span><br><span class="line">| :-------- | --------:| :--: |</span><br><span class="line">| Computer  | 1600 元 |  5   |</span><br><span class="line">| Phone     |   12 元 |  12  |</span><br><span class="line">| Pipe      |    1 元 | 234  |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">1600 元</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">12 元</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">1 元</td><td style="text-align:center">234</td></tr></tbody></table><p>###定义列表</p><p><strong>Markdown　Extra</strong>　定义列表语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">项目１</span><br><span class="line">项目２</span><br><span class="line">:   定义 A</span><br><span class="line">:   定义 B</span><br><span class="line"></span><br><span class="line">项目３</span><br><span class="line">:   定义 C</span><br><span class="line"></span><br><span class="line">:   定义 D</span><br><span class="line"></span><br><span class="line">&gt; 定义D内容</span><br></pre></td></tr></table></figure><p>项目１<br>项目２<br>:   定义 A<br>:   定义 B</p><p>项目３<br>:   定义 C</p><p>:   定义 D</p><pre><code>&gt; 定义D内容</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><p>###脚注<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生成一个脚注[^footnote].</span><br><span class="line">[^footnote]: 这里是 **脚注** 的 *内容*.</span><br></pre></td></tr></table></figure></p><p>生成一个脚注[^footnote].<br> [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p><p>[TOC]</p><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用MathJax渲染*LaTex* 数学公式，详见[math.stackexchange.com][1].</span><br><span class="line"></span><br><span class="line"> - 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</span><br><span class="line"> - 块级公式：</span><br><span class="line"></span><br><span class="line">$$x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$</span><br></pre></td></tr></table></figure><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href="http://math.stackexchange.com/" target="_blank" rel="noopener">math.stackexchange.com</a>.</p><ul><li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li><li>块级公式：</li></ul><p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><p>`</p><p>更多LaTex语法请参考 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">这儿</a>.</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：<br><code>sequence张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure><p>或者流程图：</p><p>flow<br>st=&gt;start: 开始<br>e=&gt;end: 结束<br>op=&gt;operation: 我的操作<br>cond=&gt;condition: 确认？</p><p>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>序列图</strong> 语法，参考 <a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">这儿</a>,</li><li>关于 <strong>流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">这儿</a>.</li></ul><hr>]]></content>
      
      
        <tags>
            
            <tag> 实用知识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汉诺塔</title>
      <link href="/2018/06/27/%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
      <url>/2018/06/27/%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
      <content type="html"><![CDATA[<h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><h3 id="由来及传说"><a href="#由来及传说" class="headerlink" title="由来及传说"></a>由来及传说</h3><p>由来：法国数学家爱德华·卢卡斯曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。<br>不管这个传说的可信度有多大，如果考虑一下把64片金片，由一根针上移到另一根针上，并且始终保持上小下大的顺序。这需要多少次移动呢?这里需要递归的方法。假设有n片，移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7，且f(k+1)=2*f(k)+1。此后不难证明f(n)=2^n-1。n=64时，<br>假如每秒钟一次，共需多长时间呢？一个平年365天有31536000 秒，闰年366天有31622400秒，平均每年31556952秒，计算一下：<br>18446744073709551615秒<br>这表明移完这些金片需要5845.54亿年以上，而地球存在至今不过45亿年，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，不说太阳系和银河系，至少地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。</p><p>印度传说：和汉诺塔故事相似的，还有另外一个印度传说：舍罕王打算奖赏国际象棋的发明人──宰相西萨·班·达依尔。国王问他想要什么，他对国王说：“陛下，请您在这张棋盘的第1个小格里赏给我一粒麦子，在第2个小格里给2粒，第3个小格给4粒，以后每一小格都比前一小格加一倍。请您把这样摆满棋盘上所有64格的麦粒，都赏给您的仆人吧！”国王觉得这个要求太容易满足了，就命令给他这些麦粒。当人们把一袋一袋的麦子搬来开始计数时，国王才发现：就是把全印度甚至全世界的麦粒全拿来，也满足不了那位宰相的要求。<br>那么，宰相要求得到的麦粒到底有多少呢？总数为<br>1+2+2^2 + … +2^63=2^64-1<br>等于移完汉诺塔所需的步骤数。我们已经知道这个数字有多么大了。人们估计，全世界两千年也难以生产这么多麦子！<br><a id="more"></a></p><h3 id="C语言汉诺塔的实现"><a href="#C语言汉诺塔的实现" class="headerlink" title="C语言汉诺塔的实现"></a>C语言汉诺塔的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="number">2</span> <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> form,<span class="keyword">char</span> to)</span>                                                                                                                   </span></span><br><span class="line"><span class="function">  3 </span>&#123;                                                                                                                                                    </span><br><span class="line">  <span class="number">4</span> <span class="built_in">printf</span>(<span class="string">"%d号盘从%c移到%c\n"</span>,n,form,to);                                                                                                              </span><br><span class="line">  <span class="number">5</span> &#125;                                                                                                                                                    </span><br><span class="line">  <span class="number">6</span>                                                                                                                                                      </span><br><span class="line">  <span class="number">7</span> <span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p1,<span class="keyword">int</span> p2,<span class="keyword">int</span> p3)</span>                                                                                                               </span></span><br><span class="line"><span class="function">  8 </span>&#123;                                                                                                                                                    </span><br><span class="line">  <span class="number">9</span>   <span class="keyword">if</span> (n==<span class="number">1</span>) &#123;                                                                                                                                        </span><br><span class="line"> <span class="number">10</span>     move(n,p1,p3);                                                                                                                                   </span><br><span class="line"> <span class="number">11</span>   &#125;                                                                                                                                                  </span><br><span class="line"> <span class="number">12</span>   <span class="keyword">else</span>&#123;                                                                                                                                              </span><br><span class="line"> <span class="number">13</span>     hanoi(n<span class="number">-1</span>,p1,p3,p2);                                                                                                                             </span><br><span class="line"> <span class="number">14</span>     move(n,p1,p3);                                                                                                                                   </span><br><span class="line"> <span class="number">15</span>     hanoi(n<span class="number">-1</span>,p2,p1,p3);                                                                                                                             </span><br><span class="line"> <span class="number">16</span>   &#125;                                                                                                                                                  </span><br><span class="line"> <span class="number">17</span> &#125;                                                                                                                                                    </span><br><span class="line"> <span class="number">18</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                                                                                                                                           </span></span><br><span class="line"><span class="function"> 19 </span>&#123;                                                                                                                                                    </span><br><span class="line"> <span class="number">20</span>   <span class="built_in">printf</span>(<span class="string">"请输入盘子的数量!\n"</span>);                                                                                                                     </span><br><span class="line"> <span class="number">21</span>   <span class="keyword">int</span> num=<span class="number">0</span>;                                                                                                                                         </span><br><span class="line"> <span class="number">22</span>   <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);                                                                                                                                  </span><br><span class="line"> <span class="number">23</span>   hanoi(num,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);                                                                                                                            </span><br><span class="line"> <span class="number">24</span>   <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                          </span><br><span class="line"> <span class="number">25</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E6%B1%89%E8%AF%BA%E5%A1%94.jpg" alt="这里写图片描述"><br><img src="http://pajznqooi.bkt.clouddn.com/%E6%B1%89%E8%AF%BA%E5%A1%941.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字符串中第一个只出现两次的字符</title>
      <link href="/2018/06/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/2018/06/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>找到字符串中第一个只出现两次的字符<br>例 字符串”abbcdefacdefba”<br>第一个只出现一次的字符是c</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>设置两个指针分别遍历数组<br>若指针1等于指针2则计数器加1，遍历完后若计数器为1则输出字符，并结束遍历</p><a id="more"></a><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findstr</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">char</span> tmp = <span class="string">'a'</span>;</span><br><span class="line"> <span class="keyword">char</span>*src = str+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (*str != <span class="string">'\0'</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> count = <span class="number">0</span>;</span><br><span class="line"> src = str+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (*src != <span class="string">'\0'</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (*str == *src)</span><br><span class="line"> &#123;</span><br><span class="line">   count++;</span><br><span class="line">   tmp = *src;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"> src++;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"找到字符是：%c\n"</span>,tmp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> str++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"没找到"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"abacdebaf"</span>;</span><br><span class="line">findstr(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%AD%97%E7%AC%A6.jpg" alt="这里写图片描述"><br><img src="http://pajznqooi.bkt.clouddn.com/%E5%AD%97%E7%AC%A62.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>选择排序</title>
      <link href="/2018/06/24/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/06/24/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>名词解释：选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>设置双重循环第一重循环从数组第一个元素开始，第二重循环从数组第二个元素开始，然后找出第二重循环中小于第一重循环的最小数，然后与第一重循环的首元素之交换。<br>图解：<br><img src="http://pajznqooi.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="这里写图片描述"><br><a id="more"></a></p><h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h3><p>时间复杂度：<code>O（n2)</code><br>空间复杂度：<code>O(1)</code><br>算法稳定性：不稳定算法</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selectionsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max; <span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">max = i;</span><br><span class="line"><span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; size; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[max]&gt;arr[j])</span><br><span class="line"></span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i != max)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">arr[i] = arr[max];</span><br><span class="line">arr[max] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">30</span>,<span class="number">300</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">Selectionsort(<span class="built_in">array</span>,num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基数排序</title>
      <link href="/2018/06/23/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/06/23/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>名词解释：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。<br>历史渊源：基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机(Tabulation Machine)上的贡献。它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p><a id="more"></a><p>第一步<br>以LSD为例，假设原来有一串数值如下所示：<br>73, 22, 93, 43, 55, 14, 28, 65, 39, 81<br>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：<br>0<br>1 81<br>2 22<br>3 73 93 43<br>4 14<br>5 55 65<br>6<br>7<br>8 28<br>9 39<br>第二步<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39<br>接着再进行一次分配，这次是根据十位数来分配：<br>0<br>1 14<br>2 22 28<br>3 39<br>4 43<br>5 55<br>6 65<br>7 73<br>8 81<br>9 93<br>第三步<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。<br>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</p><p>图解：<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png" alt="这里写图片描述"></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>时间效率 ：设待排序列为n个记录，d个关键码，关键码的取值范围为radix，则进行链式基数排序的时间复杂度为<code>O(d(n+radix))</code>，其中，一趟分配时间复杂度为<code>O(n)</code>，一趟收集时间复杂度为<code>O(radix)</code>，共进行d趟分配和收集。<br>空间效率：需要<code>2*radix</code>个指向队列的辅助空间，以及用于静态链表的n个指针故为<code>O(2*radix)</code></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Maxbit</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>; <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (arr[i]&gt;p)</span><br><span class="line">&#123;</span><br><span class="line">p *= <span class="number">10</span>;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = Maxbit(arr, num);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *tmp = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line"><span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">count[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">&#123;</span><br><span class="line">k = (arr[j] / index) % <span class="number">10</span>;</span><br><span class="line">count[k]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">count[j] = count[j - <span class="number">1</span>] + count[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = num - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">k = (arr[j] / index) % <span class="number">10</span>;</span><br><span class="line">tmp[count[k] - <span class="number">1</span>] = arr[j];</span><br><span class="line">count[k]--;</span><br><span class="line">&#125;</span><br><span class="line">index *= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">&#123;</span><br><span class="line">arr[j] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] tmp;</span><br><span class="line"><span class="keyword">delete</span>[] count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">30</span>,<span class="number">300</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">bucketsort(<span class="built_in">array</span>,num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>归并排序</title>
      <link href="/2018/06/21/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/06/21/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="归并排序（Mergesort"><a href="#归并排序（Mergesort" class="headerlink" title="归并排序（Mergesort)"></a>归并排序（Mergesort)</h3><p>名词解释 ：归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br><a id="more"></a></p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>归并排序采用分而治之思想将数组内容划分成许多个单位，使每个单位内序列为有序再合并各个有序的序列。<br>图解如下：<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F1.png" alt="这里写图片描述"></p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述:"></a>算法描述:</h3><p>时间复杂度:<code>O(n log n)</code><br>空间复杂度:<code>O（n)</code><br>算法稳定性：稳定</p><p>算法实现步骤：<br>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。<br>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置。<br>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。<br>重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>实现归并排序首先要实现两个有序数组的合并：<br>算法如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemeryArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> b[], <span class="keyword">int</span> m, <span class="keyword">int</span> c[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j, k;  </span><br><span class="line"></span><br><span class="line">    i = j = k = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; b[j])  </span><br><span class="line">            c[k++] = a[i++];  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            c[k++] = b[j++];   </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)  </span><br><span class="line">        c[k++] = a[i++];  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m)  </span><br><span class="line">        c[k++] = b[j++];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了合并以后就完成了算法的主体，全部实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergetarr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> tmp[])</span><span class="comment">//合并算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line">i = left; k = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">j = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=right )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i]&lt;=arr[j])</span><br><span class="line">&#123;</span><br><span class="line">tmp[k++]=arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">tmp[k++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j&lt;=right)</span><br><span class="line">&#123;</span><br><span class="line">tmp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">arr[left + i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">mergetsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right,<span class="keyword">int</span> tmp[])</span><span class="comment">//归并排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left&lt;right )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">mergetsort(arr,left,mid,tmp);<span class="comment">//左边归并</span></span><br><span class="line">mergetsort(arr, mid+<span class="number">1</span>, right,tmp);<span class="comment">//右边归并</span></span><br><span class="line">mergetarr(arr, left, right, tmp);<span class="comment">//合并左右</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">13</span>,<span class="number">25</span>,<span class="number">14</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">89</span>,<span class="number">56</span>,<span class="number">14</span>,<span class="number">25</span>,<span class="number">58</span>,<span class="number">78</span>,<span class="number">36</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">22</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">mergetsort(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>])<span class="number">-1</span>,p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法的稳定性</title>
      <link href="/2018/06/21/%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
      <url>/2018/06/21/%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
      <content type="html"><![CDATA[<h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>名词解释：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。</p><h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><p>对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。<br><a id="more"></a><br>举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n &amp;&amp; flag == <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt;arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;                             </span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">temp = a[j];</span><br><span class="line">a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">a[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*此算法本来是稳定的但是如果将判断条件改为a[j].key &gt;=a[j+1].key，</span></span><br><span class="line"><span class="comment">则会影响原来数值相同数据的的位置，就会变成不稳定的排序方法*/</span></span><br></pre></td></tr></table></figure></p><h3 id="常见算法的稳定性分析"><a href="#常见算法的稳定性分析" class="headerlink" title="常见算法的稳定性分析"></a>常见算法的稳定性分析</h3><p>堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。</p><p>其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就 是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。</p><p>八大排序分析：<br>(1)冒泡排序<br>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无 聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。<br>(2)选择排序<br>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。<br>(3)插入排序<br>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。<br>(4)快速排序<br>快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。<br>(5)归并排序<br>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。<br>(6)基数排序<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。<br>(7)希尔排序(shell)<br>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。<br>(8)堆排序<br>我们知道堆的结构是节点i的孩子为2<em>i和2</em>i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p><h3 id="稳定性的意义"><a href="#稳定性的意义" class="headerlink" title="稳定性的意义"></a>稳定性的意义</h3><p>不需要用到稳定性： 如果只是简单的进行数字的排序，那么稳定性将毫无意义，如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧将毫无意义，如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧将毫无意义。</p><p>需要用到稳定性： 排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法，例如要排序的内容是一组原本按照价格高低排序的货物，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的货物依旧保持着价格高低的排序，只有销量不同的才会重新排序，因此如果需求不需要保持初始的排序意义，那么使用稳定性算法和不稳定算法是一样的。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>希尔排序</title>
      <link href="/2018/06/20/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/06/20/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="希尔排序（Shell’s-Sort"><a href="#希尔排序（Shell’s-Sort" class="headerlink" title="希尔排序（Shell’s Sort)"></a>希尔排序（Shell’s Sort)</h3><p>名词解释：希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>1.插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。<br>2.但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>教科书表达：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2(小于d1）重复上述的分组和排序，直至所取的增量 =1(  &lt;  …&lt; &lt; d2 &lt; d1)，即所有记录放在同一组中进行直接插入排序为止。<br>简单来说：一个书架放着一排书，现在从第一本书起每数X本书，就在那本书上贴红色贴纸，贴完红色贴纸后，再次从第二本书起每数X本书就贴上蓝色贴纸（跟之前颜色不同即可），重复贴纸过程，直到所有书都贴满贴纸。接着对有相同颜色贴纸的书做插入排序。然后撕掉所有贴纸后重新对书进行贴纸，这次则每数Y本书就贴纸（Y &lt; X）,所有书贴满后再进行插入排序。重复贴纸排序、贴纸排序这个过程，直到最后每数1本书就贴纸（也就是每本书都贴同样颜色贴纸），再插入排序为止。<br>话不多说，看图<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt="这里写图片描述"><br><a id="more"></a></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>稳定性：由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。<br>时间复杂度：<code>O(n^2)</code><br>空间复杂度：<code>O(1)</code></p><p>常见排序算法一般按平均时间复杂度分为两类：<br><code>O(n^2)</code>：冒泡排序、选择排序、插入排序<br><code>O(nlogn)</code>：归并排序、快速排序、堆排序<br>1w和10w数据效率如下：</p><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F3.png" alt="这里写代码片"></p><h3 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h3><p>正如我们所知道的希尔排序的增量序列是影响希尔排序效率的最关键因素，至今为止还没有一个最完美的增量序列公式。可究竟应该选取什么样的增量才是最好，目前还是一个数学难题。<br>看如下两个增量序列：<br>n/2、n/4、n/8…1<br>1、3、7…2^k-1<br>第一个序列称为希尔增量序列，使用希尔增量时，希尔排序在最坏情况下的时间复杂度为O(n*n)。<br>第二个序列称为Hibbard增量序列，使用Hibbard增量时，希尔排序在最坏情况下的时间复杂度为O(n^3/2)。　<br>10w数据对比如下图：<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F4.png" alt="这里写图片描述"></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> size)</span><span class="comment">//希尔排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size&lt;=<span class="number">0</span>||arr==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> div = <span class="number">0</span>; <span class="keyword">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (div = size / <span class="number">2</span>; div &gt;= <span class="number">1</span>; div /= <span class="number">2</span>)<span class="comment">//定义增量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; div; i++)<span class="comment">//分成div组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; size; j += div)<span class="comment">//对数据插入排序</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (k = i; k &lt; size - div; k += div)&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[k])</span><br><span class="line">&#123;</span><br><span class="line">swap(arr[j], arr[k]);<span class="comment">//交换数据的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">13</span>,<span class="number">25</span>,<span class="number">14</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">22</span>&#125;;</span><br><span class="line">shellsort(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]));</span><br><span class="line"><span class="comment">/*for (auto it: array)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; it;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>堆排序</title>
      <link href="/2018/06/18/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/06/18/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="堆排序（-Heap-Sort"><a href="#堆排序（-Heap-Sort" class="headerlink" title="堆排序（ Heap Sort )"></a>堆排序（ Heap Sort )</h3><p>堆排序要用到堆，那什么是堆呢？可以参考我的一博客<a href="https://blog.csdn.net/weibo_dm/article/details/80718839" target="_blank" rel="noopener">什么是堆？</a></p><p>名词解释：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd）和威廉姆斯(J．Williams）在1964年共同发明了著名的堆排序算法。<br><a id="more"></a></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用Heapify实现的。<br>平均性能：<code>O(N*logN)</code></p><p>其他性能:由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。<br>堆排序是就地排序，辅助空间为O(1)。<br>堆排序是不稳定的排序方法（当数组中有相等元素时，堆排序算法对这些元素的处理方法不止一种）。（排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前 和排序后他们的相对位置不发生变化）。</p><h3 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h3><p>1.将无序序列构建成一个堆，根据升序降序需求选择大顶堆（升序）或小顶堆（降序）。<br>2.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端。<br>3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p><p>将堆化为数组：<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F.jpg" alt="这里写图片描述"></p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span><span class="comment">//调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> maxIdx = index;</span><br><span class="line"><span class="keyword">if</span> (left&lt;len &amp;&amp; arr[left] &gt; arr[maxIdx]) maxIdx = left;</span><br><span class="line"><span class="keyword">if</span> (right&lt;len &amp;&amp; arr[right] &gt; arr[maxIdx]) maxIdx = right;  <span class="comment">// maxIdx是3个数中最大数的下标</span></span><br><span class="line"><span class="keyword">if</span> (maxIdx != index)                 <span class="comment">// 如果maxidx被更新</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[maxIdx], arr[index]);<span class="comment">//交换</span></span><br><span class="line">adjust(arr, len, maxIdx);       <span class="comment">// 递归调整其他不满足堆性质的部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span><span class="comment">//堆排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="comment">// 对每一个非叶结点进行堆调整(从最后一个非叶结点开始)</span></span><br><span class="line">&#123;</span><br><span class="line">adjust(arr, size, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">swap(arr[<span class="number">0</span>], arr[i]);           <span class="comment">// 将当前最大的放置到数组末尾</span></span><br><span class="line">adjust(arr, i, <span class="number">0</span>);              <span class="comment">// 将未完成排序的部分继续进行堆排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">8</span>] = &#123; <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span> &#125;;</span><br><span class="line">heapSort(<span class="built_in">array</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">/*for (auto it: array)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; it;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>什么是堆</title>
      <link href="/2018/06/17/%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86/"/>
      <url>/2018/06/17/%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86/</url>
      <content type="html"><![CDATA[<h2 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h2><p>堆是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。<br>堆的性质：<br>1.堆中某个节点的值总是不大于或不小于其父节点的值。<br>2.堆总是一棵完全二叉树。<br><a id="more"></a></p><h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><p>将根节点最大的堆叫做最大堆或大顶堆，根节点最小的堆叫做最小堆或小顶堆。常见的堆有二叉堆、斐波那契堆等。<br>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。<br>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)<br>若将和此次序列对应的一维数组（即以一维数组作此序列的存储结构）看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。由此，若序列{k1,k2,…,kn}是堆，则堆顶元素（或完全二叉树的根）必为序列中n个元素的最小值（或最大值）。<br>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：<br>大堆：<br><img src="http://pajznqooi.bkt.clouddn.com/2.jpg" alt="网络故障"><br>小堆：<br><img src="http://pajznqooi.bkt.clouddn.com/3.jpg" alt="网络故障"></p><h2 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h2><p>build:建立一个空堆；<br>insert:向堆中插入一个新元素；<br>update：将新元素提升使其符合堆的性质；<br>get：获取当前堆顶元素的值；<br>delete：删除堆顶元素；<br>heapify：使删除堆顶元素的堆再次成为堆。<br>某些堆实现还支持其他的一些操作，如斐波那契堆支持检查一个堆中是否存在某个元素。</p><h2 id="建堆效率"><a href="#建堆效率" class="headerlink" title="建堆效率"></a>建堆效率</h2><p>n个结点的堆，高度d =log2n。根为第0层，则第i层结点个数为2i，考虑一个元素在堆中向下移动的距离。大约一半的结点深度为d-1，不移动（叶）。四分之一的结点深度为d-2，而它们至多能向下移动一层。树中每向上一层，结点的数目为前一层的一半，而子树高度加一。<br>这种算法时间代价为Ο（n)由于堆有log n层深，插入结点、删除普通元素和删除最小元素的平均时间代价和时间复杂度都是Ο（log n）。</p><h2 id="关于堆的操作实现"><a href="#关于堆的操作实现" class="headerlink" title="关于堆的操作实现"></a>关于堆的操作实现</h2><p>在程序中，堆用于动态分配和释放程序所使用的对象。在以下情况中调用堆操作：<br>1.事先不知道程序所需对象的数量和大小。<br>2.对象太大，不适合使用堆栈分配器。<br>堆使用运行期间分配给代码和堆栈以外的部分内存。<br>传统上，操作系统和运行时库随附了堆实现。当进程开始时，操作系统创建称为进程堆的默认堆。如果没有使用其他堆，则使用进程堆分配块。语言运行时库也可在一个进程内创建单独的堆。（例如，C 运行时库创建自己的堆。）除这些专用堆外，应用程序或许多加载的动态链接库 (DLL) 之一也可以创建并使用单独的堆。Win32 提供了一组丰富的 API用于创建和使用专用堆。有关堆函数的优秀教程，请参阅 MSDN 平台 SDK 节点。<br>当应用程序或 DLL 创建专用堆时，这些堆驻留于进程空间中并且在进程范围内是可访问的。某一给定堆分配的任何数据应为同一堆所释放。（从一个堆分配并释放给另一个堆没有意义。）<br>在所有虚拟内存系统中，堆位于操作系统的虚拟内存管理器之上。语言运行时堆也驻留在虚拟内存之上。某些情况下，这些堆在操作系统堆的上层，但语言运行时堆通过分配大的块来执行自己的内存管理。绕开操作系统堆来使用虚拟内存函数可使堆更好地分配和使用块。<br>典型的堆实现由前端分配器和后端分配器组成。前端分配器维护固定大小块的自由列表。当堆收到分配调用后，它尝试从前端列表中查找自由块。如果此操作失败，则堆将被迫从后端（保留和提交虚拟内存）分配一个大块来满足请求。通常的实现具有每个块分配的开销，这花费了执行周期，也减少了可用存储区。<br>单个全局锁可防止多线程同时使用堆。此锁主要用于保护堆数据结构不受多线程的任意访问。当堆操作过于频繁时，此锁会对性能造成负面影响。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">JBMinHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//申请堆空间</span></span><br><span class="line">    T *_minHeap = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> _index,_maxSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    JBMinHeap(<span class="keyword">int</span> maxSize) &#123;</span><br><span class="line">        _maxSize = maxSize;</span><br><span class="line">        _minHeap = <span class="keyword">new</span> T[_maxSize];</span><br><span class="line">        _index = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    JBMinHeap(JBMinHeap &amp;h) &#123;</span><br><span class="line">        _index = h._index;</span><br><span class="line">        _maxSize = h._maxSize;</span><br><span class="line">        _minHeap = <span class="keyword">new</span> T[_maxSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;_maxSize) &#123;</span><br><span class="line">            *_minHeap[i] = *h._minHeap[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~JBMinHeap() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[]_minHeap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取整个最小堆的头部指针</span></span><br><span class="line">    <span class="function">T * <span class="title">getMinHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _minHeap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断堆是不是空的</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _index == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _index++;</span><br><span class="line">        _minHeap[_index] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _index == _maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//堆进行向下调整</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="comment">//队进行向上调整</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjustUp</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="comment">//建堆运算</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMinHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (_index<span class="number">-1</span>)/<span class="number">2</span>;i &gt;<span class="number">-1</span>;i--) &#123;<span class="comment">//直接从倒数第二层 逐层向下调整</span></span><br><span class="line">            adjustDown(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">JBMinHeap</span>&lt;T&gt;:</span>:adjustDown(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index&lt;_index)</span><br><span class="line">    &#123;</span><br><span class="line">        T temp = _minHeap[index];<span class="comment">//将当前索引的位置的值保存下来</span></span><br><span class="line">        <span class="keyword">int</span> oneC = <span class="number">2</span> * index + <span class="number">1</span>;<span class="comment">//获取到两个孩子的位置</span></span><br><span class="line">        <span class="keyword">int</span> twoC = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (oneC == _index) &#123;<span class="comment">//若第一个孩子是整个堆最后一个位置 则直接执行交换操作并结束执行</span></span><br><span class="line">                _minHeap[index] = _minHeap[oneC];</span><br><span class="line">                _minHeap[oneC] = temp;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (twoC &gt;_index) &#123;<span class="comment">//如果第二个孩子的索引位置越界 结束执行</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_minHeap[oneC] &lt;= _minHeap[twoC]) &#123;<span class="comment">//正常情况的数据交互执行</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt; _minHeap[oneC]) &#123;</span><br><span class="line">                _minHeap[index] = _minHeap[oneC];</span><br><span class="line">                _minHeap[oneC] = temp;</span><br><span class="line">                index = oneC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//如果该处索引值已经是比两个孩子小 则结束循环</span></span><br><span class="line">                index = _index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; _minHeap[twoC]) &#123;</span><br><span class="line">                _minHeap[index] = _minHeap[twoC];</span><br><span class="line">                _minHeap[twoC] = temp;</span><br><span class="line">                index = twoC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                index = _index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">JBMinHeap</span>&lt;T&gt;:</span>:adjustUp(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; _index) &#123;<span class="comment">//大于堆的最大值直接return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index&gt;<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T temp = _minHeap[index];</span><br><span class="line">        <span class="keyword">int</span> father = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (father &gt;= <span class="number">0</span>) &#123;<span class="comment">//若果索引没有出界就执行想要的操作</span></span><br><span class="line">            <span class="keyword">if</span> (temp &lt; _minHeap[father]) &#123;</span><br><span class="line">                _minHeap[index] = _minHeap[father];</span><br><span class="line">                _minHeap[father] = temp;</span><br><span class="line">                index=father;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//若果已经是比父亲大 则直接结束循环</span></span><br><span class="line">                index = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//出界就结束循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>空间复杂度</title>
      <link href="/2018/06/15/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2018/06/15/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      <content type="html"><![CDATA[<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>  前面刚讲了时间复杂度，有兴趣的去看看<a href="https://blog.csdn.net/weibo_dm/article/details/80710491" target="_blank" rel="noopener">什么是时间复杂度？</a><br>名词解释：空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。</p><h3 id="度量方法"><a href="#度量方法" class="headerlink" title="度量方法"></a>度量方法</h3><p> 类似于 时间复杂度的讨论，一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。空间复杂度(SpaceComplexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\”进行的，是节省存储的算法，有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。<br><a id="more"></a></p><h3 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h3><p>分析一个算法所占用的存储空间要从各方面综合考虑。如对于递归算法来说，一般都比较简短，算法本身所占用的存储空间较少，但运行时需要一个附加堆栈，从而占用较多的临时工作单元；若写成非递归算法，一般可能比较长，算法本身占用的存储空间较多，但运行时将可能需要较少的存储单元。<br>一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。若一个算法为 [2]  递归算法，其空间复杂度为递归所使用的堆栈空间的大小，它等于一次调用所分配的临时存储空间的大小乘以被调用的次数(即为递归调用的次数加1，这个1表示开始进行的一次非递归调用)。算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)；当一个算法的空间复杂度与n成线性比例关系时，可表示为O(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。<br>故一个算的空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。所以它强调的是使用的辅助空间的的大小，而不是指所有的数据所占用的空间。<br>以斐波那契算法为例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>* <span class="title">fib</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    assert(n&gt;=<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>* ptr=<span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[n+<span class="number">1</span>];  </span><br><span class="line">    ptr[<span class="number">0</span>]=<span class="number">0</span>;  </span><br><span class="line">    ptr[<span class="number">1</span>]=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        ptr[i]=ptr[i<span class="number">-1</span>]+ptr[i<span class="number">-2</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ptr;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/*对于这种算法，函数真正执行次数为n-1,所以忽略常数后，时间复杂度为O(n);</span></span><br><span class="line"><span class="comment">因为开辟了n+1个空间，有n+1个辅助空间，所以空间复杂度为O(n).*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    assert(n&gt;=<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> first=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> second=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        ret=first+second;  </span><br><span class="line">        first=second;  </span><br><span class="line">        second=ret;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/*这是非递归的另一种算法，函数真正执行次数依然为n-1,所以忽略常数后，时间复杂度还是O(n);</span></span><br><span class="line"><span class="comment">由于采用变量交换的方式，所以在这里辅助空间个数为一个常数，空间复杂度为O(1).*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    assert(n&gt;=<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> (n&lt;<span class="number">2</span>)?(n):(fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>));  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/*递归算法的时间复杂度计算方法是:递归总次数*每次递归次数；</span></span><br><span class="line"><span class="comment">递归算法的时间复杂度计算方法是：递归深度*每次递归所需的辅助空间个数.</span></span><br><span class="line"><span class="comment">可以得出斐波那契递归算法时间复杂度：O（2^N），空间复杂度为:O(N)*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value=fib(<span class="number">15</span>);  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; value &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    system(<span class="string">"pause"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度与空间复杂度的联系"><a href="#时间复杂度与空间复杂度的联系" class="headerlink" title="时间复杂度与空间复杂度的联系"></a>时间复杂度与空间复杂度的联系</h3><p>对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。算法的时间复杂度和空间复杂度合称为算法的复杂度。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2018/06/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2018/06/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      <content type="html"><![CDATA[<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>算法复杂度分为时间复杂度和空间复杂度。其作用： 时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。（算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度）。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。</p><h3 id="时间复杂度计算方法"><a href="#时间复杂度计算方法" class="headerlink" title="时间复杂度计算方法"></a>时间复杂度计算方法</h3><p>1.一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。<br>分析：随着模块n的增大，算法执行的时间的增长率和 f(n) 的增长率成正比，所以 f(n) 越小，算法的时间复杂度越低，算法的效率越高。<br>2.在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级（它的同数量级有以下：1，log2n，n，n log2n ，n的平方，n的三次方，2的n次方，n!），找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数c，则时间复杂度T(n) = O(f(n))。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>循环如下：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">for(i=1; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    for(j=1; j&lt;=n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][j] = 0;//该步骤属于基本操作执行次数：n的平方次</span><br><span class="line">        for(k=1; k&lt;=n; ++k)</span><br><span class="line">        c[i][j] += a[i][k] * b[k][j];//该步骤属于基本操作执行次数：n的三次方次</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//则有，根据上面括号里的同数量级，我们可以确定n的三次方为T（n）的同数量级。</span><br><span class="line">//则有，然后根据 T(n)/f(n) 求极限可得到常数c。</span><br><span class="line">//则该算法的时间复杂度：T(n) = O(n^3) 注：n^3即是n的3次方。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例2</span><br><span class="line">//如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，</span><br><span class="line">//则将并列循环的时间复杂度相加。</span><br><span class="line"></span><br><span class="line">　　for (i=1; i&lt;=n; i++)</span><br><span class="line">　　&#123;</span><br><span class="line">　　x++;</span><br><span class="line">　　&#125;</span><br><span class="line">　　for (i=1; i&lt;=n; i++)</span><br><span class="line">　　&#123;</span><br><span class="line">　　for (j=1; j&lt;=n; j++)</span><br><span class="line">　　&#123;</span><br><span class="line">　　x++;</span><br><span class="line">　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　//第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，</span><br><span class="line">　　//则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。</span><br></pre></td></tr></table></figure></p><p>常见的算法时间复杂度由小到大依次为：<br>Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。Ο(log2n)、Ο(n)、Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者是有效算法，把这类问题称为P类问题，而把后者称为NP问题。但这也只能计算基本的计算时间复杂度，具体的运行还会与硬件有关。</p>]]></content>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql基本操作</title>
      <link href="/2018/06/13/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/06/13/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="Mysql安装"><a href="#Mysql安装" class="headerlink" title="Mysql安装"></a>Mysql安装</h3><p>mysql 是一个小型的数据库<br>安装过程参考：<a href="http://blog.51cto.com/aiilive/2116476" target="_blank" rel="noopener">MySQL安装过程</a><br>1.首先登入数据库（在cmd窗口进行操作）<br>输入：<figure class="highlight plain"><figcaption><span>-u root -p```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">![这里写图片描述](https://img-blog.csdn.net/20180613225925564?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line"></span><br><span class="line">2.建立一个数据库</span><br><span class="line">```create datebase  lala；(数据库名，可以根据实际项目取名）</span><br></pre></td></tr></table></figure></p><p>2.使用本数据库<br><figure class="highlight plain"><figcaption><span>table1；```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入此条语句数据库才能进行操作</span><br><span class="line">4.数据库的增删改查操作</span><br></pre></td></tr></table></figure></p><p>增：insert into table(表名） value（);（“()”中数据类型与表单的元素一一对应）<br>删：delete from table where la=1;<br>改：update table set la=1 where dada=”haha”;<br>查：select *(显示全部符号，也可以指定显示内容如dada） from table;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5.删除表</span><br><span class="line">```drop table tb1;</span><br></pre></td></tr></table></figure></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>1.空值与非空约束<br><figure class="highlight plain"><figcaption><span>table tb2 (user_name not null,user_age null);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2.自增约束</span><br><span class="line">自动编号 起始为1</span><br><span class="line">自动编号的字段必须设置为主键（primary key）</span><br><span class="line">例如create table tb2 (user_name auto_increment primary key);</span><br><span class="line">auto_increment 必须定义为主键  而主键不一定要是auto increment  </span><br><span class="line">3.主键约束primary key</span><br><span class="line">主键必须为not null</span><br><span class="line">主键会保证唯一性</span><br><span class="line">4.唯一约束</span><br><span class="line">unique key 保证唯一性</span><br><span class="line">### 数据表列操作</span><br></pre></td></tr></table></figure></p><p>1.添加列<br>alter tbale tb1 column a varchar;<br>新增列名为a的字段<br>2.删除列<br>alter table tb1 column x;<br>删除列名为x的字段<br>3.查询表中的所有列名<br> show columns from 表名;<br>ex:show columns from tb1;<br>4.调整字段的位置(first,last)<br>  alter table tb1 modify  y int first;<br>将该字段放到最前面去了；<br>5.修改字段的数据类型<br>alter table tb1 modify x  smallint;<br>由大类型改到小类型可能会造成数据的丢失；<br>6.修改字段的名称<br>alter table tb1  change  x  xx int;<br>将x字段更名为xx字段，其类型为int 型<br>该语句修改数据表中字段的名称和数据类型<br>7.查看表中的所有列<br>show columns from tb1;<br>8.输出所有列<br>select <em>  from tb1;<br>select </em> from tb1\G  以网格形式输出所有列<br><code>`</code></p>]]></content>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>翻转字符串</title>
      <link href="/2018/06/11/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/06/11/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入：i am a student.<br>输出：student.a am i</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先总体反转，然后逐个单词反转，首先，将字符串完全翻转一次，得到.tneduts a ma i。然后设置两个指针，对单词进行翻转，也就是局部翻转.<br><a id="more"></a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllReverse</span><span class="params">(<span class="keyword">char</span> *pStart, <span class="keyword">char</span> *pEnd)</span><span class="comment">//全反转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> pTemp;</span><br><span class="line"><span class="keyword">if</span> (pStart == <span class="literal">NULL</span> || pEnd == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pStart &lt; pEnd)</span><br><span class="line">&#123;</span><br><span class="line">pTemp = *pStart;</span><br><span class="line">*pStart = *pEnd;</span><br><span class="line">*pEnd = pTemp;</span><br><span class="line"></span><br><span class="line">pStart++;</span><br><span class="line">pEnd--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> *pData)</span><span class="comment">//单词反转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pData == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *pStart = pData;</span><br><span class="line"><span class="keyword">char</span> *pEnd = pData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*pEnd != <span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line">pEnd++;</span><br><span class="line">&#125;</span><br><span class="line">pEnd--;</span><br><span class="line"></span><br><span class="line">AllReverse(pStart, pEnd);<span class="comment">//全反转</span></span><br><span class="line"></span><br><span class="line">pStart = pEnd = pData;</span><br><span class="line"><span class="keyword">while</span> (*pStart != <span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*pStart == <span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line">pStart++;</span><br><span class="line">pEnd++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*pEnd == <span class="string">' '</span> || *pEnd == <span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line">AllReverse(pStart, --pEnd);</span><br><span class="line">pStart = ++pEnd;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pEnd++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">// 主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a_arr[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> * str = <span class="literal">NULL</span>;</span><br><span class="line">gets_s(a_arr);</span><br><span class="line">str = Reverse(a_arr);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://img-blog.csdn.net/20180611233045464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>找到数组第一个相同的数</title>
      <link href="/2018/06/06/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0/"/>
      <url>/2018/06/06/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组，然找到数组里第一个重复的数字。<br>例：<br>   arr[]={1,2,4,3,6,5,6,5,8,9}<br>找到5。</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checknum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> key = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">  &#123;</span><br><span class="line">  key = arr[j];</span><br><span class="line">  <span class="keyword">for</span> (i = j + <span class="number">1</span>; i &lt; num; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] == key)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"该数组有重复数字,数字是："</span> &lt;&lt; key &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"没有重复的数字"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">  checknum(arr, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://img-blog.csdn.net/20180608171059770?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>寻找两个链表公共节点</title>
      <link href="/2018/06/06/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
      <url>/2018/06/06/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>两个单向链表，找出它们的第一个公共结点。<br>数据类型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果两个单向链表有公共的结点，也就是说两个链表从某一结点开始，它们的Next都指向同一个结点。但由于是单向链表的结点，每个结点只有一个Next，因此从第一个公共结点开始，之后它们所有结点都是重合的，不可能再出现分叉。所以，两个有公共结点而部分重合的链表，拓扑形状看起来像一个Y，而不可能像X。<br>看到这个题目，第一反应就是蛮力法：在第一链表上顺序遍历每个结点。每遍历一个结点的时候，在第二个链表上顺序遍历每个结点。如果此时两个链表上的结点是一样的，说明此时两个链表重合，于是找到了它们的公共结点。如果第一个链表的长度为m，第二个链表的长度为n，显然，该方法的时间复杂度为O(mn)。<br>接 下来我们试着去寻找一个线性时间复杂度的算法。我们先把问题简化：如何判断两个单向链表有没有公共结点？前面已经提到，如果两个链表有一个公共结点，那么 该公共结点之后的所有结点都是重合的。那么，它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分，只要分别遍历两个链表到最后一 个结点。如果两个尾结点是一样的，说明它们用重合；否则两个链表没有公共的结点。<br>在上面的思路中，顺序遍历两个链表到尾结点的时候，我们不能保证在两个链表上同时到达尾结点。这是因为两个链表不一定长度一样。但如果假设一个链表比另一个长l个结点，我们先在长的链表上遍历l个结点，之后再同步遍历，这个时候我们就能保证同时到达最后一个结点了。由于两个链表从第一个公共结点考试到链表的尾结点，这一部分是重合的。因此，它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。在这个思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历若干次之后，再同步遍历两个链表，知道找到相同的结点，或者一直到链表结束。此时，如果第一个链表的长度为m，第二个链表的长度为n，该方法的时间复杂度为O(m+n)。</p><p>基于这个思路，我们不难写出如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>//数据结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">findnode</span><span class="params">(Node* head, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">init_list</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//初始化链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"链表数目个数有问题"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入 "</span> &lt;&lt; n &lt;&lt; <span class="string">"个数据"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n-- &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Node* ptr = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ptr-&gt;data;</span><br><span class="line">ptr-&gt;next = head;</span><br><span class="line">head = ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(Node *head)</span><span class="comment">//打印链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"这是一个空链表"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; head-&gt;data &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">sort_list</span><span class="params">(Node* head)</span><span class="comment">//遍历链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"链表为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (head)</span><br><span class="line">&#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">findnode</span><span class="params">(Node* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* ptr = head;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line">ptr = ptr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindFirstCommonNode</span><span class="params">(Node* head1, Node* head2)</span><span class="comment">//寻找公共节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(head1);</span><br><span class="line">assert(head2);</span><br><span class="line"><span class="keyword">int</span> len1 = sort_list(head1);</span><br><span class="line"><span class="keyword">int</span> len2 = sort_list(head2);</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (len1 &gt; len2)</span><br><span class="line">&#123;</span><br><span class="line">tmp = len1 - len2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp; i++)</span><br><span class="line">&#123;</span><br><span class="line">head1 = head1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = len2 - len1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp; i++)</span><br><span class="line">&#123;</span><br><span class="line">head2 = head2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((head1 != <span class="literal">NULL</span>) &amp;&amp; (head2 != <span class="literal">NULL</span>) &amp;&amp; (head1 != head2))</span><br><span class="line">&#123;</span><br><span class="line">head1 = head1-&gt;next;</span><br><span class="line">head2 = head2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">Node* key = head1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"公共节点为"</span> &lt;&lt; key-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你想要创建的链表节点个数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">Node* ptr = init_list(n);</span><br><span class="line">show(ptr);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你想要创建的链表节点个数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">Node* ptr1 = init_list(m);</span><br><span class="line">findnode(ptr1,m<span class="number">-1</span>)-&gt;next = findnode(ptr, <span class="number">3</span>);</span><br><span class="line">show(ptr1);</span><br><span class="line">FindFirstCommonNode(ptr, ptr1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p><img src="https://img-blog.csdn.net/20180609235020561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言注释转C++注释</title>
      <link href="/2018/06/04/C%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A%E8%BD%ACC++%E6%B3%A8%E9%87%8A/"/>
      <url>/2018/06/04/C%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A%E8%BD%ACC++%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>int a = 10;<br>// 1.一般情况<br>int num = 0;<br>/_ int i = 0; _/</p><p>// 2.换行问题<br>/_ int i = 0; <em>/int j = 0;<br>/</em> int i = 0; _/<br>int j = 0;</p><p>// 3.匹配问题<br>/_int i = 0;/_xxxxx*/</p><p>// 4.多行注释问题<br>/_<br>int i=0;<br>int j = 0;<br>int k = 0;<br>_/int k = 0;</p><p>// 5.连续注释问题<br>/<em>int a=0;</em>//<em>int b=0;</em>/</p><p>// 6.连续的<strong>/问题<br>/*</strong>/</p><p>// 7.C++注释问题<br>// /<em>xxxxxxxxxxxx</em>/<br><a id="more"></a></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p><img src="http://img.blog.csdn.net/20170914173237582?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpYm9fZG0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="分析图"></p><h2 id="代码片"><a href="#代码片" class="headerlink" title="代码片"></a>代码片</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMMENTCONVERT_HEADFILE__   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMMENTCONVERT_HEADFILE__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">enum</span> STATE    </span><br><span class="line">&#123;</span><br><span class="line">NUL,</span><br><span class="line">C,</span><br><span class="line">CPP,</span><br><span class="line">END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CommentConvert</span><span class="params">(FILE *pfin, FILE * pfout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoNULConvert</span><span class="params">(FILE *pfin, FILE * pfout, <span class="keyword">enum</span> STATE * state)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoCConvert</span><span class="params">(FILE *pfin, FILE * pfout, <span class="keyword">enum</span> STATE * state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoCPPConvert</span><span class="params">(FILE *pfin, FILE * pfout, <span class="keyword">enum</span> STATE * state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"标头.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CommentConvert</span><span class="params">(FILE *pfin, FILE * pfout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">enum</span> STATE state = NUL;<span class="comment">//初始化状态 为   无注释状态  </span></span><br><span class="line"><span class="keyword">while</span> (state != END)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (state)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> NUL:</span><br><span class="line">&#123;</span><br><span class="line"> DoNULConvert(pfin, pfout, &amp;state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> C:</span><br><span class="line">&#123;</span><br><span class="line">   DoCConvert(pfin, pfout, &amp;state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CPP:</span><br><span class="line">&#123;</span><br><span class="line"> DoCPPConvert(pfin, pfout, &amp;state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoNULConvert</span><span class="params">(FILE *pfin, FILE * pfout, <span class="keyword">enum</span> STATE * state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">start = fgetc(pfin);</span><br><span class="line"><span class="keyword">switch</span> (start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:  </span><br><span class="line">&#123;</span><br><span class="line"> next = fgetc(pfin);  </span><br><span class="line"> <span class="keyword">switch</span> (next)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">'*'</span>:<span class="comment">// 表示进入C语言注释状态  </span></span><br><span class="line"> &#123;</span><br><span class="line">  fputc(<span class="string">'/'</span>, pfout);  </span><br><span class="line">  fputc(<span class="string">'/'</span>, pfout);</span><br><span class="line">  *state = C;<span class="comment">//状态转换为  C注释状态  </span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">'/'</span>:<span class="comment">// 表示进入C++注释状态  </span></span><br><span class="line"> &#123;</span><br><span class="line">  fputc(start, pfout);  </span><br><span class="line">  fputc(next, pfout);</span><br><span class="line">  *state = CPP;  <span class="comment">//状态转换为  C++注释状态  </span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:   </span><br><span class="line"> &#123;</span><br><span class="line">fputc(start, pfout);  </span><br><span class="line">fputc(next, pfout);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EOF:</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> fputc(start, pfout);  </span><br><span class="line"> *state = END;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">//表示遇到的不是注释  ，状态不变   </span></span><br><span class="line">&#123;</span><br><span class="line">fputc(start, pfout); <span class="comment">//将读取的字符输出到文件  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c状态转换  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoCConvert</span><span class="params">(FILE *pfin, FILE * pfout, <span class="keyword">enum</span> STATE * state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> then = <span class="number">0</span>;</span><br><span class="line">start = fgetc(pfin);</span><br><span class="line"><span class="keyword">switch</span> (start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>:<span class="comment">//遇到'*'表示C语言注释状态   </span></span><br><span class="line">&#123;</span><br><span class="line"> next = fgetc(pfin);    </span><br><span class="line"> <span class="keyword">switch</span> (next)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line"> &#123;</span><br><span class="line">  then = fgetc(pfin);   </span><br><span class="line">  <span class="keyword">if</span> (then == <span class="string">'\n'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  fputc(then, pfout);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  fputc(<span class="string">'\n'</span>, pfout);</span><br><span class="line">  ungetc(then, pfin);</span><br><span class="line">  &#125;</span><br><span class="line">  *state = NUL;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> &#123;</span><br><span class="line">fputc(start, pfout);</span><br><span class="line">ungetc(next, pfin);   </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">&#123;</span><br><span class="line">fputc(start, pfout);</span><br><span class="line">fputc(<span class="string">'/'</span>, pfout);</span><br><span class="line">fputc(<span class="string">'/'</span>, pfout);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fputc(start, pfout);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c++状态转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoCPPConvert</span><span class="params">(FILE *pfin, FILE * pfout, <span class="keyword">enum</span> STATE * state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> then = <span class="number">0</span>;</span><br><span class="line">start = fgetc(pfin);  </span><br><span class="line"><span class="keyword">switch</span> (start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'\n'</span>:  </span><br><span class="line">&#123;</span><br><span class="line">  fputc(start, pfout);</span><br><span class="line">  *state = NUL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fputc(start, pfout);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"标头.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *pfin = <span class="literal">NULL</span>;</span><br><span class="line">FILE *pfout = <span class="literal">NULL</span>;</span><br><span class="line">pfin = fopen(<span class="string">"input.c"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span> (pfin == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"input file open:"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">pfout = fopen(<span class="string">"output.c"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="keyword">if</span> (pfout == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"output file open:"</span>);</span><br><span class="line">fclose(pfin);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">CommentConvert(pfin, pfout);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"注释转换成功\n"</span>);</span><br><span class="line">fclose(pfin);</span><br><span class="line">fclose(pfout);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>“链表倒数第K个节点”</title>
      <link href="/2018/06/03/%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2018/06/03/%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个结点。<br>思路：设置两个指针指向头节点分别为p，和ptr；<br>让p指针先走k-1次，然后让ptr跟着p指针一直遍历下去直到遍历完整个链表，这时ptr指针就指向倒数第k个节点了。<br>有些兴趣的同学可以仔细琢磨。很有意思。<br>附上我的代码：<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>//链表结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line"> &#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">init_list</span><span class="params">( <span class="keyword">int</span> n)</span><span class="comment">//初始化链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* head = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"链表数目个数有问题"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  head = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"请输入 "</span> &lt;&lt; n &lt;&lt; <span class="string">"个数据"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n-- &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Node* ptr = <span class="keyword">new</span> Node;</span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; ptr-&gt;data;</span><br><span class="line"> ptr-&gt;next = head;</span><br><span class="line"> head= ptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(Node *head)</span><span class="comment">//打印链表</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"这是一个空链表"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (head!=<span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; head-&gt;data &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line"> head = head-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">Node*  <span class="title">FindKthToTail</span><span class="params">(Node* head, <span class="keyword">int</span> k)</span><span class="comment">//链表节点</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == head&amp;&amp;k&lt;=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node* p = head, *ptr = head;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">  ptr = ptr-&gt;next;</span><br><span class="line">  p = p-&gt;next; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span> <span class="comment">//主函数</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="comment">// Node*ptr3= create_list();</span></span><br><span class="line"><span class="comment">// show(ptr3);</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你想要创建的链表节点个数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"> Node* ptr=init_list(n);</span><br><span class="line"> show(ptr);</span><br><span class="line"><span class="comment">//insert(ptr,4,5);</span></span><br><span class="line">    <span class="comment">//  show(ptr);</span></span><br><span class="line"><span class="comment">//Node* ptr2=resevertlist(ptr);</span></span><br><span class="line"><span class="comment">//show(ptr2);</span></span><br><span class="line"><span class="comment">// minus_point(ptr2, 2);</span></span><br><span class="line"><span class="comment">// show(ptr2);</span></span><br><span class="line">    <span class="comment">//Node*ptr3= minus_point(ptr2, 1);</span></span><br><span class="line"><span class="comment">// show(ptr3);</span></span><br><span class="line"><span class="comment">//int count= sort_list(ptr3);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line"> Node*ptr4 = FindKthToTail(ptr, <span class="number">3</span>);</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; ptr4-&gt;data;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="https://img-blog.csdn.net/20180603002311921?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二维数组的查找</title>
      <link href="/2018/06/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2018/06/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，因此从左下角开始查找，当要查找数字比左下角数字大时。右移要查找数字比左下角数字小时，上移。<br>例矩阵：<br>              1   2   3<br>              4   5   6<br>              7   8   9</p><p>具体算法如下：<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> row = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> col = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> arr[row][col] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入要查找的值"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; key;</span><br><span class="line"> <span class="comment">/* for (i = 0; i &lt; row; i++)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">  for (j = 0; j &lt; col; j++)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">  cin &gt;&gt; arr[row][col];</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">  <span class="keyword">for</span> (i = row - <span class="number">1</span>, j = <span class="number">0</span>;(i &gt;= <span class="number">0</span> )&amp;&amp; (j &lt; col);)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i][j] == key)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"该数存在!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[i][j]&gt;key)</span><br><span class="line">  &#123;</span><br><span class="line">  i--;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[i][j] &lt; key)</span><br><span class="line">  &#123;</span><br><span class="line">  j++;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"该数不存在"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="https://img-blog.csdn.net/2018060122062050?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="404"><br><img src="https://img-blog.csdn.net/20180601220700185?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="404"></p>]]></content>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>求二进制中1的个数</title>
      <link href="/2018/05/31/%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2018/05/31/%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>思路：如果一个数与1作与运算则可以发现该数最后一位数为1，否则为0.<br>按照此思路可以有以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入一个数"</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  count++;</span><br><span class="line">  &#125;</span><br><span class="line">  n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1的个数为"</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://img-blog.csdn.net/2018053122422894?/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/5a6L5L2T//I0JBQkFCMA==/" alt="404"><br>但是此方法存在缺陷如果输入的数为负数则会无限死循环</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>首先把n与1做与运算，判断n的最低位是不是为1。接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1….这样反复左移，每次能判断n的其中一位是不是1.这个解法中循环的次数等于整数二进制的位数，32位的整数需要循环32次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> key = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入一个数"</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (key)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &amp; key)</span><br><span class="line">  &#123;</span><br><span class="line">  count++;</span><br><span class="line">  &#125;</span><br><span class="line">  key &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1的个数为"</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>结果如上图：</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>思路：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0，那么一个整数的二进制表示中有<br>多少个1，就可以进行多少次这样的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入一个数"</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n)</span><br><span class="line"> &#123;</span><br><span class="line">  n = ((n - <span class="number">1</span>)&amp; n);</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1的个数为"</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180531225415780?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fill/I0JBQkFCMA==/dissolve/70" alt="404"></p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编程第一课</title>
      <link href="/2018/05/30/%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/"/>
      <url>/2018/05/30/%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/</url>
      <content type="html"><![CDATA[<h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>有一组数，对于其中任意两个数组，若前面一个大于后面一个数字，则这两个数字组成一个逆序对。请设计一个高效的算法，计算给定数组中的逆序对个数。</p><p>给定一个int数组A和它的大小n，请返回A中的逆序对个数。保证n小于等于5000。<br>测试样例：<br>[1,2,3,4,5,6,7,0],8<br>返回：7<br><a id="more"></a><br>答案如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">冒泡排序时做了多少次交换就有多少个逆序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AntiOrder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[j]&gt;A[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    swap(A[j],A[j+<span class="number">1</span>]);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h3><p>写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。<br>例如输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcba</span><br></pre></td></tr></table></figure></p><p>答案如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最简洁</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = str.size()<span class="number">-1</span>; i &gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：利用栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样的输出可以利用栈后进先出的结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ch_stack;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ch)</span><br><span class="line">    &#123;</span><br><span class="line">      ch_stack.push(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!ch_stack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ch_stack.top();</span><br><span class="line">        ch_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    reverse(str.begin(), str.end());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件操作</title>
      <link href="/2018/05/29/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/05/29/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>C++ 通过以下几个类支持文件的输入输出：<br>ofstream: 写操作（输出）的文件类 (由ostream引申而来)<br>ifstream: 读操作（输入）的文件类(由istream引申而来)<br>fstream: 可同时读写操作的文件类 (由iostream引申而来)<br><a id="more"></a></p><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>1.建立联系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofstream examplefile(&quot;example.txt&quot;);//声明类example并与创建的文件example.txt联系</span><br></pre></td></tr></table></figure></p><p>其中examplefile是ofstream的对象，对象（examplefile）第一个操作通常与一个真正的文件（example.txt）联系起来，改文件由一个流对象（该例子为examplefile）来表示（这些类的一个实例），对改对象进行的操作就是对该对象联系的文件操作。<br>2.判断文件是否打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">examplefile.is_open()//检查一个文件（examplefile对象所联系的文件）是否被顺利打开</span><br></pre></td></tr></table></figure><p>3.向文件中写入数据，并关闭文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">examplefile &lt;&lt; &quot;This is a line.\n&quot;;</span><br><span class="line">examplefile &lt;&lt; &quot;This is another line.\n&quot;;</span><br><span class="line">examplefile.close();</span><br></pre></td></tr></table></figure><p>ps:为防止流对象被销毁时还联系着打开的文件，析构函数一般将会自动调用关闭函数close</p><p>代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立一个文件并写入内容  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">ofstream <span class="title">examplefile</span><span class="params">(<span class="string">"example.txt"</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">if</span> (examplefile.is_open())  </span><br><span class="line">    &#123;  </span><br><span class="line">        examplefile &lt;&lt; <span class="string">"This is a line.\n"</span>;  </span><br><span class="line">        examplefile &lt;&lt; <span class="string">"This is another line.\n"</span>;  </span><br><span class="line">        examplefile.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://img-blog.csdn.net/20180529223841401?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180529223857452?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">examplefile.eof();//eof ，它是ifstream 从类 ios 中继承过来的，当到达文件末尾时返回true</span><br></pre></td></tr></table></figure><p>文件读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">examplefile.getline(buffer,100);</span><br><span class="line">//getline，读取一行字符，直到遇见换行符。getline具有返回值：成功：返回读取的字节数  失败：返回-1。</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对文件的读取示例  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">256</span>];                       <span class="comment">//定义一个数组，用来存放字符  </span></span><br><span class="line"><span class="function">ifstream <span class="title">examplefile</span><span class="params">(<span class="string">"example.txt"</span>)</span></span>;    <span class="comment">//声明一个对象与要读的文件联系  </span></span><br><span class="line"><span class="keyword">if</span> (! examplefile.is_open())            <span class="comment">//判断是否打开</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Error opening file"</span>; <span class="built_in">exit</span> (<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">while</span> (!examplefile.eof())  </span><br><span class="line">&#123;  </span><br><span class="line">examplefile.getline(buffer,<span class="number">100</span>);  </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;buffer&lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180529224253735?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="read和write函数"><a href="#read和write函数" class="headerlink" title="read和write函数"></a>read和write函数</h3><p>分别为istream和ostream的成员函数，前者被ifstream所继承，后者被ostream所继承。</p><p>代码示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * filename = <span class="string">"example.txt"</span>;  </span><br><span class="line">    <span class="keyword">char</span> * buffer;<span class="comment">//buffer是一块内存地址，用来存储或读取数据  </span></span><br><span class="line">    <span class="keyword">long</span> size;<span class="comment">//size 是一个整数值，表示要从缓存（buffer）中读出或写入的字符数  </span></span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(filename, ios::in|ios::binary|ios::ate)</span></span>;  </span><br><span class="line">    size = file.tellg();  </span><br><span class="line">    file.seekg(<span class="number">0</span>, ios::beg);  </span><br><span class="line">    buffer = <span class="keyword">new</span> <span class="keyword">char</span> [size];  </span><br><span class="line">    file.read(buffer, size);  </span><br><span class="line">    file.close();  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"the complete file is in a buffer"</span>;  </span><br><span class="line">    <span class="keyword">delete</span>[] buffer;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体read，write可参照CSDN专门有一篇博客专门介绍。</p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++输入流</title>
      <link href="/2018/05/28/C++%E8%BE%93%E5%85%A5%E6%B5%81/"/>
      <url>/2018/05/28/C++%E8%BE%93%E5%85%A5%E6%B5%81/</url>
      <content type="html"><![CDATA[<h3 id="CIN"><a href="#CIN" class="headerlink" title="CIN"></a>CIN</h3><p>cin是C++编程语言中的标准输入流对象，即istream类的对象。cin主要用于从标准输入读取数据，这里的标准输入，指的是终端的键盘。此外，cout是流的对象，即ostream类的对象，cerr是标准错误输出流的对象，也是ostream 类的对象。这里的标准输出指的是终端键盘，标准错误输出指的是终端的屏幕。<br>在理解cin功能时，不得不提标准输入缓冲区。当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键(\r)会被转换为一个换行符\n，这个换行符\n也会被存储在cin的缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了123456这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。<br>cin读取数据也是从缓冲区中获取数据，缓冲区为空时，cin的成员函数会阻塞等待数据的到来，一旦缓冲区中有数据，就触发cin的成员函数去读取数据。</p><p>使用cin从标准输入读取数据时，通常用到的方法有cin&gt;&gt;，cin.get，cin.getline<br>cin&gt;&gt;&lt;变量1&gt;[&gt;&gt;&lt;变量2&gt;&gt;&gt;…&gt;&gt;&lt;变量n&gt;];</p><p>其中“&gt;&gt;”称为提取运算符，用于读取用户输入的数据，赋给变量。在cin之后“&gt;&gt;&lt;变量&gt;”可重复多次。输入多个数据时数据之间要用空格、TAB、或者ENTER键隔开，系统会自动跳过空格和回车符，将输入的数据赋给各提取运算符的变量。回车符有两个作用一个是分隔符另一个是刷新缓冲区，并通知cin已经输入一行数据。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">    float c;</span><br><span class="line">    string</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但如果提取运算符的&lt;&lt;后面的变量是字符型，则必须输入字符。单当要获取输入的空格或ENTER键，直接用”&lt;&lt;”不能实现<br>，必须借助于cin.get函数,其一般形式为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cin.get([&lt;字符型变量])</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char a;</span><br><span class="line">    char b;</span><br><span class="line">    a=cin.get();</span><br><span class="line">    cin.get(b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输入一个空格,一个Enter:<br><img src="https://img-blog.csdn.net/20180513224550670?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>注意：<br>（1）从结果可以看出，cin.get()从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取，就出现了如上情况，将换行符读入变量b，输出时换行两次，一次是变量b，一次是endl。<br>（2）cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c)</p><p>gets读取一行<br>gets是C中的库函数，在&lt; stdio.h&gt;申明，从标准输入设备读字符串，可以无限读取，不会判断上限，以回车结束或者EOF时停止读取，所以程序员应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。</p><p>函数原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char *gets( char *buffer );</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char array[20]=&#123;NULL&#125;;</span><br><span class="line">    gets(array);</span><br><span class="line">    cout&lt;&lt;array&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于此函数是C的库函数,所以不建议使用,在C++中使用会报警告.</p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模拟实现atoi函数</title>
      <link href="/2018/05/27/atoi%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/05/27/atoi%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="atoi函数"><a href="#atoi函数" class="headerlink" title="atoi函数"></a>atoi函数</h3><p> atoi函数是把字符串转换成整型数的一个函数，应用在计算机程序和办公软件中。int atoi(const char *nptr) 函数会扫描参数 nptr字符串，跳过前面的空白字符（例如空格，tab缩进）等，可以通过isspace( )函数来检测），直到遇上数字或正负符号才开始做转换，而在遇到非数字或字符串结束符(‘\0’)才结束转换，并将结果返回。如果 nptr不能转换成 int 或者 nptr为空字符串，那么将返回 0 。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"12345"</span>;</span><br><span class="line">    n = atoi(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n=%d\n"</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 输出n=123456<br><a id="more"></a></p><h3 id="模拟实现atoi"><a href="#模拟实现atoi" class="headerlink" title="模拟实现atoi"></a>模拟实现atoi</h3><p> 代码实现<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> flag = <span class="number">1</span>;  <span class="comment">//判断符号位  </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == str)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"str is NULL"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (*str == <span class="string">' '</span>)  <span class="comment">//空格  </span></span><br><span class="line">  &#123;</span><br><span class="line">  str++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (*str == <span class="string">'-'</span>)    <span class="comment">//符号位  </span></span><br><span class="line">  &#123;</span><br><span class="line">  flag = <span class="number">-1</span>;</span><br><span class="line">  str++;    <span class="comment">//后移3移位  </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((*str &gt;= <span class="string">'0'</span>) &amp;&amp; (*str &lt;= <span class="string">'9'</span>))<span class="comment">//转化  </span></span><br><span class="line">  &#123;</span><br><span class="line">  number = number * <span class="number">10</span> + *str - <span class="string">'0'</span>;</span><br><span class="line">  str++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag*number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* str = <span class="string">"-123456"</span>;</span><br><span class="line">  <span class="keyword">int</span> tmp = StrToInt(str);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; tmp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p> <img src="https://img-blog.csdn.net/20180527215512598?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>指针数组和数组指针的区别</title>
      <link href="/2018/05/26/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88-md/"/>
      <url>/2018/05/26/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88-md/</url>
      <content type="html"><![CDATA[<p>昨天聊了常量指针和指针常量的区别，今天继续一个比较容易混淆的话题，指针数组和数组指针=.=!</p><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>含义：指向数组的的指针<br>(1)数组在内存中的表示<br>创建一个数组就是在内存里面开辟一块连续的空间，比如int a[4];就是在内存里面开辟了一个大小为4*sizeof(int)字节的内存空间。而二维数组是特殊的一维数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//这是一个2*2的二维数组  </span></span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">2</span>];<span class="comment">//数组指针  </span></span><br><span class="line">    p=a;<span class="comment">//令p指向数组a  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里p是一个指向数组的指针。<br><a id="more"></a></p><h4 id="让我们理解数组名和数组指针变量：a-a-0-a-1-p-a-1-a-0-1-p-1这些分别代表什么意思呢？"><a href="#让我们理解数组名和数组指针变量：a-a-0-a-1-p-a-1-a-0-1-p-1这些分别代表什么意思呢？" class="headerlink" title="让我们理解数组名和数组指针变量：a,a[0],a[1],p,a+1,a[0]+1,p+1这些分别代表什么意思呢？"></a>让我们理解数组名和数组指针变量：a,a[0],a[1],p,a+1,a[0]+1,p+1这些分别代表什么意思呢？</h4><p>答案：<br>a是一个数组名，类型是指向一维数组的指针，不是变量，a的值是指针常量，即不能有a++或者a=p这些操作。a指向这块连续空间的首地址，值是&amp;a[0][0]。</p><p>a[0]是一维数组名，类型是指向整型的指针，值是&amp;a[0][0]，这个值是一个常量。</p><p>a[1]是一维数组名，类型是指向整型的指针，值是&amp;a[1][0]，这个值是一个常量。</p><p>p是一个数组指针变量，指向一维数组的指针变量，值是&amp;a[0][0]。可以执行p++;p=a等操作。<br>a+1表示指向下一行元素，也可以理解为指向下一个一维数组。</p><p>(a+1)是取出第一行的首地址。</p><p>a[0]+1是指向第0行第1个元素，也可以理解为指向一维数组a[0]的第一个元素。</p><p>p+1同a+1</p><p>(p+1)同_(a+1)</p><p>虽然a跟a[0]值是一样，但类型不一样，表示的意义不一样。通过分析就不难理解为什么_(*(a+i)+j)和a[i][j]等效了。</p><h4 id="数组名与数组指针变量的区别"><a href="#数组名与数组指针变量的区别" class="headerlink" title="数组名与数组指针变量的区别"></a>数组名与数组指针变量的区别</h4><p>区别：数组名是指针，类型是指向元素类型的指针，但值是指针常量，声明数组时编译器会为声明所指定的元素数量保留内存空间。数组指针是指向数组的指针，声明指针变量时编译器只为指针本身保留内存空间。</p><h3 id="指针数组（存放指针的数组）"><a href="#指针数组（存放指针的数组）" class="headerlink" title="指针数组（存放指针的数组）"></a>指针数组（存放指针的数组）</h3><p>指针数组：一个存放int类型的数组称为整型数组，那么存放指针的数组就叫指针数组。</p><pre><code class="c++"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span><span class="function"></span>{      <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;<span class="comment">//p先跟[]结合，然后再跟*结合  </span>    <span class="keyword">int</span> *p[<span class="number">2</span>];<span class="comment">//指针数组,存放指针的数组  </span>    p[<span class="number">0</span>]=&amp;i;      p[<span class="number">1</span>]=&amp;j;      <span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="keyword">sizeof</span>(p));      }</code></pre><p>此例数组p就两个元素，p[0]是指向i的指针，p[1]是指向j的指针。这两个指针都是int型指针，所以p是存放int型指针的数组。sizeof(p)返回数组占用的总空间，所以程序输出是8</p><h4 id="常用举例"><a href="#常用举例" class="headerlink" title="常用举例"></a>常用举例</h4><p>字符排序，可以用指针数组指向不字符串，排序时改变指针指向就避免了大量文本数据的移动。</p>]]></content>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快速排序</title>
      <link href="/2018/05/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/05/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h3><p>是对冒泡排序的一种改进。快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>官方解释：设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。<br>一趟快速排序的算法是：<br>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。<br>尼玛，这都是啥，想必没有见过这个算法的小可爱，对这个官方解释可能是一脸懵逼。所以我就把这个算法通俗的讲一讲。<br>首先要对一堆数字排序我们必须找到一个基准数。而这个基准数可以是这一堆数字中的任意一个，我们定义两个移动的变量从数组的两头向中间检索。从右往左走的变量找到一个小于基准数后停止，从左往右的的变量找到一个大余基准数后停止然后这两个数就交换一下，直到两个变量相遇后就遍历了整个数组，这时候数字的左边都小于基准数，右边大于基准数。然后把数组分成两部分在执行遍历交换后，就完成排序了。<br><a id="more"></a></p><p><img src="https://img-blog.csdn.net/20180515130753470?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图片加载失败"></p><p>具体实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, t, temp;</span><br><span class="line">  <span class="keyword">if</span> (left&gt;right)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  temp = a[left]; <span class="comment">//temp中存的就是基准数</span></span><br><span class="line">  i = left;</span><br><span class="line">  j = right;</span><br><span class="line">  <span class="keyword">while</span> (i != j)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//顺序很重要，要先从右边开始找</span></span><br><span class="line">  <span class="keyword">while</span> (a[j] &gt;= temp &amp;&amp; i&lt;j)</span><br><span class="line">  j--;</span><br><span class="line">  <span class="comment">//再找右边的</span></span><br><span class="line">  <span class="keyword">while</span> (a[i] &lt;= temp &amp;&amp; i&lt;j)</span><br><span class="line">  i++;</span><br><span class="line">  <span class="comment">//交换两个数在数组中的位置</span></span><br><span class="line">  <span class="keyword">if</span> (i&lt;j)</span><br><span class="line">  &#123;</span><br><span class="line">  t = a[i];</span><br><span class="line">  a[i] = a[j];</span><br><span class="line">  a[j] = t;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最终将基准数归位</span></span><br><span class="line">  a[left] = a[i];</span><br><span class="line">  a[i] = temp;</span><br><span class="line">  quicksort(a, left, i - <span class="number">1</span>);<span class="comment">//继续处理左边的，这里是一个递归的过程</span></span><br><span class="line">  quicksort(a, i + <span class="number">1</span>, right);<span class="comment">//继续处理右边的 ，这里是一个递归的过程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span> &#125;;</span><br><span class="line">  quicksort(arr, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180515134156903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这图片加载失败"></p><p>快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>指针常量和常量指针的区别</title>
      <link href="/2018/05/24/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/24/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>在面试中我们经常会被面试官问到什么是常量指针，什么又是指针常量。可能第一次被问到都会有些懵逼（大神略过）。我今天就来讲一讲这二者的区别。<br>下面开始正题。。。。</p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>指针常量：顾名思义它就是一个常量，但是是指针修饰的。<br>格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p <span class="comment">//指针常量</span></span><br></pre></td></tr></table></figure><p>在这个例子下定义以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a，b；</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p=&amp;a <span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作成功</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作错误</span></span><br></pre></td></tr></table></figure><p>因为声明了指针常量，说明指针变量不允许修改。如同次指针指向一个地址该地址不能被修改，但是该地址里的内容可以被修改<br><a id="more"></a></p><h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h2><p>常量指针：如果在定义指针变量的时候，数据类型前用const修饰，被定义的指针变量就是指向常量的指针变量，指向常量的指针变量称为常量指针，格式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a; <span class="comment">//常量指针</span></span><br></pre></td></tr></table></figure><p>在这个例子下定义以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a，b；</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;a <span class="comment">//常量指针</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作错误</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作成功</span></span><br></pre></td></tr></table></figure><p>因为常量指针本质是指针，并且这个指针是一个指向常量的指针，指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变。</p><h2 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h2><p>指向常量的指针常量该怎么写？<br>答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> b = &amp;a;<span class="comment">//指向常量的指针常量</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>函数源码</title>
      <link href="/2018/05/23/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2-md/"/>
      <url>/2018/05/23/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2-md/</url>
      <content type="html"><![CDATA[<h3 id="strcpy源码："><a href="#strcpy源码：" class="headerlink" title="strcpy源码："></a>strcpy源码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *strDes, <span class="keyword">const</span> <span class="keyword">char</span> *strSrc)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        assert((strDes != <span class="literal">NULL</span>) &amp;&amp; (strSrc != <span class="literal">NULL</span>));   </span><br><span class="line">        <span class="keyword">char</span> *address = strDes;   </span><br><span class="line">        <span class="keyword">while</span> ((*strDes ++ = *strSrc ++) != <span class="string">'\0'</span>)   </span><br><span class="line">            <span class="literal">NULL</span>;   </span><br><span class="line">        <span class="keyword">return</span> address;   </span><br><span class="line"></span><br><span class="line">注意：<span class="built_in">strcpy</span>只是复制字符串，但不限制复制的数量。很容易造成缓冲溢出，也就是说，不过dest有没有足够的空间来容纳src的字符串，它都会把src指向的字符串全部复制到从dest开始的内存</span><br><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure><h3 id="strcmp源码："><a href="#strcmp源码：" class="headerlink" title="strcmp源码："></a>strcmp源码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    assert(s != <span class="literal">NULL</span> &amp;&amp; t != <span class="literal">NULL</span>);   </span><br><span class="line">    <span class="keyword">while</span> (*s &amp;&amp; *t &amp;&amp; *s == *t)   </span><br><span class="line">    &#123;   </span><br><span class="line">        ++ s;   </span><br><span class="line">        ++ t;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> (*s - *t);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strcat源码："><a href="#strcat源码：" class="headerlink" title="strcat源码："></a>strcat源码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *strDes, <span class="keyword">const</span> <span class="keyword">char</span> *strSrc)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"></span><br><span class="line"> assert((strDes != <span class="literal">NULL</span>) &amp;&amp; (strSrc != <span class="literal">NULL</span>));   </span><br><span class="line">    <span class="keyword">char</span> *address = strDes;   </span><br><span class="line">    <span class="keyword">while</span> (*strDes != <span class="string">'\0'</span>)   </span><br><span class="line">        ++ strDes;   </span><br><span class="line">    <span class="keyword">while</span> ((*strDes ++ = *strSrc ++) != <span class="string">'\0'</span>)   </span><br><span class="line">        <span class="literal">NULL</span>;   </span><br><span class="line">    <span class="keyword">return</span> address;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：1.不能向形参传递指向字符串常量的指针（本题中dst和src都是指向串常量的指针，字符串常量存储在常量区不能被修改  2.传递的字符数组前一个实参的所分配的内存空间必须足够大</p><h3 id="strlen源码："><a href="#strlen源码：" class="headerlink" title="strlen源码："></a>strlen源码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    assert(str != <span class="literal">NULL</span>);   </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">while</span> (*str ++ != <span class="string">'\0'</span>)   </span><br><span class="line">        ++ len;   </span><br><span class="line">    <span class="keyword">return</span> len;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strstr源码："><a href="#strstr源码：" class="headerlink" title="strstr源码："></a>strstr源码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strSrc, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    assert(strSrc != <span class="literal">NULL</span> &amp;&amp; str != <span class="literal">NULL</span>);   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s = strSrc;   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *t = str;   </span><br><span class="line">    <span class="keyword">for</span> (; *t != <span class="string">'\0'</span>; ++ strSrc)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">for</span> (s = strSrc, t = str; *t != <span class="string">'\0'</span> &amp;&amp; *s == *t; ++s, ++t)   </span><br><span class="line">            <span class="literal">NULL</span>;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*t == <span class="string">'\0'</span>)   </span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">char</span> *) strSrc;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strchr源码："><a href="#strchr源码：" class="headerlink" title="strchr源码："></a>strchr源码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * __<span class="function">cdecl <span class="title">strchr</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                      constchar * <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> ch</span></span></span><br><span class="line"><span class="function"><span class="params">                       )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">while</span> (*<span class="built_in">string</span> &amp;&amp; *<span class="built_in">string</span> != (<span class="keyword">char</span>)ch)</span><br><span class="line">        <span class="built_in">string</span>++;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (*<span class="built_in">string</span> == (<span class="keyword">char</span>)ch)</span><br><span class="line">       <span class="keyword">return</span>((<span class="keyword">char</span> *)<span class="built_in">string</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断言：assert（表达式）如果表达式的值为假，整个程序将退出，并输出一条错误信息。如果表达式的值为真则继续执行后面的语句，使用这个宏前需要包含头文件assert.h<br>结语：函数就向一个黑盒一样，调用它的人给他输入（调用它本身就是一种输入），然后等待一个理想中的输出或者是相应的操作。调用者是希望我们的这个函数能够非常健壮的让他们利用，那么为了使我们的函数拥有一定的鲁棒性。</p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 程序源码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2018/05/23/hello-world/"/>
      <url>/2018/05/23/hello-world/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="测试博客"><a href="#测试博客" class="headerlink" title="测试博客"></a>测试博客</h2><h3 id="这是一篇测试博客"><a href="#这是一篇测试博客" class="headerlink" title="这是一篇测试博客"></a>这是一篇测试博客</h3><!--more--><p>第一次使用github+hexo搭建属于自己的博客.<br>日经过不懈的努力终于搭建好了，我非常开心！！</p><pre><code>2018.5.23   邓铭</code></pre>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
