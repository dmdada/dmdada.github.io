<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2018%2F06%2F24%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[基数排序]]></title>
    <url>%2F2018%2F06%2F23%2F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基数排序名词解释：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。历史渊源：基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机(Tabulation Machine)上的贡献。它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。排序步骤：第一步以LSD为例，假设原来有一串数值如下所示：73, 22, 93, 43, 55, 14, 28, 65, 39, 81首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：01 812 223 73 93 434 145 55 65678 289 39第二步接下来将这些桶子中的数值重新串接起来，成为以下的数列：81, 22, 73, 93, 43, 14, 55, 65, 28, 39接着再进行一次分配，这次是根据十位数来分配：01 142 22 283 394 435 556 657 738 819 93第三步接下来将这些桶子中的数值重新串接起来，成为以下的数列：14, 22, 28, 39, 43, 55, 65, 73, 81, 93这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。 图解： 算法分析时间效率 ：设待排序列为n个记录，d个关键码，关键码的取值范围为radix，则进行链式基数排序的时间复杂度为O(d(n+radix))，其中，一趟分配时间复杂度为O(n)，一趟收集时间复杂度为O(radix)，共进行d趟分配和收集。空间效率：需要2*radix个指向队列的辅助空间，以及用于静态链表的n个指针故为O(2*radix) 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int Maxbit(int arr[], int size)&#123; int p = 1; int count = 0; for (int i = 0; i &lt; size; i++) &#123; while (arr[i]&gt;p) &#123; p *= 10; count++; &#125; &#125; return count;&#125;void bucketsort(int arr[], int num)&#123; int max = Maxbit(arr, num); int i = 0; int j = 0; int k = 0; int index = 1; int *tmp = new int[num]; int *count = new int[10]; for (i = 0; i &lt; max; i++) &#123; for (j = 0;j &lt; 10; j++) &#123; count[j] = 0; &#125; for (j = 0; j &lt; num; j++) &#123; k = (arr[j] / index) % 10; count[k]++; &#125; for (j = 1; j &lt; 10; j++) &#123; count[j] = count[j - 1] + count[j]; &#125; for (j = num - 1; j &gt;= 0; j--) &#123; k = (arr[j] / index) % 10; tmp[count[k] - 1] = arr[j]; count[k]--; &#125; index *= 10; for (j = 0; j &lt; num; j++) &#123; arr[j] = tmp[j]; &#125; &#125; delete[] tmp; delete[] count;&#125;int main()&#123; int array[] = &#123;1,3,6,2,5,8,7,9,4,6,12,30,300&#125;; const int num = sizeof(array) / sizeof(array[0]); bucketsort(array,num); for (int i = 0; i &lt;sizeof(array) / sizeof(array[0]); i++) &#123; cout &lt;&lt; array[i] &lt;&lt; " "; &#125; return 0;&#125; 结果]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2018%2F06%2F21%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序（Mergesort)名词解释 ：归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 算法原理归并排序采用分而治之思想将数组内容划分成许多个单位，使每个单位内序列为有序再合并各个有序的序列。图解如下： 算法描述:时间复杂度:O(n log n)空间复杂度:O（n)算法稳定性：稳定 算法实现步骤：第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置。第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾。 算法实现实现归并排序首先要实现两个有序数组的合并：算法如下: 12345678910111213141516171819void MemeryArray(int a[], int n, int b[], int m, int c[]) &#123; int i, j, k; i = j = k = 0; while (i &lt; n &amp;&amp; j &lt; m) &#123; if (a[i] &lt; b[j]) c[k++] = a[i++]; else c[k++] = b[j++]; &#125; while (i &lt; n) c[k++] = a[i++]; while (j &lt; m) c[k++] = b[j++]; &#125; 有了合并以后就完成了算法的主体，全部实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void mergetarr(int arr[], int left, int right, int tmp[])//合并算法&#123; int i, j, k; i = left; k = 0; int mid = (left + right) / 2; j = mid+1; while (i&lt;=mid&amp;&amp;j&lt;=right ) &#123; if (arr[i]&lt;=arr[j]) &#123; tmp[k++]=arr[i++]; &#125; else &#123; tmp[k++] = arr[j++]; &#125; &#125; while (i&lt;=mid) &#123; tmp[k++] = arr[i++]; &#125; while (j&lt;=right) &#123; tmp[k++] = arr[j++]; &#125; for (i = 0; i &lt; k; i++) arr[left + i] = tmp[i];&#125;void mergetsort(int arr[], int left, int right,int tmp[])//归并排序&#123; if (left&lt;right ) &#123; int mid = (right + left) / 2; mergetsort(arr,left,mid,tmp);//左边归并 mergetsort(arr, mid+1, right,tmp);//右边归并 mergetarr(arr, left, right, tmp);//合并左右 &#125;&#125;int main()&#123; int array[] = &#123;1,3,6,2,5,8,7,9,4,6,12,16,13,25,14,26,25,28,29,31,89,56,14,25,58,78,36,14,17,22&#125;; const int num = sizeof(array) / sizeof(array[0]); int *p = new int[num]; mergetsort(array, 0, sizeof(array) / sizeof(array[0])-1,p); for (int i = 0; i &lt;sizeof(array) / sizeof(array[0]); i++) &#123; cout &lt;&lt; array[i] &lt;&lt; " "; &#125; delete[] p; return 0;&#125; 结果：]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法的稳定性]]></title>
    <url>%2F2018%2F06%2F21%2F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%2F</url>
    <content type="text"><![CDATA[排序算法的稳定性名词解释：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。 判断方法对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。举例：123456789101112131415161718192021void BubbleSort(int *arr, int n)&#123; int i, j, flag = 1; int temp; for (i = 1; i &lt; n &amp;&amp; flag == 1; i++) &#123; flag = 0; for (j = 0; j &lt; n - i; j++) &#123; if (arr[j] &gt;arr[j + 1]) &#123; flag = 1; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125;&#125;/*此算法本来是稳定的但是如果将判断条件改为a[j].key &gt;=a[j+1].key，则会影响原来数值相同数据的的位置，就会变成不稳定的排序方法*/ 常见算法的稳定性分析堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。 其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就 是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。 八大排序分析：(1)冒泡排序冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无 聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。(2)选择排序选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。(3)插入排序插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。(4)快速排序快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。(5)归并排序归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。(6)基数排序基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。(7)希尔排序(shell)希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。(8)堆排序我们知道堆的结构是节点i的孩子为2i和2i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。 稳定性的意义不需要用到稳定性： 如果只是简单的进行数字的排序，那么稳定性将毫无意义，如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧将毫无意义，如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧将毫无意义。 需要用到稳定性： 排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法，例如要排序的内容是一组原本按照价格高低排序的货物，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的货物依旧保持着价格高低的排序，只有销量不同的才会重新排序，因此如果需求不需要保持初始的排序意义，那么使用稳定性算法和不稳定算法是一样的。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[希尔排序（Shell’s Sort)名词解释：希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 希尔排序是基于插入排序的以下两点性质而提出改进方法的：1.插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。2.但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 算法思想教科书表达：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2(小于d1）重复上述的分组和排序，直至所取的增量 =1( &lt; …&lt; &lt; d2 &lt; d1)，即所有记录放在同一组中进行直接插入排序为止。简单来说：一个书架放着一排书，现在从第一本书起每数X本书，就在那本书上贴红色贴纸，贴完红色贴纸后，再次从第二本书起每数X本书就贴上蓝色贴纸（跟之前颜色不同即可），重复贴纸过程，直到所有书都贴满贴纸。接着对有相同颜色贴纸的书做插入排序。然后撕掉所有贴纸后重新对书进行贴纸，这次则每数Y本书就贴纸（Y &lt; X）,所有书贴满后再进行插入排序。重复贴纸排序、贴纸排序这个过程，直到最后每数1本书就贴纸（也就是每本书都贴同样颜色贴纸），再插入排序为止。话不多说，看图 算法分析稳定性：由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。时间复杂度：O(n^2)空间复杂度：O(1) 常见排序算法一般按平均时间复杂度分为两类：O(n^2)：冒泡排序、选择排序、插入排序O(nlogn)：归并排序、快速排序、堆排序1w和10w数据效率如下： 算法效率正如我们所知道的希尔排序的增量序列是影响希尔排序效率的最关键因素，至今为止还没有一个最完美的增量序列公式。可究竟应该选取什么样的增量才是最好，目前还是一个数学难题。看如下两个增量序列：n/2、n/4、n/8…11、3、7…2^k-1第一个序列称为希尔增量序列，使用希尔增量时，希尔排序在最坏情况下的时间复杂度为O(n*n)。第二个序列称为Hibbard增量序列，使用Hibbard增量时，希尔排序在最坏情况下的时间复杂度为O(n^3/2)。 10w数据对比如下图： 算法实现12345678910111213141516171819202122232425262728293031323334353637383940void shellsort(int* arr, int size)//希尔排序&#123; if(size&lt;=0||arr==NULL) &#123; return; &#125; int div = 0; int i, j, k = 0; for (div = size / 2; div &gt;= 1; div /= 2)//定义增量 &#123; for (i = 0; i &lt; div; i++)//分成div组 &#123; for (j = i; j &lt; size; j += div)//对数据插入排序 &#123; for (k = i; k &lt; size - div; k += div)&#123; if (arr[j] &lt; arr[k]) &#123; swap(arr[j], arr[k]);//交换数据的值 &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; int array[] = &#123;1,3,6,2,5,8,7,9,4,6,12,16,13,25,14,26,25,28,29,31,22&#125;; shellsort(array, sizeof(array)/sizeof(array[0])); /*for (auto it: array) &#123; cout &lt;&lt; it; &#125;*/ for (int i = 0; i &lt;sizeof(array) / sizeof(array[0]); i++) &#123; cout &lt;&lt; array[i] &lt;&lt; " "; &#125; return 0;&#125; 截图]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2018%2F06%2F18%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序（ Heap Sort )堆排序要用到堆，那什么是堆呢？可以参考我的一博客什么是堆？ 名词解释：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd）和威廉姆斯(J．Williams）在1964年共同发明了著名的堆排序算法。 算法分析堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用Heapify实现的。平均性能：O(N*logN) 其他性能:由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。堆排序是就地排序，辅助空间为O(1)。堆排序是不稳定的排序方法（当数组中有相等元素时，堆排序算法对这些元素的处理方法不止一种）。（排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前 和排序后他们的相对位置不发生变化）。 一般步骤1.将无序序列构建成一个堆，根据升序降序需求选择大顶堆（升序）或小顶堆（降序）。2.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端。3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 将堆化为数组： 具体实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041void adjust(int arr[], int len, int index)//调整&#123; int left = 2 * index + 1; int right = 2 * index + 2; int maxIdx = index; if (left&lt;len &amp;&amp; arr[left] &gt; arr[maxIdx]) maxIdx = left; if (right&lt;len &amp;&amp; arr[right] &gt; arr[maxIdx]) maxIdx = right; // maxIdx是3个数中最大数的下标 if (maxIdx != index) // 如果maxidx被更新 &#123; swap(arr[maxIdx], arr[index]);//交换 adjust(arr, len, maxIdx); // 递归调整其他不满足堆性质的部分 &#125;&#125;void heapSort(int arr[], int size)//堆排序&#123; for (int i = size / 2 - 1; i &gt;= 0; i--) // 对每一个非叶结点进行堆调整(从最后一个非叶结点开始) &#123; adjust(arr, size, i); &#125; for (int i = size - 1; i &gt;= 1; i--) &#123; swap(arr[0], arr[i]); // 将当前最大的放置到数组末尾 adjust(arr, i, 0); // 将未完成排序的部分继续进行堆排序 &#125;&#125;int main()&#123; int array[8] = &#123; 5, 1, 6, 3, 8, 4, 7, 10 &#125;; heapSort(array, 8); /*for (auto it: array) &#123; cout &lt;&lt; it; &#125;*/ for (int i = 0; i &lt;sizeof(array)/sizeof(array[0]); i++) &#123; cout &lt;&lt; array[i] &lt;&lt;" "; &#125; return 0;&#125; 结果]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是堆]]></title>
    <url>%2F2018%2F06%2F17%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%2F</url>
    <content type="text"><![CDATA[堆(heap)堆是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆的性质：1.堆中某个节点的值总是不大于或不小于其父节点的值。2.堆总是一棵完全二叉树。 堆的分类将根节点最大的堆叫做最大堆或大顶堆，根节点最小的堆叫做最小堆或小顶堆。常见的堆有二叉堆、斐波那契堆等。堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)若将和此次序列对应的一维数组（即以一维数组作此序列的存储结构）看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。由此，若序列{k1,k2,…,kn}是堆，则堆顶元素（或完全二叉树的根）必为序列中n个元素的最小值（或最大值）。每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：大堆：小堆： 堆的操作build:建立一个空堆；insert:向堆中插入一个新元素；update：将新元素提升使其符合堆的性质；get：获取当前堆顶元素的值；delete：删除堆顶元素；heapify：使删除堆顶元素的堆再次成为堆。某些堆实现还支持其他的一些操作，如斐波那契堆支持检查一个堆中是否存在某个元素。 建堆效率n个结点的堆，高度d =log2n。根为第0层，则第i层结点个数为2i，考虑一个元素在堆中向下移动的距离。大约一半的结点深度为d-1，不移动（叶）。四分之一的结点深度为d-2，而它们至多能向下移动一层。树中每向上一层，结点的数目为前一层的一半，而子树高度加一。这种算法时间代价为Ο（n)由于堆有log n层深，插入结点、删除普通元素和删除最小元素的平均时间代价和时间复杂度都是Ο（log n）。 关于堆的操作实现在程序中，堆用于动态分配和释放程序所使用的对象。在以下情况中调用堆操作：1.事先不知道程序所需对象的数量和大小。2.对象太大，不适合使用堆栈分配器。堆使用运行期间分配给代码和堆栈以外的部分内存。传统上，操作系统和运行时库随附了堆实现。当进程开始时，操作系统创建称为进程堆的默认堆。如果没有使用其他堆，则使用进程堆分配块。语言运行时库也可在一个进程内创建单独的堆。（例如，C 运行时库创建自己的堆。）除这些专用堆外，应用程序或许多加载的动态链接库 (DLL) 之一也可以创建并使用单独的堆。Win32 提供了一组丰富的 API用于创建和使用专用堆。有关堆函数的优秀教程，请参阅 MSDN 平台 SDK 节点。当应用程序或 DLL 创建专用堆时，这些堆驻留于进程空间中并且在进程范围内是可访问的。某一给定堆分配的任何数据应为同一堆所释放。（从一个堆分配并释放给另一个堆没有意义。）在所有虚拟内存系统中，堆位于操作系统的虚拟内存管理器之上。语言运行时堆也驻留在虚拟内存之上。某些情况下，这些堆在操作系统堆的上层，但语言运行时堆通过分配大的块来执行自己的内存管理。绕开操作系统堆来使用虚拟内存函数可使堆更好地分配和使用块。典型的堆实现由前端分配器和后端分配器组成。前端分配器维护固定大小块的自由列表。当堆收到分配调用后，它尝试从前端列表中查找自由块。如果此操作失败，则堆将被迫从后端（保留和提交虚拟内存）分配一个大块来满足请求。通常的实现具有每个块分配的开销，这花费了执行周期，也减少了可用存储区。单个全局锁可防止多线程同时使用堆。此锁主要用于保护堆数据结构不受多线程的任意访问。当堆操作过于频繁时，此锁会对性能造成负面影响。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#pragma oncetemplate&lt;class T&gt;class JBMinHeap&#123;private: //申请堆空间 T *_minHeap = NULL; int _index,_maxSize;public: JBMinHeap(int maxSize) &#123; _maxSize = maxSize; _minHeap = new T[_maxSize]; _index = -1; &#125; JBMinHeap(JBMinHeap &amp;h) &#123; _index = h._index; _maxSize = h._maxSize; _minHeap = new T[_maxSize]; for (int i = 0;i&lt;_maxSize) &#123; *_minHeap[i] = *h._minHeap[i]; &#125; &#125; ~JBMinHeap() &#123; delete[]_minHeap; &#125; //获取整个最小堆的头部指针 T * getMinHeap() &#123; return _minHeap; &#125; //判断堆是不是空的 bool isEmpty() &#123; return _index == -1; &#125; bool add(T x) &#123; if (isFull()) &#123; return false; &#125; _index++; _minHeap[_index] = x; return true; &#125; bool isFull() &#123; return _index == _maxSize; &#125; //堆进行向下调整 void adjustDown(int index); //队进行向上调整 void adjustUp(int index); //建堆运算 void createMinHeap() &#123; if (isEmpty()) &#123; return; &#125; for (int i = (_index-1)/2;i &gt;-1;i--) &#123;//直接从倒数第二层 逐层向下调整 adjustDown(i); &#125; &#125;&#125;;template&lt;class T&gt;void JBMinHeap&lt;T&gt;::adjustDown(int index) &#123; if (isEmpty()) &#123; return; &#125; while (index&lt;_index) &#123; T temp = _minHeap[index];//将当前索引的位置的值保存下来 int oneC = 2 * index + 1;//获取到两个孩子的位置 int twoC = 2 * index + 2; if (oneC == _index) &#123;//若第一个孩子是整个堆最后一个位置 则直接执行交换操作并结束执行 _minHeap[index] = _minHeap[oneC]; _minHeap[oneC] = temp; return; &#125; if (twoC &gt;_index) &#123;//如果第二个孩子的索引位置越界 结束执行 return; &#125; if (_minHeap[oneC] &lt;= _minHeap[twoC]) &#123;//正常情况的数据交互执行 if (temp &gt; _minHeap[oneC]) &#123; _minHeap[index] = _minHeap[oneC]; _minHeap[oneC] = temp; index = oneC; &#125; else &#123;//如果该处索引值已经是比两个孩子小 则结束循环 index = _index; &#125; &#125; else &#123; if (temp &gt; _minHeap[twoC]) &#123; _minHeap[index] = _minHeap[twoC]; _minHeap[twoC] = temp; index = twoC; &#125; else &#123; index = _index; &#125; &#125; &#125;&#125;template&lt;class T&gt;void JBMinHeap&lt;T&gt;::adjustUp(int index) &#123; if (index &gt; _index) &#123;//大于堆的最大值直接return return; &#125; while (index&gt;-1) &#123; T temp = _minHeap[index]; int father = (index - 1) / 2; if (father &gt;= 0) &#123;//若果索引没有出界就执行想要的操作 if (temp &lt; _minHeap[father]) &#123; _minHeap[index] = _minHeap[father]; _minHeap[father] = temp; index=father; &#125; else &#123;//若果已经是比父亲大 则直接结束循环 index = -1; &#125; &#125; else//出界就结束循环 &#123; index = -1; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空间复杂度]]></title>
    <url>%2F2018%2F06%2F15%2F%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[空间复杂度 前面刚讲了时间复杂度，有兴趣的去看看什么是时间复杂度？ 名词解释：空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。 度量方法 类似于 时间复杂度的讨论，一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。空间复杂度(SpaceComplexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\”进行的，是节省存储的算法，有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。 分析方法分析一个算法所占用的存储空间要从各方面综合考虑。如对于递归算法来说，一般都比较简短，算法本身所占用的存储空间较少，但运行时需要一个附加堆栈，从而占用较多的临时工作单元；若写成非递归算法，一般可能比较长，算法本身占用的存储空间较多，但运行时将可能需要较少的存储单元。一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。若一个算法为 [2] 递归算法，其空间复杂度为递归所使用的堆栈空间的大小，它等于一次调用所分配的临时存储空间的大小乘以被调用的次数(即为递归调用的次数加1，这个1表示开始进行的一次非递归调用)。算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)；当一个算法的空间复杂度与n成线性比例关系时，可表示为O(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。故一个算的空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。所以它强调的是使用的辅助空间的的大小，而不是指所有的数据所占用的空间。以斐波那契算法为例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152long long* fib(long long n) &#123; assert(n&gt;=0); long long* ptr=new long long[n+1]; ptr[0]=0; ptr[1]=1; for(int i=2;i&lt;=n;++i) &#123; ptr[i]=ptr[i-1]+ptr[i-2]; &#125; return ptr; &#125; /*对于这种算法，函数真正执行次数为n-1,所以忽略常数后，时间复杂度为O(n);因为开辟了n+1个空间，有n+1个辅助空间，所以空间复杂度为O(n).*/long long fib(long long n) &#123; assert(n&gt;=0); long long first=0; long long second=1; long long ret=0; for(int i=2;i&lt;=n;i++) &#123; ret=first+second; first=second; second=ret; &#125; return ret; &#125; /*这是非递归的另一种算法，函数真正执行次数依然为n-1,所以忽略常数后，时间复杂度还是O(n);由于采用变量交换的方式，所以在这里辅助空间个数为一个常数，空间复杂度为O(1).*///递归写法#include&lt;assert.h&gt; #include&lt;iostream&gt; using namespace std; long long fib(long long n) &#123; assert(n&gt;=0); return (n&lt;2)?(n):(fib(n-1)+fib(n-2)); &#125; /*递归算法的时间复杂度计算方法是:递归总次数*每次递归次数；递归算法的时间复杂度计算方法是：递归深度*每次递归所需的辅助空间个数.可以得出斐波那契递归算法时间复杂度：O（2^N），空间复杂度为:O(N)*/int main() &#123; long long value=fib(15); cout&lt;&lt; value &lt;&lt;endl; system("pause"); return 0; &#125; 时间复杂度与空间复杂度的联系对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。算法的时间复杂度和空间复杂度合称为算法的复杂度。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间复杂度]]></title>
    <url>%2F2018%2F06%2F15%2F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[算法复杂度算法复杂度分为时间复杂度和空间复杂度。其作用： 时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。（算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度）。 时间复杂度时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。 时间复杂度计算方法1.一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。分析：随着模块n的增大，算法执行的时间的增长率和 f(n) 的增长率成正比，所以 f(n) 越小，算法的时间复杂度越低，算法的效率越高。2.在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级（它的同数量级有以下：1，log2n，n，n log2n ，n的平方，n的三次方，2的n次方，n!），找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数c，则时间复杂度T(n) = O(f(n))。 举例循环如下：12345678910111213141516171819202122232425262728293031for(i=1; i&lt;=n; ++i)&#123; for(j=1; j&lt;=n; ++j) &#123; c[i][j] = 0;//该步骤属于基本操作执行次数：n的平方次 for(k=1; k&lt;=n; ++k) c[i][j] += a[i][k] * b[k][j];//该步骤属于基本操作执行次数：n的三次方次 &#125;&#125;//则有，根据上面括号里的同数量级，我们可以确定n的三次方为T（n）的同数量级。//则有，然后根据 T(n)/f(n) 求极限可得到常数c。//则该算法的时间复杂度：T(n) = O(n^3) 注：n^3即是n的3次方。例2//如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，//则将并列循环的时间复杂度相加。 for (i=1; i&lt;=n; i++) &#123; x++; &#125; for (i=1; i&lt;=n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; x++; &#125; &#125; //第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)， //则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!) 注意Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。Ο(log2n)、Ο(n)、Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者是有效算法，把这类问题称为P类问题，而把后者称为NP问题。但这也只能计算基本的计算时间复杂度，具体的运行还会与硬件有关。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基本操作]]></title>
    <url>%2F2018%2F06%2F13%2Fmysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Mysql安装mysql 是一个小型的数据库安装过程参考：MySQL安装过程1.首先登入数据库（在cmd窗口进行操作）输入：-u root -p```12345![这里写图片描述](https://img-blog.csdn.net/20180613225925564?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)2.建立一个数据库```create datebase lala；(数据库名，可以根据实际项目取名） 2.使用本数据库table1；```12输入此条语句数据库才能进行操作4.数据库的增删改查操作 增：insert into table(表名） value（);（“()”中数据类型与表单的元素一一对应）删：delete from table where la=1;改：update table set la=1 where dada=”haha”;查：select *(显示全部符号，也可以指定显示内容如dada） from table;125.删除表```drop table tb1; 约束1.空值与非空约束table tb2 (user_name not null,user_age null);```12345678910112.自增约束自动编号 起始为1自动编号的字段必须设置为主键（primary key）例如create table tb2 (user_name auto_increment primary key);auto_increment 必须定义为主键 而主键不一定要是auto increment 3.主键约束primary key主键必须为not null主键会保证唯一性4.唯一约束unique key 保证唯一性### 数据表列操作 1.添加列alter tbale tb1 column a varchar;新增列名为a的字段2.删除列alter table tb1 column x;删除列名为x的字段3.查询表中的所有列名 show columns from 表名;ex:show columns from tb1;4.调整字段的位置(first,last) alter table tb1 modify y int first;将该字段放到最前面去了；5.修改字段的数据类型alter table tb1 modify x smallint;由大类型改到小类型可能会造成数据的丢失；6.修改字段的名称alter table tb1 change x xx int;将x字段更名为xx字段，其类型为int 型该语句修改数据表中字段的名称和数据类型7.查看表中的所有列show columns from tb1;8.输出所有列select from tb1;select from tb1\G 以网格形式输出所有列`]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻转字符串]]></title>
    <url>%2F2018%2F06%2F11%2F%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目输入：i am a student.输出：student.a am i 分析先总体反转，然后逐个单词反转，首先，将字符串完全翻转一次，得到.tneduts a ma i。然后设置两个指针，对单词进行翻转，也就是局部翻转. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void AllReverse(char *pStart, char *pEnd)//全反转&#123; char pTemp; if (pStart == NULL || pEnd == NULL) return; while (pStart &lt; pEnd) &#123; pTemp = *pStart; *pStart = *pEnd; *pEnd = pTemp; pStart++; pEnd--; &#125;&#125;char *Reverse(char *pData)//单词反转&#123; if (pData == NULL) &#123; return NULL; &#125; char *pStart = pData; char *pEnd = pData; while (*pEnd != '\0') &#123; pEnd++; &#125; pEnd--; AllReverse(pStart, pEnd);//全反转 pStart = pEnd = pData; while (*pStart != '\0') &#123; if (*pStart == ' ') &#123; pStart++; pEnd++; &#125; else if (*pEnd == ' ' || *pEnd == '\0') &#123; AllReverse(pStart, --pEnd); pStart = ++pEnd; &#125; else &#123; pEnd++; &#125; &#125; return pData;&#125;int main()// 主函数&#123; char a_arr[100]; char * str = NULL; gets_s(a_arr); str = Reverse(a_arr); cout &lt;&lt; str; return 0;&#125; 运行结果]]></content>
      <tags>
        <tag>面试</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找到数组第一个相同的数]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定一个数组，然找到数组里第一个重复的数字。例： arr[]={1,2,4,3,6,5,6,5,8,9}找到5。 代码1234567891011121314151617181920212223void checknum(int arr[], int num) &#123; int key = arr[0]; int i = 0; for (int j = 0; j &lt; num; j++) &#123; key = arr[j]; for (i = j + 1; i &lt; num; i++) &#123; if (arr[i] == key) &#123; cout &lt;&lt; "该数组有重复数字,数字是：" &lt;&lt; key &lt;&lt; endl; return; &#125; &#125; &#125; cout &lt;&lt; "没有重复的数字"; &#125; int main() &#123; int arr[] = &#123; 1, 2, 3, 4, 5, 4, 7, 8, 9 &#125;; checknum(arr, 9); return 0; 结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[寻找两个链表公共节点]]></title>
    <url>%2F2018%2F06%2F06%2F%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目两个单向链表，找出它们的第一个公共结点。数据类型如下： 12345typedef struct Node&#123; int data; Node* next;&#125;Node; 分析如果两个单向链表有公共的结点，也就是说两个链表从某一结点开始，它们的Next都指向同一个结点。但由于是单向链表的结点，每个结点只有一个Next，因此从第一个公共结点开始，之后它们所有结点都是重合的，不可能再出现分叉。所以，两个有公共结点而部分重合的链表，拓扑形状看起来像一个Y，而不可能像X。看到这个题目，第一反应就是蛮力法：在第一链表上顺序遍历每个结点。每遍历一个结点的时候，在第二个链表上顺序遍历每个结点。如果此时两个链表上的结点是一样的，说明此时两个链表重合，于是找到了它们的公共结点。如果第一个链表的长度为m，第二个链表的长度为n，显然，该方法的时间复杂度为O(mn)。接 下来我们试着去寻找一个线性时间复杂度的算法。我们先把问题简化：如何判断两个单向链表有没有公共结点？前面已经提到，如果两个链表有一个公共结点，那么 该公共结点之后的所有结点都是重合的。那么，它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分，只要分别遍历两个链表到最后一 个结点。如果两个尾结点是一样的，说明它们用重合；否则两个链表没有公共的结点。在上面的思路中，顺序遍历两个链表到尾结点的时候，我们不能保证在两个链表上同时到达尾结点。这是因为两个链表不一定长度一样。但如果假设一个链表比另一个长l个结点，我们先在长的链表上遍历l个结点，之后再同步遍历，这个时候我们就能保证同时到达最后一个结点了。由于两个链表从第一个公共结点考试到链表的尾结点，这一部分是重合的。因此，它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。在这个思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历若干次之后，再同步遍历两个链表，知道找到相同的结点，或者一直到链表结束。此时，如果第一个链表的长度为m，第二个链表的长度为n，该方法的时间复杂度为O(m+n)。 基于这个思路，我们不难写出如下的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;iostream&gt;#include&lt;assert.h&gt;using namespace std;typedef struct Node//数据结构体&#123; int data; Node* next;&#125;Node;Node* findnode(Node* head, int n);Node* init_list(int n)//初始化链表&#123; Node* head = NULL; if (n &lt; 0) &#123; cout &lt;&lt; "链表数目个数有问题" &lt;&lt; endl; &#125; else if (n == 0) &#123; head = NULL; return head; &#125; else &#123; cout &lt;&lt; "请输入 " &lt;&lt; n &lt;&lt; "个数据" &lt;&lt; endl; while (n-- &gt; 0) &#123; Node* ptr = new Node; cin &gt;&gt; ptr-&gt;data; ptr-&gt;next = head; head = ptr; &#125; &#125; return head;&#125;void show(Node *head)//打印链表&#123; if (head == NULL) &#123; cout &lt;&lt; "这是一个空链表" &lt;&lt; endl; &#125; while (head != NULL) &#123; cout &lt;&lt; head-&gt;data &lt;&lt; "-&gt;"; head = head-&gt;next; &#125; cout &lt;&lt; "NULL" &lt;&lt; endl;&#125;int sort_list(Node* head)//遍历链表&#123; int count = 0; if (head == NULL) &#123; cout &lt;&lt; "链表为空" &lt;&lt; endl; &#125; while (head) &#123; head = head-&gt;next; count++; &#125; return count;&#125;Node* findnode(Node* head, int n)&#123; Node* ptr = head; if (NULL == head) &#123; return NULL; &#125; else &#123; while (n--) &#123; ptr = ptr-&gt;next; &#125; &#125; return ptr;&#125;void FindFirstCommonNode(Node* head1, Node* head2)//寻找公共节点&#123; assert(head1); assert(head2); int len1 = sort_list(head1); int len2 = sort_list(head2); int tmp = 0; if (len1 &gt; len2) &#123; tmp = len1 - len2; for (int i = 0; i &lt; tmp; i++) &#123; head1 = head1-&gt;next; &#125; &#125; else &#123; tmp = len2 - len1; for (int i = 0; i &lt; tmp; i++) &#123; head2 = head2-&gt;next; &#125; &#125; while ((head1 != NULL) &amp;&amp; (head2 != NULL) &amp;&amp; (head1 != head2)) &#123; head1 = head1-&gt;next; head2 = head2-&gt;next; &#125; Node* key = head1; cout &lt;&lt; "公共节点为" &lt;&lt; key-&gt;data &lt;&lt; endl;&#125;int main()&#123; int n; int m; cout &lt;&lt; "请输入你想要创建的链表节点个数" &lt;&lt; endl; cin &gt;&gt; n; Node* ptr = init_list(n); show(ptr); cout &lt;&lt; "请输入你想要创建的链表节点个数" &lt;&lt; endl; cin &gt;&gt; m; Node* ptr1 = init_list(m); findnode(ptr1,m-1)-&gt;next = findnode(ptr, 3); show(ptr1); FindFirstCommonNode(ptr, ptr1); return 0;&#125; 截图]]></content>
      <tags>
        <tag>面试</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言注释转C++注释]]></title>
    <url>%2F2018%2F06%2F04%2FC%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A%E8%BD%ACC%2B%2B%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[题目要求int a = 10;// 1.一般情况int num = 0;/_ int i = 0; _/ // 2.换行问题/_ int i = 0; /int j = 0;/ int i = 0; _/int j = 0; // 3.匹配问题/_int i = 0;/_xxxxx*/ // 4.多行注释问题/_int i=0;int j = 0;int k = 0;_/int k = 0; // 5.连续注释问题/int a=0;//int b=0;/ // 6.连续的/问题/*/ // 7.C++注释问题// /xxxxxxxxxxxx/ 问题分析 代码片头文件12345678910111213141516171819202122#ifndef __COMMENTCONVERT_HEADFILE__ #define __COMMENTCONVERT_HEADFILE__#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; enum STATE &#123;NUL,C,CPP,END&#125;;void CommentConvert(FILE *pfin, FILE * pfout);void DoNULConvert(FILE *pfin, FILE * pfout, enum STATE * state); void DoCConvert(FILE *pfin, FILE * pfout, enum STATE * state);void DoCPPConvert(FILE *pfin, FILE * pfout, enum STATE * state);#endif 源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include"标头.h"#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void CommentConvert(FILE *pfin, FILE * pfout)&#123; enum STATE state = NUL;//初始化状态 为 无注释状态 while (state != END) &#123; switch (state) &#123; case NUL: &#123; DoNULConvert(pfin, pfout, &amp;state); &#125; break; case C: &#123; DoCConvert(pfin, pfout, &amp;state); &#125; break; case CPP: &#123; DoCPPConvert(pfin, pfout, &amp;state); &#125; break; default: break; &#125; &#125;&#125;void DoNULConvert(FILE *pfin, FILE * pfout, enum STATE * state)&#123; int start = 0; int next = 0; start = fgetc(pfin); switch (start) &#123; case '/': &#123; next = fgetc(pfin); switch (next) &#123; case '*':// 表示进入C语言注释状态 &#123; fputc('/', pfout); fputc('/', pfout); *state = C;//状态转换为 C注释状态 &#125; break; case '/':// 表示进入C++注释状态 &#123; fputc(start, pfout); fputc(next, pfout); *state = CPP; //状态转换为 C++注释状态 &#125; break; default: &#123; fputc(start, pfout); fputc(next, pfout); &#125; break; &#125; &#125; break; case EOF: &#123; fputc(start, pfout); *state = END; &#125; break; default://表示遇到的不是注释 ，状态不变 &#123; fputc(start, pfout); //将读取的字符输出到文件 &#125; break; &#125;&#125;//c状态转换 void DoCConvert(FILE *pfin, FILE * pfout, enum STATE * state)&#123; int start = 0; int next = 0; int then = 0; start = fgetc(pfin); switch (start) &#123; case '*'://遇到'*'表示C语言注释状态 &#123; next = fgetc(pfin); switch (next) &#123; case '/': &#123; then = fgetc(pfin); if (then == '\n') &#123; fputc(then, pfout); &#125; else &#123; fputc('\n', pfout); ungetc(then, pfin); &#125; *state = NUL; &#125; break; default: &#123; fputc(start, pfout); ungetc(next, pfin); &#125; break; &#125; &#125; break; case '\n': &#123; fputc(start, pfout); fputc('/', pfout); fputc('/', pfout); &#125; break; default: fputc(start, pfout); break; &#125;&#125;//c++状态转换void DoCPPConvert(FILE *pfin, FILE * pfout, enum STATE * state)&#123; int start = 0; int next = 0; int then = 0; start = fgetc(pfin); switch (start) &#123; case '\n': &#123; fputc(start, pfout); *state = NUL; &#125; break; default: fputc(start, pfout); break; &#125;&#125; 测试文件123456789101112131415161718192021222324252627#include "标头.h"int main()&#123; FILE *pfin = NULL; FILE *pfout = NULL; pfin = fopen("input.c", "r"); if (pfin == NULL) &#123; perror("input file open:"); exit(EXIT_FAILURE); &#125; pfout = fopen("output.c", "w"); if (pfout == NULL) &#123; perror("output file open:"); fclose(pfin); exit(EXIT_FAILURE); &#125; CommentConvert(pfin, pfout); printf("注释转换成功\n"); fclose(pfin); fclose(pfout); system("pause"); return 0;&#125;]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“链表倒数第K个节点”]]></title>
    <url>%2F2018%2F06%2F03%2F%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，输出该链表中倒数第k个结点。思路：设置两个指针指向头节点分别为p，和ptr；让p指针先走k-1次，然后让ptr跟着p指针一直遍历下去直到遍历完整个链表，这时ptr指针就指向倒数第k个节点了。有些兴趣的同学可以仔细琢磨。很有意思。附上我的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;using namespace std;typedef struct Node//链表结构&#123; int data; Node* next; &#125;Node;Node* init_list( int n)//初始化链表&#123; Node* head = NULL; if (n &lt; 0) &#123; cout &lt;&lt; "链表数目个数有问题" &lt;&lt; endl; &#125; else if(n == 0) &#123; head = NULL; return head; &#125; else &#123; cout&lt;&lt; "请输入 " &lt;&lt; n &lt;&lt; "个数据"&lt;&lt;endl; while (n-- &gt; 0) &#123; Node* ptr = new Node; cin &gt;&gt; ptr-&gt;data; ptr-&gt;next = head; head= ptr; &#125; &#125; return head;&#125;void show(Node *head)//打印链表 &#123; if (head == NULL) &#123; cout &lt;&lt; "这是一个空链表" &lt;&lt; endl; &#125; while (head!=NULL) &#123; cout &lt;&lt; head-&gt;data &lt;&lt; "-&gt;"; head = head-&gt;next; &#125; cout &lt;&lt; "NULL"&lt;&lt;endl; &#125; Node* FindKthToTail(Node* head, int k)//链表节点 &#123; if (NULL == head&amp;&amp;k&lt;=0) &#123; return NULL; &#125; Node* p = head, *ptr = head; for (int i = 0; i &lt; k-1; i++) &#123; if (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; &#125; while (p-&gt;next) &#123; ptr = ptr-&gt;next; p = p-&gt;next; &#125; return ptr; &#125;int main() //主函数 &#123; // Node*ptr3= create_list(); // show(ptr3); int n; cout &lt;&lt; "请输入你想要创建的链表节点个数" &lt;&lt; endl; cin &gt;&gt; n; Node* ptr=init_list(n); show(ptr); //insert(ptr,4,5); // show(ptr); //Node* ptr2=resevertlist(ptr); //show(ptr2); // minus_point(ptr2, 2); // show(ptr2); // Node*ptr3= minus_point(ptr2, 1); // show(ptr3); //int count= sort_list(ptr3); //cout &lt;&lt; count &lt;&lt; endl; Node*ptr4 = FindKthToTail(ptr, 3); cout &lt;&lt; ptr4-&gt;data; return 0; &#125; 运行结果：]]></content>
      <tags>
        <tag>面试</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组的查找]]></title>
    <url>%2F2018%2F06%2F01%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目分析矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，因此从左下角开始查找，当要查找数字比左下角数字大时。右移要查找数字比左下角数字小时，上移。例矩阵： 1 2 3 4 5 6 7 8 9 具体算法如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt; using namespace std; int main() &#123; int i, j; int key = 0; int const row = 3; int const col = 3; int arr[row][col] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; cout &lt;&lt; "输入要查找的值" &lt;&lt; endl; cin &gt;&gt; key; /* for (i = 0; i &lt; row; i++) &#123; for (j = 0; j &lt; col; j++) &#123; cin &gt;&gt; arr[row][col]; &#125; &#125;*/ for (i = row - 1, j = 0;(i &gt;= 0 )&amp;&amp; (j &lt; col);) &#123; if (arr[i][j] == key) &#123; cout &lt;&lt; "该数存在!" &lt;&lt; endl; return 0; &#125; if (arr[i][j]&gt;key) &#123; i--; continue; &#125; if (arr[i][j] &lt; key) &#123; j++; &#125; &#125; cout &lt;&lt; "该数不存在" &lt;&lt; endl; return 0; &#125; 运行结果：]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求二进制中1的个数]]></title>
    <url>%2F2018%2F05%2F31%2F%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[方法一：思路：如果一个数与1作与运算则可以发现该数最后一位数为1，否则为0.按照此思路可以有以下代码： 12345678910111213141516171819202122#include &lt;iostream&gt; using namespace std; int main() &#123; int n = 0; cout &lt;&lt; "输入一个数"; cin &gt;&gt; n; int count = 0; while (n) &#123; if (n &amp; 1) &#123; count++; &#125; n &gt;&gt;= 1; &#125; cout &lt;&lt; "1的个数为"&lt;&lt;count&lt;&lt;endl; return 0; &#125; 但是此方法存在缺陷如果输入的数为负数则会无限死循环 方法二：首先把n与1做与运算，判断n的最低位是不是为1。接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1….这样反复左移，每次能判断n的其中一位是不是1.这个解法中循环的次数等于整数二进制的位数，32位的整数需要循环32次 1234567891011121314151617181920212223#include &lt;iostream&gt; using namespace std; int main() &#123; int n = 0; int key = 1; cout &lt;&lt; "输入一个数"; cin &gt;&gt; n; int count = 0; while (key) &#123; if (n &amp; key) &#123; count++; &#125; key &lt;&lt;= 1; &#125; cout &lt;&lt; "1的个数为"&lt;&lt;count&lt;&lt;endl; return 0; &#125; 结果如上图： 方法三思路：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0，那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。 12345678910111213141516171819#include &lt;iostream&gt; using namespace std; int main() &#123; int n = 0; cout &lt;&lt; "输入一个数"; cin &gt;&gt; n; int count = 0; while (n) &#123; n = ((n - 1)&amp; n); count++; &#125; cout &lt;&lt; "1的个数为"&lt;&lt;count&lt;&lt;endl; return 0; &#125;]]></content>
      <tags>
        <tag>面试</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程第一课]]></title>
    <url>%2F2018%2F05%2F30%2F%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[第一题有一组数，对于其中任意两个数组，若前面一个大于后面一个数字，则这两个数字组成一个逆序对。请设计一个高效的算法，计算给定数组中的逆序对个数。 给定一个int数组A和它的大小n，请返回A中的逆序对个数。保证n小于等于5000。测试样例：[1,2,3,4,5,6,7,0],8返回：7 答案如下： 123456789101112131415161718192021/*冒泡排序时做了多少次交换就有多少个逆序*/class AntiOrder &#123;public: int count(vector&lt;int&gt; A, int n) &#123; // write code here int count = 0; int i,j; if(n &lt; 2) return n; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n-i-1;j++)&#123; if(A[j]&gt;A[j+1])&#123; swap(A[j],A[j+1]); count++; &#125; &#125; &#125; return count; &#125;&#125;; 第二题：写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。例如输入：1abcd 输出1dcba 答案如下： 12345678910//最简洁#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; for(int i = str.size()-1; i &gt;=0;i--) cout &lt;&lt; str[i];&#125; 方法二：利用栈 12345678910111213141516171819//这样的输出可以利用栈后进先出的结构#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main(void)&#123; char ch; stack&lt;char&gt; ch_stack; while(cin&gt;&gt;ch) &#123; ch_stack.push(ch); &#125; while(!ch_stack.empty()) &#123; cout&lt;&lt;ch_stack.top(); ch_stack.pop(); &#125; return 0;&#125; 方法三： 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; reverse(str.begin(), str.end()); cout &lt;&lt; str; return 0;&#125;]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2F2018%2F05%2F29%2F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件操作C++ 通过以下几个类支持文件的输入输出：ofstream: 写操作（输出）的文件类 (由ostream引申而来)ifstream: 读操作（输入）的文件类(由istream引申而来)fstream: 可同时读写操作的文件类 (由iostream引申而来) 打开文件1.建立联系1ofstream examplefile(&quot;example.txt&quot;);//声明类example并与创建的文件example.txt联系 其中examplefile是ofstream的对象，对象（examplefile）第一个操作通常与一个真正的文件（example.txt）联系起来，改文件由一个流对象（该例子为examplefile）来表示（这些类的一个实例），对改对象进行的操作就是对该对象联系的文件操作。2.判断文件是否打开 1examplefile.is_open()//检查一个文件（examplefile对象所联系的文件）是否被顺利打开 3.向文件中写入数据，并关闭文件 123examplefile &lt;&lt; &quot;This is a line.\n&quot;;examplefile &lt;&lt; &quot;This is another line.\n&quot;;examplefile.close(); ps:为防止流对象被销毁时还联系着打开的文件，析构函数一般将会自动调用关闭函数close 代码示例 123456789101112131415//建立一个文件并写入内容 #include &lt;fstream&gt; using namespace std; int main() &#123; ofstream examplefile("example.txt"); if (examplefile.is_open()) &#123; examplefile &lt;&lt; "This is a line.\n"; examplefile &lt;&lt; "This is another line.\n"; examplefile.close(); &#125; return 0; &#125; 结果： 1examplefile.eof();//eof ，它是ifstream 从类 ios 中继承过来的，当到达文件末尾时返回true 文件读取： 12examplefile.getline(buffer,100);//getline，读取一行字符，直到遇见换行符。getline具有返回值：成功：返回读取的字节数 失败：返回-1。 代码示例： 1234567891011121314151617181920//对文件的读取示例 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;cstdlib&gt; using namespace std; int main () &#123; char buffer[256]; //定义一个数组，用来存放字符 ifstream examplefile("example.txt"); //声明一个对象与要读的文件联系 if (! examplefile.is_open()) //判断是否打开&#123; cout &lt;&lt; "Error opening file"; exit (1); &#125; while (!examplefile.eof()) &#123; examplefile.getline(buffer,100); cout&lt;&lt;buffer&lt;&lt; endl; &#125; return 0; &#125; read和write函数分别为istream和ostream的成员函数，前者被ifstream所继承，后者被ostream所继承。 代码示例：123456789101112131415161718#include &lt;fstream&gt; #include &lt;iostream&gt; using namespace std; int main () &#123; const char * filename = "example.txt"; char * buffer;//buffer是一块内存地址，用来存储或读取数据 long size;//size 是一个整数值，表示要从缓存（buffer）中读出或写入的字符数 ifstream file(filename, ios::in|ios::binary|ios::ate); size = file.tellg(); file.seekg(0, ios::beg); buffer = new char [size]; file.read(buffer, size); file.close(); cout &lt;&lt;"the complete file is in a buffer"; delete[] buffer; return 0; &#125; 具体read，write可参照CSDN专门有一篇博客专门介绍。]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++输入流]]></title>
    <url>%2F2018%2F05%2F28%2FC%2B%2B%E8%BE%93%E5%85%A5%E6%B5%81%2F</url>
    <content type="text"><![CDATA[CINcin是C++编程语言中的标准输入流对象，即istream类的对象。cin主要用于从标准输入读取数据，这里的标准输入，指的是终端的键盘。此外，cout是流的对象，即ostream类的对象，cerr是标准错误输出流的对象，也是ostream 类的对象。这里的标准输出指的是终端键盘，标准错误输出指的是终端的屏幕。在理解cin功能时，不得不提标准输入缓冲区。当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键(\r)会被转换为一个换行符\n，这个换行符\n也会被存储在cin的缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了123456这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。cin读取数据也是从缓冲区中获取数据，缓冲区为空时，cin的成员函数会阻塞等待数据的到来，一旦缓冲区中有数据，就触发cin的成员函数去读取数据。 使用cin从标准输入读取数据时，通常用到的方法有cin&gt;&gt;，cin.get，cin.getlinecin&gt;&gt;&lt;变量1&gt;[&gt;&gt;&lt;变量2&gt;&gt;&gt;…&gt;&gt;&lt;变量n&gt;]; 其中“&gt;&gt;”称为提取运算符，用于读取用户输入的数据，赋给变量。在cin之后“&gt;&gt;&lt;变量&gt;”可重复多次。输入多个数据时数据之间要用空格、TAB、或者ENTER键隔开，系统会自动跳过空格和回车符，将输入的数据赋给各提取运算符的变量。回车符有两个作用一个是分隔符另一个是刷新缓冲区，并通知cin已经输入一行数据。123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; char a; int b; float c; string cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 但如果提取运算符的&lt;&lt;后面的变量是字符型，则必须输入字符。单当要获取输入的空格或ENTER键，直接用”&lt;&lt;”不能实现，必须借助于cin.get函数,其一般形式为:123456789101112131415cin.get([&lt;字符型变量])#include &lt;iostream&gt;using namespace std;int main()&#123; char a; char b; a=cin.get(); cin.get(b); cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 输入一个空格,一个Enter:注意：（1）从结果可以看出，cin.get()从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取，就出现了如上情况，将换行符读入变量b，输出时换行两次，一次是变量b，一次是endl。（2）cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c) gets读取一行gets是C中的库函数，在&lt; stdio.h&gt;申明，从标准输入设备读字符串，可以无限读取，不会判断上限，以回车结束或者EOF时停止读取，所以程序员应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。 函数原型：123456789101112char *gets( char *buffer );#include &lt;iostream&gt;using namespace std;int main()&#123; char array[20]=&#123;NULL&#125;; gets(array); cout&lt;&lt;array&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 由于此函数是C的库函数,所以不建议使用,在C++中使用会报警告.]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟实现atoi函数]]></title>
    <url>%2F2018%2F05%2F27%2Fatoi%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[atoi函数 atoi函数是把字符串转换成整型数的一个函数，应用在计算机程序和办公软件中。int atoi(const char *nptr) 函数会扫描参数 nptr字符串，跳过前面的空白字符（例如空格，tab缩进）等，可以通过isspace( )函数来检测），直到遇上数字或正负符号才开始做转换，而在遇到非数字或字符串结束符(‘\0’)才结束转换，并将结果返回。如果 nptr不能转换成 int 或者 nptr为空字符串，那么将返回 0 。12345678910#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; int n; char *str = "12345"; n = atoi(str); printf("n=%d\n",n); return 0;&#125; 输出n=123456 模拟实现atoi 代码实现 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt; int StrToInt(char *str) &#123; long number = 0; int flag = 1; //判断符号位 if (NULL == str) &#123; printf("str is NULL"); return 0; &#125; while (*str == ' ') //空格 &#123; str++; &#125; if (*str == '-') //符号位 &#123; flag = -1; str++; //后移3移位 &#125; while ((*str &gt;= '0') &amp;&amp; (*str &lt;= '9'))//转化 &#123; number = number * 10 + *str - '0'; str++; &#125; return flag*number; &#125; int main() &#123; char* str = "-123456"; int tmp = StrToInt(str); cout &lt;&lt; tmp&lt;&lt;endl; &#125;]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针数组和数组指针的区别]]></title>
    <url>%2F2018%2F05%2F26%2F%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88-md%2F</url>
    <content type="text"><![CDATA[昨天聊了常量指针和指针常量的区别，今天继续一个比较容易混淆的话题，指针数组和数组指针=.=! 数组指针含义：指向数组的的指针(1)数组在内存中的表示创建一个数组就是在内存里面开辟一块连续的空间，比如int a[4];就是在内存里面开辟了一个大小为4*sizeof(int)字节的内存空间。而二维数组是特殊的一维数组。1234567#include&lt;stdio.h&gt;void main() &#123; int a[2][2]=&#123;1,2,3,4&#125;;//这是一个2*2的二维数组 int (*p)[2];//数组指针 p=a;//令p指向数组a &#125; 这里p是一个指向数组的指针。 让我们理解数组名和数组指针变量：a,a[0],a[1],p,a+1,a[0]+1,p+1这些分别代表什么意思呢？答案：a是一个数组名，类型是指向一维数组的指针，不是变量，a的值是指针常量，即不能有a++或者a=p这些操作。a指向这块连续空间的首地址，值是&amp;a[0][0]。 a[0]是一维数组名，类型是指向整型的指针，值是&amp;a[0][0]，这个值是一个常量。 a[1]是一维数组名，类型是指向整型的指针，值是&amp;a[1][0]，这个值是一个常量。 p是一个数组指针变量，指向一维数组的指针变量，值是&amp;a[0][0]。可以执行p++;p=a等操作。a+1表示指向下一行元素，也可以理解为指向下一个一维数组。 (a+1)是取出第一行的首地址。 a[0]+1是指向第0行第1个元素，也可以理解为指向一维数组a[0]的第一个元素。 p+1同a+1 (p+1)同_(a+1) 虽然a跟a[0]值是一样，但类型不一样，表示的意义不一样。通过分析就不难理解为什么_(*(a+i)+j)和a[i][j]等效了。 数组名与数组指针变量的区别区别：数组名是指针，类型是指向元素类型的指针，但值是指针常量，声明数组时编译器会为声明所指定的元素数量保留内存空间。数组指针是指向数组的指针，声明指针变量时编译器只为指针本身保留内存空间。 指针数组（存放指针的数组）指针数组：一个存放int类型的数组称为整型数组，那么存放指针的数组就叫指针数组。 #include&lt;stdio.h&gt; void main() { int i=1,j=2;//p先跟[]结合，然后再跟*结合 int *p[2];//指针数组,存放指针的数组 p[0]=&amp;i; p[1]=&amp;j; printf("%d",sizeof(p)); } 此例数组p就两个元素，p[0]是指向i的指针，p[1]是指向j的指针。这两个指针都是int型指针，所以p是存放int型指针的数组。sizeof(p)返回数组占用的总空间，所以程序输出是8 常用举例字符排序，可以用指针数组指向不字符串，排序时改变指针指向就避免了大量文本数据的移动。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F05%2F25%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序（Quicksort）是对冒泡排序的一种改进。快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 原理官方解释：设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。一趟快速排序的算法是：1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。尼玛，这都是啥，想必没有见过这个算法的小可爱，对这个官方解释可能是一脸懵逼。所以我就把这个算法通俗的讲一讲。首先要对一堆数字排序我们必须找到一个基准数。而这个基准数可以是这一堆数字中的任意一个，我们定义两个移动的变量从数组的两头向中间检索。从右往左走的变量找到一个小于基准数后停止，从左往右的的变量找到一个大余基准数后停止然后这两个数就交换一下，直到两个变量相遇后就遍历了整个数组，这时候数字的左边都小于基准数，右边大于基准数。然后把数组分成两部分在执行遍历交换后，就完成排序了。 具体实例： 1234567891011121314151617181920212223242526272829303132333435363738394041void quicksort(int* a, int left, int right) &#123; int i, j, t, temp; if (left&gt;right) return; temp = a[left]; //temp中存的就是基准数 i = left; j = right; while (i != j) &#123; //顺序很重要，要先从右边开始找 while (a[j] &gt;= temp &amp;&amp; i&lt;j) j--; //再找右边的 while (a[i] &lt;= temp &amp;&amp; i&lt;j) i++; //交换两个数在数组中的位置 if (i&lt;j) &#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; //最终将基准数归位 a[left] = a[i]; a[i] = temp; quicksort(a, left, i - 1);//继续处理左边的，这里是一个递归的过程 quicksort(a, i + 1, right);//继续处理右边的 ，这里是一个递归的过程 &#125; int main()&#123; int arr[10] = &#123; 8, 2, 3, 1, 6, 5, 4, 7, 0, 9 &#125;; quicksort(arr, 0, 9); for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; arr[i]&lt;&lt;endl; &#125; return 0; &#125; 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针常量和常量指针的区别]]></title>
    <url>%2F2018%2F05%2F24%2F%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在面试中我们经常会被面试官问到什么是常量指针，什么又是指针常量。可能第一次被问到都会有些懵逼（大神略过）。我今天就来讲一讲这二者的区别。下面开始正题。。。。 指针常量指针常量：顾名思义它就是一个常量，但是是指针修饰的。格式为： 1int * const p //指针常量 在这个例子下定义以下代码： 12345int a，b；int * const p=&amp;a //指针常量//那么分为一下两种操作*p=9;//操作成功p=&amp;b;//操作错误 因为声明了指针常量，说明指针变量不允许修改。如同次指针指向一个地址该地址不能被修改，但是该地址里的内容可以被修改 常量指针常量指针：如果在定义指针变量的时候，数据类型前用const修饰，被定义的指针变量就是指向常量的指针变量，指向常量的指针变量称为常量指针，格式如下 1const int *p = &amp;a; //常量指针 在这个例子下定义以下代码： 12345int a，b； const int *p=&amp;a //常量指针//那么分为一下两种操作*p=9;//操作错误p=&amp;b;//操作成功 因为常量指针本质是指针，并且这个指针是一个指向常量的指针，指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变。 附加题指向常量的指针常量该怎么写？答案： 1const int * const b = &amp;a;//指向常量的指针常量]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数源码]]></title>
    <url>%2F2018%2F05%2F23%2F%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2-md%2F</url>
    <content type="text"><![CDATA[strcpy源码：123456789 char *strcpy(char *strDes, const char *strSrc) &#123; assert((strDes != NULL) &amp;&amp; (strSrc != NULL)); char *address = strDes; while ((*strDes ++ = *strSrc ++) != '\0') NULL; return address; 注意：strcpy只是复制字符串，但不限制复制的数量。很容易造成缓冲溢出，也就是说，不过dest有没有足够的空间来容纳src的字符串，它都会把src指向的字符串全部复制到从dest开始的内存 strcmp源码：123456789101112int strcmp(const char *s, const char *t) &#123; assert(s != NULL &amp;&amp; t != NULL); while (*s &amp;&amp; *t &amp;&amp; *s == *t) &#123; ++ s; ++ t; &#125; return (*s - *t); &#125; strcat源码：12345678910111213char *strcat(char *strDes, const char *strSrc) &#123; assert((strDes != NULL) &amp;&amp; (strSrc != NULL)); char *address = strDes; while (*strDes != '\0') ++ strDes; while ((*strDes ++ = *strSrc ++) != '\0') NULL; return address; &#125; 注意：1.不能向形参传递指向字符串常量的指针（本题中dst和src都是指向串常量的指针，字符串常量存储在常量区不能被修改 2.传递的字符数组前一个实参的所分配的内存空间必须足够大 strlen源码：12345678910int strlen(const char *str) &#123; assert(str != NULL); int len = 0; while (*str ++ != '\0') ++ len; return len; &#125; strstr源码：1234567891011121314151617char *strstr(const char *strSrc, const char *str) &#123; assert(strSrc != NULL &amp;&amp; str != NULL); const char *s = strSrc; const char *t = str; for (; *t != '\0'; ++ strSrc) &#123; for (s = strSrc, t = str; *t != '\0' &amp;&amp; *s == *t; ++s, ++t) NULL; if (*t == '\0') return (char *) strSrc; &#125; return NULL; &#125; strchr源码：1234567891011121314char * __cdecl strchr ( constchar * string, int ch )&#123; while (*string &amp;&amp; *string != (char)ch) string++; if (*string == (char)ch) return((char *)string); return(NULL);&#125; 断言：assert（表达式）如果表达式的值为假，整个程序将退出，并输出一条错误信息。如果表达式的值为真则继续执行后面的语句，使用这个宏前需要包含头文件assert.h结语：函数就向一个黑盒一样，调用它的人给他输入（调用它本身就是一种输入），然后等待一个理想中的输出或者是相应的操作。调用者是希望我们的这个函数能够非常健壮的让他们利用，那么为了使我们的函数拥有一定的鲁棒性。]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
        <tag>程序源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2018%2F05%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[测试博客这是一篇测试博客第一次使用github+hexo搭建属于自己的博客.日经过不懈的努力终于搭建好了，我非常开心！！ 2018.5.23 邓铭]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
