<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>函数源码</title>
      <link href="/2018/05/23/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2-md/"/>
      <url>/2018/05/23/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2-md/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="strcpy源码："><a href="#strcpy源码：" class="headerlink" title="strcpy源码："></a>strcpy源码：</h3><pre><code>char *strcpy(char *strDes, const char *strSrc)   {       assert((strDes != NULL) &amp;&amp; (strSrc != NULL));       char *address = strDes;       while ((*strDes ++ = *strSrc ++) != &apos;\0&apos;)           NULL;       return address;   </code></pre><p>注意：strcpy只是复制字符串，但不限制复制的数量。很容易造成缓冲溢出，也就是说，不过dest有没有足够的空间来容纳src的字符串，它都会把src指向的字符串全部复制到从dest开始的内存</p><h3 id="strcmp源码："><a href="#strcmp源码：" class="headerlink" title="strcmp源码："></a>strcmp源码：</h3><pre><code>int strcmp(const char *s, const char *t)   {       assert(s != NULL &amp;&amp; t != NULL);       while (*s &amp;&amp; *t &amp;&amp; *s == *t)       {           ++ s;           ++ t;       }       return (*s - *t);   }  </code></pre><h3 id="strcat源码："><a href="#strcat源码：" class="headerlink" title="strcat源码："></a>strcat源码：</h3><pre><code>char *strcat(char *strDes, const char *strSrc)   {    assert((strDes != NULL) &amp;&amp; (strSrc != NULL));       char *address = strDes;       while (*strDes != &apos;\0&apos;)           ++ strDes;       while ((*strDes ++ = *strSrc ++) != &apos;\0&apos;)           NULL;       return address;   }  </code></pre><p>注意：1.不能向形参传递指向字符串常量的指针（本题中dst和src都是指向串常量的指针，字符串常量存储在常量区不能被修改<br>            2.传递的字符数组前一个实参的所分配的内存空间必须足够大</p><h3 id="strlen源码："><a href="#strlen源码：" class="headerlink" title="strlen源码："></a>strlen源码：</h3><pre><code>int strlen(const char *str)   {       assert(str != NULL);       int len = 0;       while (*str ++ != &apos;\0&apos;)           ++ len;       return len;   }  </code></pre><h3 id="strstr源码："><a href="#strstr源码：" class="headerlink" title="strstr源码："></a>strstr源码：</h3><pre><code>char *strstr(const char *strSrc, const char *str)   {       assert(strSrc != NULL &amp;&amp; str != NULL);       const char *s = strSrc;       const char *t = str;       for (; *t != &apos;\0&apos;; ++ strSrc)       {           for (s = strSrc, t = str; *t != &apos;\0&apos; &amp;&amp; *s == *t; ++s, ++t)               NULL;           if (*t == &apos;\0&apos;)               return (char *) strSrc;       }       return NULL;   }  </code></pre><h3 id="strchr源码："><a href="#strchr源码：" class="headerlink" title="strchr源码："></a>strchr源码：</h3><pre><code>char * __cdecl strchr (                      constchar * string,                      int ch                       ){   while (*string &amp;&amp; *string != (char)ch)        string++;   if (*string == (char)ch)       return((char *)string);    return(NULL);}</code></pre><p>断言：assert（表达式）如果表达式的值为假，整个程序将退出，并输出一条错误信息。如果表达式的值为真则继续执行后面的语句，使用这个宏前需要包含头文件assert.h<br>结语：函数就向一个黑盒一样，调用它的人给他输入（调用它本身就是一种输入），然后等待一个理想中的输出或者是相应的操作。调用者是希望我们的这个函数能够非常健壮的让他们利用，那么为了使我们的函数拥有一定的鲁棒性。</p>]]></content>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 程序源码 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2018/05/23/hello-world/"/>
      <url>/2018/05/23/hello-world/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="测试博客"><a href="#测试博客" class="headerlink" title="测试博客"></a>测试博客</h2><h3 id="这是一篇测试博客"><a href="#这是一篇测试博客" class="headerlink" title="这是一篇测试博客"></a>这是一篇测试博客</h3><p>第一次使用github+hexo搭建属于自己的博客</p>]]></content>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
