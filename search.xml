<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>模板</title>
      <link href="/2018/07/01/%E6%A8%A1%E6%9D%BF/"/>
      <url>/2018/07/01/%E6%A8%A1%E6%9D%BF/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>模板是实现代码重用机制的一种工具，它可以实现数据类型的参数化，即将数据类型定义为参数，而由编译系统在处理具体函数调用时，根据实参类型来匹配函数模板中的对应形参并在确认后生成一个重载函数，从而真正实现代码重用。</p><p>C++中，允许用户构造函数模板，创建支持多种不同数据类型的形参但却具有通用功能的函数；也允许构造类模板，使的类中某些数据成员，成员函数的参数和返回值可以是任意数据类型。使用模板可以从一个函数生成多个函数或者从一个类模板生成多个类，建立一个模板后，编译器将根据使用时的实际数据类型使其实例化，生成可执行的代码，实例化的函数模板称为模板函数；实例化的类称为模板类。模板、模板函数、模板类以及对象关系如下：</p><p><img src="http://pajznqooi.bkt.clouddn.com/%E6%A8%A1%E6%9D%BF.png" alt="404"><br>模板使用方法：<br><code>templete&lt;&lt;类型形参表》&lt;返回类型&gt;&lt;函数名&gt;(模板形参表){...}</code></p><h3 id="模板函数的使用"><a href="#模板函数的使用" class="headerlink" title="模板函数的使用"></a>模板函数的使用</h3><pre><code class="c++"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;                                                                                                                                       </span></span><span class="keyword">using</span> <span class="keyword">namespace</span>  <span class="built_in">std</span>;                                                                                                                                    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                                                                                                       <span class="function">T <span class="title">Power</span><span class="params">(T base,<span class="keyword">int</span> exponent)</span>                                                                                                                             </span><span class="function"></span>{                                                                                                                                                         T value =base;                                                                                                                                           <span class="keyword">while</span>(--exponent&gt;<span class="number">0</span>)                                                                                                                                      {                                                                                                                                                       value*=base;                                                                                                                                             <span class="keyword">return</span> value;                                                                                                                                             }                                                                                                                                                       }                                                                                                                                                        <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                                                                                                                                               </span><span class="function"></span>{                                                                                                                                                          <span class="built_in">cout</span>&lt;&lt;<span class="string">"18^1="</span>&lt;&lt;Power(<span class="number">18</span>,<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;                                                                                                                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"5^3="</span>&lt;&lt;Power(<span class="number">5</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;                                                                                                                          <span class="built_in">cout</span>&lt;&lt;<span class="string">"2.6^7="</span>&lt;&lt;Power(<span class="number">2.6</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;                                                                                                                      <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                              }</code></pre><p>结果：<br><img src="http://pajznqooi.bkt.clouddn.com/%E6%A8%A1%E6%9D%BF1.jpg" alt="404"></p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vector</title>
      <link href="/2018/06/29/Vector/"/>
      <url>/2018/06/29/Vector/</url>
      <content type="html"><![CDATA[<a id="more"></a><p>vector 是同一种类型的对象的集合,每个对象都有一个对应的整数索引值 [1]  。<br>和 string 对象一样,标准库将负责管理与存储元素相关的内存。我们把 vector称为容器,是因为它可以包含其他对象，能够存放任意类型的动态数组，增加和压缩数据。一个容器中的所有对象都必须是同一种类型的 [1]  。<br>vector 是一个类模板(class template)。使用模板可以编写一个类定义或函数定义,而用于多个不同的数据类型。因此,我们可以定义保存 string 对象的 vector,或保存 int 值的 vector,又或是保存自定义的类类型对象(如Sales_items 对象)的 vector。vector 不是一种数据类型,而只是一个类模板,可用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型</p>]]></content>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2018/06/28/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/06/28/Markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="Markdown编辑器写博客"><a href="#Markdown编辑器写博客" class="headerlink" title="Markdown编辑器写博客"></a>Markdown编辑器写博客</h2><p>新功能：</p><ul><li><strong>Markdown和扩展Markdown简洁的语法</strong></li><li><strong>代码块高亮</strong></li><li><strong>图片链接和图片上传</strong></li><li><strong><em>LaTex</em>数学公式</strong></li><li><strong>UML序列图和流程图</strong></li><li><strong>离线写博客</strong></li><li><strong>导入导出Markdown文件</strong></li><li><strong>丰富的快捷键</strong></li></ul><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>加粗    <code>Ctrl + B</code></li><li>斜体    <code>Ctrl + I</code></li><li>引用    <code>Ctrl + Q</code></li><li>插入链接    <code>Ctrl + L</code></li><li>插入代码    <code>Ctrl + K</code></li><li>插入图片    <code>Ctrl + G</code></li><li>提升标题    <code>Ctrl + H</code></li><li>有序列表    <code>Ctrl + O</code></li><li>无序列表    <code>Ctrl + U</code></li><li>横线    <code>Ctrl + R</code></li><li>撤销    <code>Ctrl + Z</code></li><li>重做    <code>Ctrl + Y</code></li></ul><h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</a></p></blockquote><p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net" target="_blank" rel="noopener">链接</a>等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 表格</span><br><span class="line"></span><br><span class="line">**Markdown　Extra**　表格语法：</span><br><span class="line"></span><br><span class="line">项目     | 价格</span><br><span class="line">-------- | ---</span><br><span class="line">Computer | $1600</span><br><span class="line">Phone    | $12</span><br><span class="line">Pipe     | $1</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>项目</th><th>价格</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可以使用冒号来定义对齐方式：</span><br><span class="line"></span><br><span class="line">| 项目      |    价格 | 数量  |</span><br><span class="line">| :-------- | --------:| :--: |</span><br><span class="line">| Computer  | 1600 元 |  5   |</span><br><span class="line">| Phone     |   12 元 |  12  |</span><br><span class="line">| Pipe      |    1 元 | 234  |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">1600 元</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">12 元</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">1 元</td><td style="text-align:center">234</td></tr></tbody></table><p>###定义列表</p><p><strong>Markdown　Extra</strong>　定义列表语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">项目１</span><br><span class="line">项目２</span><br><span class="line">:   定义 A</span><br><span class="line">:   定义 B</span><br><span class="line"></span><br><span class="line">项目３</span><br><span class="line">:   定义 C</span><br><span class="line"></span><br><span class="line">:   定义 D</span><br><span class="line"></span><br><span class="line">&gt; 定义D内容</span><br></pre></td></tr></table></figure><p>项目１<br>项目２<br>:   定义 A<br>:   定义 B</p><p>项目３<br>:   定义 C</p><p>:   定义 D</p><pre><code>&gt; 定义D内容</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><p>###脚注<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生成一个脚注[^footnote].</span><br><span class="line">[^footnote]: 这里是 **脚注** 的 *内容*.</span><br></pre></td></tr></table></figure></p><p>生成一个脚注[^footnote].<br> [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p><p>[TOC]</p><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用MathJax渲染*LaTex* 数学公式，详见[math.stackexchange.com][1].</span><br><span class="line"></span><br><span class="line"> - 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</span><br><span class="line"> - 块级公式：</span><br><span class="line"></span><br><span class="line">$$x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$</span><br></pre></td></tr></table></figure><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href="http://math.stackexchange.com/" target="_blank" rel="noopener">math.stackexchange.com</a>.</p><ul><li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li><li>块级公式：</li></ul><p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><p>`</p><p>更多LaTex语法请参考 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">这儿</a>.</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：<br><code>sequence张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure><p>或者流程图：</p><p>flow<br>st=&gt;start: 开始<br>e=&gt;end: 结束<br>op=&gt;operation: 我的操作<br>cond=&gt;condition: 确认？</p><p>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>序列图</strong> 语法，参考 <a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">这儿</a>,</li><li>关于 <strong>流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">这儿</a>.</li></ul><hr>]]></content>
      
      
        <tags>
            
            <tag> 实用知识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汉诺塔</title>
      <link href="/2018/06/27/%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
      <url>/2018/06/27/%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><h3 id="由来及传说"><a href="#由来及传说" class="headerlink" title="由来及传说"></a>由来及传说</h3><p>由来：法国数学家爱德华·卢卡斯曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。<br>不管这个传说的可信度有多大，如果考虑一下把64片金片，由一根针上移到另一根针上，并且始终保持上小下大的顺序。这需要多少次移动呢?这里需要递归的方法。假设有n片，移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7，且f(k+1)=2*f(k)+1。此后不难证明f(n)=2^n-1。n=64时，<br>假如每秒钟一次，共需多长时间呢？一个平年365天有31536000 秒，闰年366天有31622400秒，平均每年31556952秒，计算一下：<br>18446744073709551615秒<br>这表明移完这些金片需要5845.54亿年以上，而地球存在至今不过45亿年，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，不说太阳系和银河系，至少地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。</p><p>印度传说：和汉诺塔故事相似的，还有另外一个印度传说：舍罕王打算奖赏国际象棋的发明人──宰相西萨·班·达依尔。国王问他想要什么，他对国王说：“陛下，请您在这张棋盘的第1个小格里赏给我一粒麦子，在第2个小格里给2粒，第3个小格给4粒，以后每一小格都比前一小格加一倍。请您把这样摆满棋盘上所有64格的麦粒，都赏给您的仆人吧！”国王觉得这个要求太容易满足了，就命令给他这些麦粒。当人们把一袋一袋的麦子搬来开始计数时，国王才发现：就是把全印度甚至全世界的麦粒全拿来，也满足不了那位宰相的要求。<br>那么，宰相要求得到的麦粒到底有多少呢？总数为<br>1+2+2^2 + … +2^63=2^64-1<br>等于移完汉诺塔所需的步骤数。我们已经知道这个数字有多么大了。人们估计，全世界两千年也难以生产这么多麦子！    </p><h3 id="C语言汉诺塔的实现"><a href="#C语言汉诺塔的实现" class="headerlink" title="C语言汉诺塔的实现"></a>C语言汉诺塔的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="number">2</span> <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> form,<span class="keyword">char</span> to)</span>                                                                                                                   </span></span><br><span class="line"><span class="function">  3 </span>&#123;                                                                                                                                                    </span><br><span class="line">  <span class="number">4</span> <span class="built_in">printf</span>(<span class="string">"%d号盘从%c移到%c\n"</span>,n,form,to);                                                                                                              </span><br><span class="line">  <span class="number">5</span> &#125;                                                                                                                                                    </span><br><span class="line">  <span class="number">6</span>                                                                                                                                                      </span><br><span class="line">  <span class="number">7</span> <span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p1,<span class="keyword">int</span> p2,<span class="keyword">int</span> p3)</span>                                                                                                               </span></span><br><span class="line"><span class="function">  8 </span>&#123;                                                                                                                                                    </span><br><span class="line">  <span class="number">9</span>   <span class="keyword">if</span> (n==<span class="number">1</span>) &#123;                                                                                                                                        </span><br><span class="line"> <span class="number">10</span>     move(n,p1,p3);                                                                                                                                   </span><br><span class="line"> <span class="number">11</span>   &#125;                                                                                                                                                  </span><br><span class="line"> <span class="number">12</span>   <span class="keyword">else</span>&#123;                                                                                                                                              </span><br><span class="line"> <span class="number">13</span>     hanoi(n<span class="number">-1</span>,p1,p3,p2);                                                                                                                             </span><br><span class="line"> <span class="number">14</span>     move(n,p1,p3);                                                                                                                                   </span><br><span class="line"> <span class="number">15</span>     hanoi(n<span class="number">-1</span>,p2,p1,p3);                                                                                                                             </span><br><span class="line"> <span class="number">16</span>   &#125;                                                                                                                                                  </span><br><span class="line"> <span class="number">17</span> &#125;                                                                                                                                                    </span><br><span class="line"> <span class="number">18</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                                                                                                                                           </span></span><br><span class="line"><span class="function"> 19 </span>&#123;                                                                                                                                                    </span><br><span class="line"> <span class="number">20</span>   <span class="built_in">printf</span>(<span class="string">"请输入盘子的数量!\n"</span>);                                                                                                                     </span><br><span class="line"> <span class="number">21</span>   <span class="keyword">int</span> num=<span class="number">0</span>;                                                                                                                                         </span><br><span class="line"> <span class="number">22</span>   <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);                                                                                                                                  </span><br><span class="line"> <span class="number">23</span>   hanoi(num,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);                                                                                                                            </span><br><span class="line"> <span class="number">24</span>   <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                          </span><br><span class="line"> <span class="number">25</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E6%B1%89%E8%AF%BA%E5%A1%94.jpg" alt="这里写图片描述"><br><img src="http://pajznqooi.bkt.clouddn.com/%E6%B1%89%E8%AF%BA%E5%A1%941.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字符串中第一个只出现两次的字符</title>
      <link href="/2018/06/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/2018/06/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>找到字符串中第一个只出现两次的字符<br>例 字符串”abbcdefacdefba”<br>第一个只出现一次的字符是c</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>设置两个指针分别遍历数组<br>若指针1等于指针2则计数器加1，遍历完后若计数器为1则输出字符，并结束遍历</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findstr</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">char</span> tmp = <span class="string">'a'</span>;</span><br><span class="line"> <span class="keyword">char</span>*src = str+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (*str != <span class="string">'\0'</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> count = <span class="number">0</span>;</span><br><span class="line"> src = str+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (*src != <span class="string">'\0'</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (*str == *src)</span><br><span class="line"> &#123;</span><br><span class="line">   count++;</span><br><span class="line">   tmp = *src;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"> src++;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"找到字符是：%c\n"</span>,tmp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> str++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"没找到"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"abacdebaf"</span>;</span><br><span class="line">findstr(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%AD%97%E7%AC%A6.jpg" alt="这里写图片描述"><br><img src="http://pajznqooi.bkt.clouddn.com/%E5%AD%97%E7%AC%A62.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>选择排序</title>
      <link href="/2018/06/24/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/06/24/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>名词解释：选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>设置双重循环第一重循环从数组第一个元素开始，第二重循环从数组第二个元素开始，然后找出第二重循环中小于第一重循环的最小数，然后与第一重循环的首元素之交换。<br>图解：<br><img src="http://pajznqooi.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="这里写图片描述"></p><h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h3><p>时间复杂度：<code>O（n2)</code><br>空间复杂度：<code>O(1)</code><br>算法稳定性：不稳定算法</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selectionsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max; <span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">max = i;</span><br><span class="line"><span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; size; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[max]&gt;arr[j])</span><br><span class="line"></span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i != max)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">arr[i] = arr[max];</span><br><span class="line">arr[max] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">30</span>,<span class="number">300</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">Selectionsort(<span class="built_in">array</span>,num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基数排序</title>
      <link href="/2018/06/23/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/06/23/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>名词解释：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。<br>历史渊源：基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机(Tabulation Machine)上的贡献。它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。<br>排序步骤：<br>第一步<br>以LSD为例，假设原来有一串数值如下所示：<br>73, 22, 93, 43, 55, 14, 28, 65, 39, 81<br>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：<br>0<br>1 81<br>2 22<br>3 73 93 43<br>4 14<br>5 55 65<br>6<br>7<br>8 28<br>9 39<br>第二步<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39<br>接着再进行一次分配，这次是根据十位数来分配：<br>0<br>1 14<br>2 22 28<br>3 39<br>4 43<br>5 55<br>6 65<br>7 73<br>8 81<br>9 93<br>第三步<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。<br>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</p><p>图解：<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png" alt="这里写图片描述"></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>时间效率 ：设待排序列为n个记录，d个关键码，关键码的取值范围为radix，则进行链式基数排序的时间复杂度为<code>O(d(n+radix))</code>，其中，一趟分配时间复杂度为<code>O(n)</code>，一趟收集时间复杂度为<code>O(radix)</code>，共进行d趟分配和收集。<br>空间效率：需要<code>2*radix</code>个指向队列的辅助空间，以及用于静态链表的n个指针故为<code>O(2*radix)</code></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Maxbit</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>; <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (arr[i]&gt;p)</span><br><span class="line">&#123;</span><br><span class="line">p *= <span class="number">10</span>;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = Maxbit(arr, num);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *tmp = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line"><span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">count[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">&#123;</span><br><span class="line">k = (arr[j] / index) % <span class="number">10</span>;</span><br><span class="line">count[k]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">count[j] = count[j - <span class="number">1</span>] + count[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = num - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">k = (arr[j] / index) % <span class="number">10</span>;</span><br><span class="line">tmp[count[k] - <span class="number">1</span>] = arr[j];</span><br><span class="line">count[k]--;</span><br><span class="line">&#125;</span><br><span class="line">index *= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">&#123;</span><br><span class="line">arr[j] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] tmp;</span><br><span class="line"><span class="keyword">delete</span>[] count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">30</span>,<span class="number">300</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">bucketsort(<span class="built_in">array</span>,num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>归并排序</title>
      <link href="/2018/06/21/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/06/21/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="归并排序（Mergesort"><a href="#归并排序（Mergesort" class="headerlink" title="归并排序（Mergesort)"></a>归并排序（Mergesort)</h3><p>名词解释 ：归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>归并排序采用分而治之思想将数组内容划分成许多个单位，使每个单位内序列为有序再合并各个有序的序列。<br>图解如下：<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F1.png" alt="这里写图片描述"></p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述:"></a>算法描述:</h3><p>时间复杂度:<code>O(n log n)</code><br>空间复杂度:<code>O（n)</code><br>算法稳定性：稳定</p><p>算法实现步骤：<br>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。<br>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置。<br>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。<br>重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>实现归并排序首先要实现两个有序数组的合并：<br>算法如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemeryArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> b[], <span class="keyword">int</span> m, <span class="keyword">int</span> c[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j, k;  </span><br><span class="line"></span><br><span class="line">    i = j = k = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; b[j])  </span><br><span class="line">            c[k++] = a[i++];  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            c[k++] = b[j++];   </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)  </span><br><span class="line">        c[k++] = a[i++];  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m)  </span><br><span class="line">        c[k++] = b[j++];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了合并以后就完成了算法的主体，全部实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergetarr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> tmp[])</span><span class="comment">//合并算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line">i = left; k = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">j = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=right )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i]&lt;=arr[j])</span><br><span class="line">&#123;</span><br><span class="line">tmp[k++]=arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">tmp[k++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j&lt;=right)</span><br><span class="line">&#123;</span><br><span class="line">tmp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">arr[left + i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">mergetsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right,<span class="keyword">int</span> tmp[])</span><span class="comment">//归并排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left&lt;right )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">mergetsort(arr,left,mid,tmp);<span class="comment">//左边归并</span></span><br><span class="line">mergetsort(arr, mid+<span class="number">1</span>, right,tmp);<span class="comment">//右边归并</span></span><br><span class="line">mergetarr(arr, left, right, tmp);<span class="comment">//合并左右</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">13</span>,<span class="number">25</span>,<span class="number">14</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">89</span>,<span class="number">56</span>,<span class="number">14</span>,<span class="number">25</span>,<span class="number">58</span>,<span class="number">78</span>,<span class="number">36</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">22</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">mergetsort(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>])<span class="number">-1</span>,p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法的稳定性</title>
      <link href="/2018/06/21/%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
      <url>/2018/06/21/%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>名词解释：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。</p><h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><p>对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。<br>举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n &amp;&amp; flag == <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt;arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;                             </span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">temp = a[j];</span><br><span class="line">a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">a[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*此算法本来是稳定的但是如果将判断条件改为a[j].key &gt;=a[j+1].key，</span></span><br><span class="line"><span class="comment">则会影响原来数值相同数据的的位置，就会变成不稳定的排序方法*/</span></span><br></pre></td></tr></table></figure></p><h3 id="常见算法的稳定性分析"><a href="#常见算法的稳定性分析" class="headerlink" title="常见算法的稳定性分析"></a>常见算法的稳定性分析</h3><p>堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。</p><p>其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就 是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。</p><p>八大排序分析：<br>(1)冒泡排序<br>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无 聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。<br>(2)选择排序<br>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。<br>(3)插入排序<br>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。<br>(4)快速排序<br>快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。<br>(5)归并排序<br>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。<br>(6)基数排序<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。<br>(7)希尔排序(shell)<br>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。<br>(8)堆排序<br>我们知道堆的结构是节点i的孩子为2<em>i和2</em>i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p><h3 id="稳定性的意义"><a href="#稳定性的意义" class="headerlink" title="稳定性的意义"></a>稳定性的意义</h3><p>不需要用到稳定性： 如果只是简单的进行数字的排序，那么稳定性将毫无意义，如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧将毫无意义，如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧将毫无意义。</p><p>需要用到稳定性： 排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法，例如要排序的内容是一组原本按照价格高低排序的货物，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的货物依旧保持着价格高低的排序，只有销量不同的才会重新排序，因此如果需求不需要保持初始的排序意义，那么使用稳定性算法和不稳定算法是一样的。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>希尔排序</title>
      <link href="/2018/06/20/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/06/20/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="希尔排序（Shell’s-Sort"><a href="#希尔排序（Shell’s-Sort" class="headerlink" title="希尔排序（Shell’s Sort)"></a>希尔排序（Shell’s Sort)</h3><p>名词解释：希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>1.插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。<br>2.但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>教科书表达：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2(小于d1）重复上述的分组和排序，直至所取的增量 =1(  &lt;  …&lt; &lt; d2 &lt; d1)，即所有记录放在同一组中进行直接插入排序为止。<br>简单来说：一个书架放着一排书，现在从第一本书起每数X本书，就在那本书上贴红色贴纸，贴完红色贴纸后，再次从第二本书起每数X本书就贴上蓝色贴纸（跟之前颜色不同即可），重复贴纸过程，直到所有书都贴满贴纸。接着对有相同颜色贴纸的书做插入排序。然后撕掉所有贴纸后重新对书进行贴纸，这次则每数Y本书就贴纸（Y &lt; X）,所有书贴满后再进行插入排序。重复贴纸排序、贴纸排序这个过程，直到最后每数1本书就贴纸（也就是每本书都贴同样颜色贴纸），再插入排序为止。<br>话不多说，看图<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt="这里写图片描述"></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>稳定性：由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。<br>时间复杂度：<code>O(n^2)</code><br>空间复杂度：<code>O(1)</code></p><p>常见排序算法一般按平均时间复杂度分为两类：<br><code>O(n^2)</code>：冒泡排序、选择排序、插入排序<br><code>O(nlogn)</code>：归并排序、快速排序、堆排序<br>1w和10w数据效率如下：</p><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F3.png" alt="这里写代码片"></p><h3 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h3><p>正如我们所知道的希尔排序的增量序列是影响希尔排序效率的最关键因素，至今为止还没有一个最完美的增量序列公式。可究竟应该选取什么样的增量才是最好，目前还是一个数学难题。<br>看如下两个增量序列：<br>n/2、n/4、n/8…1<br>1、3、7…2^k-1<br>第一个序列称为希尔增量序列，使用希尔增量时，希尔排序在最坏情况下的时间复杂度为O(n*n)。<br>第二个序列称为Hibbard增量序列，使用Hibbard增量时，希尔排序在最坏情况下的时间复杂度为O(n^3/2)。　<br>10w数据对比如下图：<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F4.png" alt="这里写图片描述"></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> size)</span><span class="comment">//希尔排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size&lt;=<span class="number">0</span>||arr==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> div = <span class="number">0</span>; <span class="keyword">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (div = size / <span class="number">2</span>; div &gt;= <span class="number">1</span>; div /= <span class="number">2</span>)<span class="comment">//定义增量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; div; i++)<span class="comment">//分成div组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; size; j += div)<span class="comment">//对数据插入排序</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (k = i; k &lt; size - div; k += div)&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[k])</span><br><span class="line">&#123;</span><br><span class="line">swap(arr[j], arr[k]);<span class="comment">//交换数据的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">13</span>,<span class="number">25</span>,<span class="number">14</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">22</span>&#125;;</span><br><span class="line">shellsort(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]));</span><br><span class="line"><span class="comment">/*for (auto it: array)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; it;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>堆排序</title>
      <link href="/2018/06/18/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/06/18/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="堆排序（-Heap-Sort"><a href="#堆排序（-Heap-Sort" class="headerlink" title="堆排序（ Heap Sort )"></a>堆排序（ Heap Sort )</h3><p>堆排序要用到堆，那什么是堆呢？可以参考我的一博客<a href="https://blog.csdn.net/weibo_dm/article/details/80718839" target="_blank" rel="noopener">什么是堆？</a></p><p>名词解释：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd）和威廉姆斯(J．Williams）在1964年共同发明了著名的堆排序算法。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用Heapify实现的。<br>平均性能：<code>O(N*logN)</code></p><p>其他性能:由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。<br>堆排序是就地排序，辅助空间为O(1)。<br>堆排序是不稳定的排序方法（当数组中有相等元素时，堆排序算法对这些元素的处理方法不止一种）。（排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前 和排序后他们的相对位置不发生变化）。</p><h3 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h3><p>1.将无序序列构建成一个堆，根据升序降序需求选择大顶堆（升序）或小顶堆（降序）。<br>2.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端。<br>3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p><p>将堆化为数组：<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F.jpg" alt="这里写图片描述"></p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span><span class="comment">//调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> maxIdx = index;</span><br><span class="line"><span class="keyword">if</span> (left&lt;len &amp;&amp; arr[left] &gt; arr[maxIdx]) maxIdx = left;</span><br><span class="line"><span class="keyword">if</span> (right&lt;len &amp;&amp; arr[right] &gt; arr[maxIdx]) maxIdx = right;  <span class="comment">// maxIdx是3个数中最大数的下标</span></span><br><span class="line"><span class="keyword">if</span> (maxIdx != index)                 <span class="comment">// 如果maxidx被更新</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[maxIdx], arr[index]);<span class="comment">//交换</span></span><br><span class="line">adjust(arr, len, maxIdx);       <span class="comment">// 递归调整其他不满足堆性质的部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span><span class="comment">//堆排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="comment">// 对每一个非叶结点进行堆调整(从最后一个非叶结点开始)</span></span><br><span class="line">&#123;</span><br><span class="line">adjust(arr, size, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">swap(arr[<span class="number">0</span>], arr[i]);           <span class="comment">// 将当前最大的放置到数组末尾</span></span><br><span class="line">adjust(arr, i, <span class="number">0</span>);              <span class="comment">// 将未完成排序的部分继续进行堆排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">8</span>] = &#123; <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span> &#125;;</span><br><span class="line">heapSort(<span class="built_in">array</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">/*for (auto it: array)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; it;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>什么是堆</title>
      <link href="/2018/06/17/%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86/"/>
      <url>/2018/06/17/%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h2><p>堆是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。<br>堆的性质：<br>1.堆中某个节点的值总是不大于或不小于其父节点的值。<br>2.堆总是一棵完全二叉树。</p><h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><p>将根节点最大的堆叫做最大堆或大顶堆，根节点最小的堆叫做最小堆或小顶堆。常见的堆有二叉堆、斐波那契堆等。<br>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。<br>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)<br>若将和此次序列对应的一维数组（即以一维数组作此序列的存储结构）看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。由此，若序列{k1,k2,…,kn}是堆，则堆顶元素（或完全二叉树的根）必为序列中n个元素的最小值（或最大值）。<br>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：<br>大堆：<br><img src="http://pajznqooi.bkt.clouddn.com/2.jpg" alt="网络故障"><br>小堆：<br><img src="http://pajznqooi.bkt.clouddn.com/3.jpg" alt="网络故障"></p><h2 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h2><p>build:建立一个空堆；<br>insert:向堆中插入一个新元素；<br>update：将新元素提升使其符合堆的性质；<br>get：获取当前堆顶元素的值；<br>delete：删除堆顶元素；<br>heapify：使删除堆顶元素的堆再次成为堆。<br>某些堆实现还支持其他的一些操作，如斐波那契堆支持检查一个堆中是否存在某个元素。</p><h2 id="建堆效率"><a href="#建堆效率" class="headerlink" title="建堆效率"></a>建堆效率</h2><p>n个结点的堆，高度d =log2n。根为第0层，则第i层结点个数为2i，考虑一个元素在堆中向下移动的距离。大约一半的结点深度为d-1，不移动（叶）。四分之一的结点深度为d-2，而它们至多能向下移动一层。树中每向上一层，结点的数目为前一层的一半，而子树高度加一。<br>这种算法时间代价为Ο（n)由于堆有log n层深，插入结点、删除普通元素和删除最小元素的平均时间代价和时间复杂度都是Ο（log n）。</p><h2 id="关于堆的操作实现"><a href="#关于堆的操作实现" class="headerlink" title="关于堆的操作实现"></a>关于堆的操作实现</h2><p>在程序中，堆用于动态分配和释放程序所使用的对象。在以下情况中调用堆操作：<br>1.事先不知道程序所需对象的数量和大小。<br>2.对象太大，不适合使用堆栈分配器。<br>堆使用运行期间分配给代码和堆栈以外的部分内存。<br>传统上，操作系统和运行时库随附了堆实现。当进程开始时，操作系统创建称为进程堆的默认堆。如果没有使用其他堆，则使用进程堆分配块。语言运行时库也可在一个进程内创建单独的堆。（例如，C 运行时库创建自己的堆。）除这些专用堆外，应用程序或许多加载的动态链接库 (DLL) 之一也可以创建并使用单独的堆。Win32 提供了一组丰富的 API用于创建和使用专用堆。有关堆函数的优秀教程，请参阅 MSDN 平台 SDK 节点。<br>当应用程序或 DLL 创建专用堆时，这些堆驻留于进程空间中并且在进程范围内是可访问的。某一给定堆分配的任何数据应为同一堆所释放。（从一个堆分配并释放给另一个堆没有意义。）<br>在所有虚拟内存系统中，堆位于操作系统的虚拟内存管理器之上。语言运行时堆也驻留在虚拟内存之上。某些情况下，这些堆在操作系统堆的上层，但语言运行时堆通过分配大的块来执行自己的内存管理。绕开操作系统堆来使用虚拟内存函数可使堆更好地分配和使用块。<br>典型的堆实现由前端分配器和后端分配器组成。前端分配器维护固定大小块的自由列表。当堆收到分配调用后，它尝试从前端列表中查找自由块。如果此操作失败，则堆将被迫从后端（保留和提交虚拟内存）分配一个大块来满足请求。通常的实现具有每个块分配的开销，这花费了执行周期，也减少了可用存储区。<br>单个全局锁可防止多线程同时使用堆。此锁主要用于保护堆数据结构不受多线程的任意访问。当堆操作过于频繁时，此锁会对性能造成负面影响。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">JBMinHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//申请堆空间</span></span><br><span class="line">    T *_minHeap = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> _index,_maxSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    JBMinHeap(<span class="keyword">int</span> maxSize) &#123;</span><br><span class="line">        _maxSize = maxSize;</span><br><span class="line">        _minHeap = <span class="keyword">new</span> T[_maxSize];</span><br><span class="line">        _index = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    JBMinHeap(JBMinHeap &amp;h) &#123;</span><br><span class="line">        _index = h._index;</span><br><span class="line">        _maxSize = h._maxSize;</span><br><span class="line">        _minHeap = <span class="keyword">new</span> T[_maxSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;_maxSize) &#123;</span><br><span class="line">            *_minHeap[i] = *h._minHeap[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~JBMinHeap() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[]_minHeap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取整个最小堆的头部指针</span></span><br><span class="line">    <span class="function">T * <span class="title">getMinHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _minHeap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断堆是不是空的</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _index == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _index++;</span><br><span class="line">        _minHeap[_index] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _index == _maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//堆进行向下调整</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="comment">//队进行向上调整</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjustUp</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="comment">//建堆运算</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMinHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (_index<span class="number">-1</span>)/<span class="number">2</span>;i &gt;<span class="number">-1</span>;i--) &#123;<span class="comment">//直接从倒数第二层 逐层向下调整</span></span><br><span class="line">            adjustDown(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">JBMinHeap</span>&lt;T&gt;:</span>:adjustDown(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index&lt;_index)</span><br><span class="line">    &#123;</span><br><span class="line">        T temp = _minHeap[index];<span class="comment">//将当前索引的位置的值保存下来</span></span><br><span class="line">        <span class="keyword">int</span> oneC = <span class="number">2</span> * index + <span class="number">1</span>;<span class="comment">//获取到两个孩子的位置</span></span><br><span class="line">        <span class="keyword">int</span> twoC = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (oneC == _index) &#123;<span class="comment">//若第一个孩子是整个堆最后一个位置 则直接执行交换操作并结束执行</span></span><br><span class="line">                _minHeap[index] = _minHeap[oneC];</span><br><span class="line">                _minHeap[oneC] = temp;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (twoC &gt;_index) &#123;<span class="comment">//如果第二个孩子的索引位置越界 结束执行</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_minHeap[oneC] &lt;= _minHeap[twoC]) &#123;<span class="comment">//正常情况的数据交互执行</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt; _minHeap[oneC]) &#123;</span><br><span class="line">                _minHeap[index] = _minHeap[oneC];</span><br><span class="line">                _minHeap[oneC] = temp;</span><br><span class="line">                index = oneC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//如果该处索引值已经是比两个孩子小 则结束循环</span></span><br><span class="line">                index = _index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; _minHeap[twoC]) &#123;</span><br><span class="line">                _minHeap[index] = _minHeap[twoC];</span><br><span class="line">                _minHeap[twoC] = temp;</span><br><span class="line">                index = twoC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                index = _index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">JBMinHeap</span>&lt;T&gt;:</span>:adjustUp(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; _index) &#123;<span class="comment">//大于堆的最大值直接return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index&gt;<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T temp = _minHeap[index];</span><br><span class="line">        <span class="keyword">int</span> father = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (father &gt;= <span class="number">0</span>) &#123;<span class="comment">//若果索引没有出界就执行想要的操作</span></span><br><span class="line">            <span class="keyword">if</span> (temp &lt; _minHeap[father]) &#123;</span><br><span class="line">                _minHeap[index] = _minHeap[father];</span><br><span class="line">                _minHeap[father] = temp;</span><br><span class="line">                index=father;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//若果已经是比父亲大 则直接结束循环</span></span><br><span class="line">                index = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//出界就结束循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>空间复杂度</title>
      <link href="/2018/06/15/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2018/06/15/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>  前面刚讲了时间复杂度，有兴趣的去看看<a href="https://blog.csdn.net/weibo_dm/article/details/80710491" target="_blank" rel="noopener">什么是时间复杂度？</a><br>名词解释：空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。</p><h3 id="度量方法"><a href="#度量方法" class="headerlink" title="度量方法"></a>度量方法</h3><p> 类似于 时间复杂度的讨论，一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。空间复杂度(SpaceComplexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\”进行的，是节省存储的算法，有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。</p><h3 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h3><p>分析一个算法所占用的存储空间要从各方面综合考虑。如对于递归算法来说，一般都比较简短，算法本身所占用的存储空间较少，但运行时需要一个附加堆栈，从而占用较多的临时工作单元；若写成非递归算法，一般可能比较长，算法本身占用的存储空间较多，但运行时将可能需要较少的存储单元。<br>一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。若一个算法为 [2]  递归算法，其空间复杂度为递归所使用的堆栈空间的大小，它等于一次调用所分配的临时存储空间的大小乘以被调用的次数(即为递归调用的次数加1，这个1表示开始进行的一次非递归调用)。算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)；当一个算法的空间复杂度与n成线性比例关系时，可表示为O(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。<br>故一个算的空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。所以它强调的是使用的辅助空间的的大小，而不是指所有的数据所占用的空间。<br>以斐波那契算法为例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>* <span class="title">fib</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    assert(n&gt;=<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>* ptr=<span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[n+<span class="number">1</span>];  </span><br><span class="line">    ptr[<span class="number">0</span>]=<span class="number">0</span>;  </span><br><span class="line">    ptr[<span class="number">1</span>]=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        ptr[i]=ptr[i<span class="number">-1</span>]+ptr[i<span class="number">-2</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ptr;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/*对于这种算法，函数真正执行次数为n-1,所以忽略常数后，时间复杂度为O(n);</span></span><br><span class="line"><span class="comment">因为开辟了n+1个空间，有n+1个辅助空间，所以空间复杂度为O(n).*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    assert(n&gt;=<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> first=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> second=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        ret=first+second;  </span><br><span class="line">        first=second;  </span><br><span class="line">        second=ret;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/*这是非递归的另一种算法，函数真正执行次数依然为n-1,所以忽略常数后，时间复杂度还是O(n);</span></span><br><span class="line"><span class="comment">由于采用变量交换的方式，所以在这里辅助空间个数为一个常数，空间复杂度为O(1).*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    assert(n&gt;=<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> (n&lt;<span class="number">2</span>)?(n):(fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>));  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/*递归算法的时间复杂度计算方法是:递归总次数*每次递归次数；</span></span><br><span class="line"><span class="comment">递归算法的时间复杂度计算方法是：递归深度*每次递归所需的辅助空间个数.</span></span><br><span class="line"><span class="comment">可以得出斐波那契递归算法时间复杂度：O（2^N），空间复杂度为:O(N)*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value=fib(<span class="number">15</span>);  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; value &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    system(<span class="string">"pause"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度与空间复杂度的联系"><a href="#时间复杂度与空间复杂度的联系" class="headerlink" title="时间复杂度与空间复杂度的联系"></a>时间复杂度与空间复杂度的联系</h3><p>对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。算法的时间复杂度和空间复杂度合称为算法的复杂度。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2018/06/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2018/06/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>算法复杂度分为时间复杂度和空间复杂度。其作用： 时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。（算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度）。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。</p><h3 id="时间复杂度计算方法"><a href="#时间复杂度计算方法" class="headerlink" title="时间复杂度计算方法"></a>时间复杂度计算方法</h3><p>1.一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。<br>分析：随着模块n的增大，算法执行的时间的增长率和 f(n) 的增长率成正比，所以 f(n) 越小，算法的时间复杂度越低，算法的效率越高。<br>2.在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级（它的同数量级有以下：1，log2n，n，n log2n ，n的平方，n的三次方，2的n次方，n!），找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数c，则时间复杂度T(n) = O(f(n))。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>循环如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">for(i=1; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    for(j=1; j&lt;=n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][j] = 0;//该步骤属于基本操作执行次数：n的平方次</span><br><span class="line">        for(k=1; k&lt;=n; ++k)</span><br><span class="line">        c[i][j] += a[i][k] * b[k][j];//该步骤属于基本操作执行次数：n的三次方次</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//则有，根据上面括号里的同数量级，我们可以确定n的三次方为T（n）的同数量级。</span><br><span class="line">//则有，然后根据 T(n)/f(n) 求极限可得到常数c。</span><br><span class="line">//则该算法的时间复杂度：T(n) = O(n^3) 注：n^3即是n的3次方。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例2</span><br><span class="line">//如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，</span><br><span class="line">//则将并列循环的时间复杂度相加。</span><br><span class="line"></span><br><span class="line">　　for (i=1; i&lt;=n; i++)</span><br><span class="line">　　&#123;</span><br><span class="line">　　x++;</span><br><span class="line">　　&#125;</span><br><span class="line">　　for (i=1; i&lt;=n; i++)</span><br><span class="line">　　&#123;</span><br><span class="line">　　for (j=1; j&lt;=n; j++)</span><br><span class="line">　　&#123;</span><br><span class="line">　　x++;</span><br><span class="line">　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　//第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，</span><br><span class="line">　　//则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。</span><br></pre></td></tr></table></figure></p><p>常见的算法时间复杂度由小到大依次为：<br>Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。Ο(log2n)、Ο(n)、Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者是有效算法，把这类问题称为P类问题，而把后者称为NP问题。但这也只能计算基本的计算时间复杂度，具体的运行还会与硬件有关。</p>]]></content>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql基本操作</title>
      <link href="/2018/06/13/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/06/13/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="Mysql安装"><a href="#Mysql安装" class="headerlink" title="Mysql安装"></a>Mysql安装</h3><p>mysql 是一个小型的数据库<br>安装过程参考：<a href="http://blog.51cto.com/aiilive/2116476" target="_blank" rel="noopener">MySQL安装过程</a><br>1.首先登入数据库（在cmd窗口进行操作）<br>输入：<figure class="highlight plain"><figcaption><span>-u root -p```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![这里写图片描述](https://img-blog.csdn.net/20180613225925564?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line"></span><br><span class="line">2.建立一个数据库</span><br><span class="line">```create datebase  lala；(数据库名，可以根据实际项目取名）</span><br></pre></td></tr></table></figure></p><p>2.使用本数据库<br><figure class="highlight plain"><figcaption><span>table1；```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入此条语句数据库才能进行操作</span><br><span class="line">4.数据库的增删改查操作</span><br></pre></td></tr></table></figure></p><p>增：insert into table(表名） value（);（“()”中数据类型与表单的元素一一对应）<br>删：delete from table where la=1;<br>改：update table set la=1 where dada=”haha”;<br>查：select *(显示全部符号，也可以指定显示内容如dada） from table;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5.删除表</span><br><span class="line">```drop table tb1;</span><br></pre></td></tr></table></figure></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>1.空值与非空约束<br><figure class="highlight plain"><figcaption><span>table tb2 (user_name not null,user_age null);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2.自增约束</span><br><span class="line">自动编号 起始为1</span><br><span class="line">自动编号的字段必须设置为主键（primary key）</span><br><span class="line">例如create table tb2 (user_name auto_increment primary key);</span><br><span class="line">auto_increment 必须定义为主键  而主键不一定要是auto increment  </span><br><span class="line">3.主键约束primary key</span><br><span class="line">主键必须为not null</span><br><span class="line">主键会保证唯一性</span><br><span class="line">4.唯一约束</span><br><span class="line">unique key 保证唯一性</span><br><span class="line">### 数据表列操作</span><br></pre></td></tr></table></figure></p><p>1.添加列<br>alter tbale tb1 column a varchar;<br>新增列名为a的字段<br>2.删除列<br>alter table tb1 column x;<br>删除列名为x的字段<br>3.查询表中的所有列名<br> show columns from 表名;<br>ex:show columns from tb1;<br>4.调整字段的位置(first,last)<br>  alter table tb1 modify  y int first;<br>将该字段放到最前面去了；<br>5.修改字段的数据类型<br>alter table tb1 modify x  smallint;<br>由大类型改到小类型可能会造成数据的丢失；<br>6.修改字段的名称<br>alter table tb1  change  x  xx int;<br>将x字段更名为xx字段，其类型为int 型<br>该语句修改数据表中字段的名称和数据类型<br>7.查看表中的所有列<br>show columns from tb1;<br>8.输出所有列<br>select <em>  from tb1;<br>select </em> from tb1\G  以网格形式输出所有列<br><code>`</code></p>]]></content>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>翻转字符串</title>
      <link href="/2018/06/11/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/06/11/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入：i am a student.<br>输出：student.a am i</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先总体反转，然后逐个单词反转，首先，将字符串完全翻转一次，得到.tneduts a ma i。然后设置两个指针，对单词进行翻转，也就是局部翻转.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllReverse</span><span class="params">(<span class="keyword">char</span> *pStart, <span class="keyword">char</span> *pEnd)</span><span class="comment">//全反转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> pTemp;</span><br><span class="line"><span class="keyword">if</span> (pStart == <span class="literal">NULL</span> || pEnd == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pStart &lt; pEnd)</span><br><span class="line">&#123;</span><br><span class="line">pTemp = *pStart;</span><br><span class="line">*pStart = *pEnd;</span><br><span class="line">*pEnd = pTemp;</span><br><span class="line"></span><br><span class="line">pStart++;</span><br><span class="line">pEnd--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> *pData)</span><span class="comment">//单词反转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pData == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *pStart = pData;</span><br><span class="line"><span class="keyword">char</span> *pEnd = pData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*pEnd != <span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line">pEnd++;</span><br><span class="line">&#125;</span><br><span class="line">pEnd--;</span><br><span class="line"></span><br><span class="line">AllReverse(pStart, pEnd);<span class="comment">//全反转</span></span><br><span class="line"></span><br><span class="line">pStart = pEnd = pData;</span><br><span class="line"><span class="keyword">while</span> (*pStart != <span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*pStart == <span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line">pStart++;</span><br><span class="line">pEnd++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*pEnd == <span class="string">' '</span> || *pEnd == <span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line">AllReverse(pStart, --pEnd);</span><br><span class="line">pStart = ++pEnd;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pEnd++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">// 主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a_arr[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> * str = <span class="literal">NULL</span>;</span><br><span class="line">gets_s(a_arr);</span><br><span class="line">str = Reverse(a_arr);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://img-blog.csdn.net/20180611233045464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>找到数组第一个相同的数</title>
      <link href="/2018/06/06/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0/"/>
      <url>/2018/06/06/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组，然找到数组里第一个重复的数字。<br>例：<br>   arr[]={1,2,4,3,6,5,6,5,8,9}<br>找到5。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checknum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> key = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">  &#123;</span><br><span class="line">  key = arr[j];</span><br><span class="line">  <span class="keyword">for</span> (i = j + <span class="number">1</span>; i &lt; num; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] == key)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"该数组有重复数字,数字是："</span> &lt;&lt; key &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"没有重复的数字"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">  checknum(arr, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://img-blog.csdn.net/20180608171059770?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>寻找两个链表公共节点</title>
      <link href="/2018/06/06/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
      <url>/2018/06/06/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>两个单向链表，找出它们的第一个公共结点。<br>数据类型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果两个单向链表有公共的结点，也就是说两个链表从某一结点开始，它们的Next都指向同一个结点。但由于是单向链表的结点，每个结点只有一个Next，因此从第一个公共结点开始，之后它们所有结点都是重合的，不可能再出现分叉。所以，两个有公共结点而部分重合的链表，拓扑形状看起来像一个Y，而不可能像X。<br>看到这个题目，第一反应就是蛮力法：在第一链表上顺序遍历每个结点。每遍历一个结点的时候，在第二个链表上顺序遍历每个结点。如果此时两个链表上的结点是一样的，说明此时两个链表重合，于是找到了它们的公共结点。如果第一个链表的长度为m，第二个链表的长度为n，显然，该方法的时间复杂度为O(mn)。<br>接 下来我们试着去寻找一个线性时间复杂度的算法。我们先把问题简化：如何判断两个单向链表有没有公共结点？前面已经提到，如果两个链表有一个公共结点，那么 该公共结点之后的所有结点都是重合的。那么，它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分，只要分别遍历两个链表到最后一 个结点。如果两个尾结点是一样的，说明它们用重合；否则两个链表没有公共的结点。<br>在上面的思路中，顺序遍历两个链表到尾结点的时候，我们不能保证在两个链表上同时到达尾结点。这是因为两个链表不一定长度一样。但如果假设一个链表比另一个长l个结点，我们先在长的链表上遍历l个结点，之后再同步遍历，这个时候我们就能保证同时到达最后一个结点了。由于两个链表从第一个公共结点考试到链表的尾结点，这一部分是重合的。因此，它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。在这个思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历若干次之后，再同步遍历两个链表，知道找到相同的结点，或者一直到链表结束。此时，如果第一个链表的长度为m，第二个链表的长度为n，该方法的时间复杂度为O(m+n)。</p><p>基于这个思路，我们不难写出如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>//数据结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">findnode</span><span class="params">(Node* head, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">init_list</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//初始化链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"链表数目个数有问题"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入 "</span> &lt;&lt; n &lt;&lt; <span class="string">"个数据"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n-- &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Node* ptr = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ptr-&gt;data;</span><br><span class="line">ptr-&gt;next = head;</span><br><span class="line">head = ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(Node *head)</span><span class="comment">//打印链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"这是一个空链表"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; head-&gt;data &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">sort_list</span><span class="params">(Node* head)</span><span class="comment">//遍历链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"链表为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (head)</span><br><span class="line">&#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">findnode</span><span class="params">(Node* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* ptr = head;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line">ptr = ptr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindFirstCommonNode</span><span class="params">(Node* head1, Node* head2)</span><span class="comment">//寻找公共节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(head1);</span><br><span class="line">assert(head2);</span><br><span class="line"><span class="keyword">int</span> len1 = sort_list(head1);</span><br><span class="line"><span class="keyword">int</span> len2 = sort_list(head2);</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (len1 &gt; len2)</span><br><span class="line">&#123;</span><br><span class="line">tmp = len1 - len2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp; i++)</span><br><span class="line">&#123;</span><br><span class="line">head1 = head1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = len2 - len1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp; i++)</span><br><span class="line">&#123;</span><br><span class="line">head2 = head2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((head1 != <span class="literal">NULL</span>) &amp;&amp; (head2 != <span class="literal">NULL</span>) &amp;&amp; (head1 != head2))</span><br><span class="line">&#123;</span><br><span class="line">head1 = head1-&gt;next;</span><br><span class="line">head2 = head2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">Node* key = head1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"公共节点为"</span> &lt;&lt; key-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你想要创建的链表节点个数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">Node* ptr = init_list(n);</span><br><span class="line">show(ptr);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你想要创建的链表节点个数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">Node* ptr1 = init_list(m);</span><br><span class="line">findnode(ptr1,m<span class="number">-1</span>)-&gt;next = findnode(ptr, <span class="number">3</span>);</span><br><span class="line">show(ptr1);</span><br><span class="line">FindFirstCommonNode(ptr, ptr1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p><img src="https://img-blog.csdn.net/20180609235020561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言注释转C++注释</title>
      <link href="/2018/06/04/C%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A%E8%BD%ACC++%E6%B3%A8%E9%87%8A/"/>
      <url>/2018/06/04/C%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A%E8%BD%ACC++%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>int a = 10;<br>// 1.一般情况<br>int num = 0;<br>/_ int i = 0; _/</p><p>// 2.换行问题<br>/_ int i = 0; <em>/int j = 0;<br>/</em> int i = 0; _/<br>int j = 0;</p><p>// 3.匹配问题<br>/_int i = 0;/_xxxxx*/</p><p>// 4.多行注释问题<br>/_<br>int i=0;<br>int j = 0;<br>int k = 0;<br>_/int k = 0;</p><p>// 5.连续注释问题<br>/<em>int a=0;</em>//<em>int b=0;</em>/</p><p>// 6.连续的<strong>/问题<br>/*</strong>/</p><p>// 7.C++注释问题<br>// /<em>xxxxxxxxxxxx</em>/</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p><img src="http://img.blog.csdn.net/20170914173237582?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpYm9fZG0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="分析图"></p><h2 id="代码片"><a href="#代码片" class="headerlink" title="代码片"></a>代码片</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMMENTCONVERT_HEADFILE__   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMMENTCONVERT_HEADFILE__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">enum</span> STATE    </span><br><span class="line">&#123;</span><br><span class="line">NUL,</span><br><span class="line">C,</span><br><span class="line">CPP,</span><br><span class="line">END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CommentConvert</span><span class="params">(FILE *pfin, FILE * pfout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoNULConvert</span><span class="params">(FILE *pfin, FILE * pfout, <span class="keyword">enum</span> STATE * state)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoCConvert</span><span class="params">(FILE *pfin, FILE * pfout, <span class="keyword">enum</span> STATE * state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoCPPConvert</span><span class="params">(FILE *pfin, FILE * pfout, <span class="keyword">enum</span> STATE * state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"标头.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CommentConvert</span><span class="params">(FILE *pfin, FILE * pfout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">enum</span> STATE state = NUL;<span class="comment">//初始化状态 为   无注释状态  </span></span><br><span class="line"><span class="keyword">while</span> (state != END)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (state)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> NUL:</span><br><span class="line">&#123;</span><br><span class="line"> DoNULConvert(pfin, pfout, &amp;state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> C:</span><br><span class="line">&#123;</span><br><span class="line">   DoCConvert(pfin, pfout, &amp;state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CPP:</span><br><span class="line">&#123;</span><br><span class="line"> DoCPPConvert(pfin, pfout, &amp;state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoNULConvert</span><span class="params">(FILE *pfin, FILE * pfout, <span class="keyword">enum</span> STATE * state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">start = fgetc(pfin);</span><br><span class="line"><span class="keyword">switch</span> (start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:  </span><br><span class="line">&#123;</span><br><span class="line"> next = fgetc(pfin);  </span><br><span class="line"> <span class="keyword">switch</span> (next)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">'*'</span>:<span class="comment">// 表示进入C语言注释状态  </span></span><br><span class="line"> &#123;</span><br><span class="line">  fputc(<span class="string">'/'</span>, pfout);  </span><br><span class="line">  fputc(<span class="string">'/'</span>, pfout);</span><br><span class="line">  *state = C;<span class="comment">//状态转换为  C注释状态  </span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">'/'</span>:<span class="comment">// 表示进入C++注释状态  </span></span><br><span class="line"> &#123;</span><br><span class="line">  fputc(start, pfout);  </span><br><span class="line">  fputc(next, pfout);</span><br><span class="line">  *state = CPP;  <span class="comment">//状态转换为  C++注释状态  </span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:   </span><br><span class="line"> &#123;</span><br><span class="line">fputc(start, pfout);  </span><br><span class="line">fputc(next, pfout);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EOF:</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> fputc(start, pfout);  </span><br><span class="line"> *state = END;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">//表示遇到的不是注释  ，状态不变   </span></span><br><span class="line">&#123;</span><br><span class="line">fputc(start, pfout); <span class="comment">//将读取的字符输出到文件  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c状态转换  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoCConvert</span><span class="params">(FILE *pfin, FILE * pfout, <span class="keyword">enum</span> STATE * state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> then = <span class="number">0</span>;</span><br><span class="line">start = fgetc(pfin);</span><br><span class="line"><span class="keyword">switch</span> (start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>:<span class="comment">//遇到'*'表示C语言注释状态   </span></span><br><span class="line">&#123;</span><br><span class="line"> next = fgetc(pfin);    </span><br><span class="line"> <span class="keyword">switch</span> (next)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line"> &#123;</span><br><span class="line">  then = fgetc(pfin);   </span><br><span class="line">  <span class="keyword">if</span> (then == <span class="string">'\n'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  fputc(then, pfout);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  fputc(<span class="string">'\n'</span>, pfout);</span><br><span class="line">  ungetc(then, pfin);</span><br><span class="line">  &#125;</span><br><span class="line">  *state = NUL;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> &#123;</span><br><span class="line">fputc(start, pfout);</span><br><span class="line">ungetc(next, pfin);   </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">&#123;</span><br><span class="line">fputc(start, pfout);</span><br><span class="line">fputc(<span class="string">'/'</span>, pfout);</span><br><span class="line">fputc(<span class="string">'/'</span>, pfout);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fputc(start, pfout);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c++状态转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoCPPConvert</span><span class="params">(FILE *pfin, FILE * pfout, <span class="keyword">enum</span> STATE * state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> then = <span class="number">0</span>;</span><br><span class="line">start = fgetc(pfin);  </span><br><span class="line"><span class="keyword">switch</span> (start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'\n'</span>:  </span><br><span class="line">&#123;</span><br><span class="line">  fputc(start, pfout);</span><br><span class="line">  *state = NUL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fputc(start, pfout);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"标头.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *pfin = <span class="literal">NULL</span>;</span><br><span class="line">FILE *pfout = <span class="literal">NULL</span>;</span><br><span class="line">pfin = fopen(<span class="string">"input.c"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span> (pfin == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"input file open:"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">pfout = fopen(<span class="string">"output.c"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="keyword">if</span> (pfout == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"output file open:"</span>);</span><br><span class="line">fclose(pfin);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">CommentConvert(pfin, pfout);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"注释转换成功\n"</span>);</span><br><span class="line">fclose(pfin);</span><br><span class="line">fclose(pfout);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>“链表倒数第K个节点”</title>
      <link href="/2018/06/03/%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2018/06/03/%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个结点。<br>思路：设置两个指针指向头节点分别为p，和ptr；<br>让p指针先走k-1次，然后让ptr跟着p指针一直遍历下去直到遍历完整个链表，这时ptr指针就指向倒数第k个节点了。<br>有些兴趣的同学可以仔细琢磨。很有意思。<br>附上我的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>//链表结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line"> &#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">init_list</span><span class="params">( <span class="keyword">int</span> n)</span><span class="comment">//初始化链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* head = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"链表数目个数有问题"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  head = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"请输入 "</span> &lt;&lt; n &lt;&lt; <span class="string">"个数据"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n-- &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Node* ptr = <span class="keyword">new</span> Node;</span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; ptr-&gt;data;</span><br><span class="line"> ptr-&gt;next = head;</span><br><span class="line"> head= ptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(Node *head)</span><span class="comment">//打印链表</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"这是一个空链表"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (head!=<span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; head-&gt;data &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line"> head = head-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">Node*  <span class="title">FindKthToTail</span><span class="params">(Node* head, <span class="keyword">int</span> k)</span><span class="comment">//链表节点</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == head&amp;&amp;k&lt;=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node* p = head, *ptr = head;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">  ptr = ptr-&gt;next;</span><br><span class="line">  p = p-&gt;next; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span> <span class="comment">//主函数</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="comment">// Node*ptr3= create_list();</span></span><br><span class="line"><span class="comment">// show(ptr3);</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你想要创建的链表节点个数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"> Node* ptr=init_list(n);</span><br><span class="line"> show(ptr);</span><br><span class="line"><span class="comment">//insert(ptr,4,5);</span></span><br><span class="line">    <span class="comment">//  show(ptr);</span></span><br><span class="line"><span class="comment">//Node* ptr2=resevertlist(ptr);</span></span><br><span class="line"><span class="comment">//show(ptr2);</span></span><br><span class="line"><span class="comment">// minus_point(ptr2, 2);</span></span><br><span class="line"><span class="comment">// show(ptr2);</span></span><br><span class="line">    <span class="comment">//Node*ptr3= minus_point(ptr2, 1);</span></span><br><span class="line"><span class="comment">// show(ptr3);</span></span><br><span class="line"><span class="comment">//int count= sort_list(ptr3);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line"> Node*ptr4 = FindKthToTail(ptr, <span class="number">3</span>);</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; ptr4-&gt;data;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="https://img-blog.csdn.net/20180603002311921?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二维数组的查找</title>
      <link href="/2018/06/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2018/06/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，因此从左下角开始查找，当要查找数字比左下角数字大时。右移要查找数字比左下角数字小时，上移。<br>例矩阵：<br>              1   2   3<br>              4   5   6<br>              7   8   9</p><p>具体算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> row = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> col = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> arr[row][col] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入要查找的值"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; key;</span><br><span class="line"> <span class="comment">/* for (i = 0; i &lt; row; i++)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">  for (j = 0; j &lt; col; j++)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">  cin &gt;&gt; arr[row][col];</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">  <span class="keyword">for</span> (i = row - <span class="number">1</span>, j = <span class="number">0</span>;(i &gt;= <span class="number">0</span> )&amp;&amp; (j &lt; col);)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i][j] == key)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"该数存在!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[i][j]&gt;key)</span><br><span class="line">  &#123;</span><br><span class="line">  i--;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[i][j] &lt; key)</span><br><span class="line">  &#123;</span><br><span class="line">  j++;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"该数不存在"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="https://img-blog.csdn.net/2018060122062050?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="404"><br><img src="https://img-blog.csdn.net/20180601220700185?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="404"></p>]]></content>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>求二进制中1的个数</title>
      <link href="/2018/05/31/%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2018/05/31/%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>思路：如果一个数与1作与运算则可以发现该数最后一位数为1，否则为0.<br>按照此思路可以有以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入一个数"</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  count++;</span><br><span class="line">  &#125;</span><br><span class="line">  n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1的个数为"</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/2018053122422894?/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/5a6L5L2T//I0JBQkFCMA==/" alt="404"><br>但是此方法存在缺陷如果输入的数为负数则会无限死循环</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>首先把n与1做与运算，判断n的最低位是不是为1。接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1….这样反复左移，每次能判断n的其中一位是不是1.这个解法中循环的次数等于整数二进制的位数，32位的整数需要循环32次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> key = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入一个数"</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (key)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &amp; key)</span><br><span class="line">  &#123;</span><br><span class="line">  count++;</span><br><span class="line">  &#125;</span><br><span class="line">  key &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1的个数为"</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>结果如上图：</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>思路：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0，那么一个整数的二进制表示中有<br>多少个1，就可以进行多少次这样的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入一个数"</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n)</span><br><span class="line"> &#123;</span><br><span class="line">  n = ((n - <span class="number">1</span>)&amp; n);</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1的个数为"</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180531225415780?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fill/I0JBQkFCMA==/dissolve/70" alt="404"></p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编程第一课</title>
      <link href="/2018/05/30/%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/"/>
      <url>/2018/05/30/%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>有一组数，对于其中任意两个数组，若前面一个大于后面一个数字，则这两个数字组成一个逆序对。请设计一个高效的算法，计算给定数组中的逆序对个数。</p><p>给定一个int数组A和它的大小n，请返回A中的逆序对个数。保证n小于等于5000。<br>测试样例：<br>[1,2,3,4,5,6,7,0],8<br>返回：7</p><p>答案如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">冒泡排序时做了多少次交换就有多少个逆序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AntiOrder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[j]&gt;A[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    swap(A[j],A[j+<span class="number">1</span>]);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h3><p>写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。<br>例如输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcba</span><br></pre></td></tr></table></figure></p><p>答案如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最简洁</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = str.size()<span class="number">-1</span>; i &gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：利用栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样的输出可以利用栈后进先出的结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ch_stack;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ch)</span><br><span class="line">    &#123;</span><br><span class="line">      ch_stack.push(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!ch_stack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ch_stack.top();</span><br><span class="line">        ch_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    reverse(str.begin(), str.end());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件操作</title>
      <link href="/2018/05/29/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/05/29/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>C++ 通过以下几个类支持文件的输入输出：<br>ofstream: 写操作（输出）的文件类 (由ostream引申而来)<br>ifstream: 读操作（输入）的文件类(由istream引申而来)<br>fstream: 可同时读写操作的文件类 (由iostream引申而来)</p><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>1.建立联系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofstream examplefile(&quot;example.txt&quot;);//声明类example并与创建的文件example.txt联系</span><br></pre></td></tr></table></figure></p><p>其中examplefile是ofstream的对象，对象（examplefile）第一个操作通常与一个真正的文件（example.txt）联系起来，改文件由一个流对象（该例子为examplefile）来表示（这些类的一个实例），对改对象进行的操作就是对该对象联系的文件操作。<br>2.判断文件是否打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">examplefile.is_open()//检查一个文件（examplefile对象所联系的文件）是否被顺利打开</span><br></pre></td></tr></table></figure><p>3.向文件中写入数据，并关闭文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">examplefile &lt;&lt; &quot;This is a line.\n&quot;;</span><br><span class="line">examplefile &lt;&lt; &quot;This is another line.\n&quot;;</span><br><span class="line">examplefile.close();</span><br></pre></td></tr></table></figure><p>ps:为防止流对象被销毁时还联系着打开的文件，析构函数一般将会自动调用关闭函数close</p><p>代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立一个文件并写入内容  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">ofstream <span class="title">examplefile</span><span class="params">(<span class="string">"example.txt"</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">if</span> (examplefile.is_open())  </span><br><span class="line">    &#123;  </span><br><span class="line">        examplefile &lt;&lt; <span class="string">"This is a line.\n"</span>;  </span><br><span class="line">        examplefile &lt;&lt; <span class="string">"This is another line.\n"</span>;  </span><br><span class="line">        examplefile.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://img-blog.csdn.net/20180529223841401?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180529223857452?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">examplefile.eof();//eof ，它是ifstream 从类 ios 中继承过来的，当到达文件末尾时返回true</span><br></pre></td></tr></table></figure><p>文件读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">examplefile.getline(buffer,100);</span><br><span class="line">//getline，读取一行字符，直到遇见换行符。getline具有返回值：成功：返回读取的字节数  失败：返回-1。</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对文件的读取示例  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">256</span>];                       <span class="comment">//定义一个数组，用来存放字符  </span></span><br><span class="line"><span class="function">ifstream <span class="title">examplefile</span><span class="params">(<span class="string">"example.txt"</span>)</span></span>;    <span class="comment">//声明一个对象与要读的文件联系  </span></span><br><span class="line"><span class="keyword">if</span> (! examplefile.is_open())            <span class="comment">//判断是否打开</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Error opening file"</span>; <span class="built_in">exit</span> (<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">while</span> (!examplefile.eof())  </span><br><span class="line">&#123;  </span><br><span class="line">examplefile.getline(buffer,<span class="number">100</span>);  </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;buffer&lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180529224253735?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="read和write函数"><a href="#read和write函数" class="headerlink" title="read和write函数"></a>read和write函数</h3><p>分别为istream和ostream的成员函数，前者被ifstream所继承，后者被ostream所继承。</p><p>代码示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * filename = <span class="string">"example.txt"</span>;  </span><br><span class="line">    <span class="keyword">char</span> * buffer;<span class="comment">//buffer是一块内存地址，用来存储或读取数据  </span></span><br><span class="line">    <span class="keyword">long</span> size;<span class="comment">//size 是一个整数值，表示要从缓存（buffer）中读出或写入的字符数  </span></span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(filename, ios::in|ios::binary|ios::ate)</span></span>;  </span><br><span class="line">    size = file.tellg();  </span><br><span class="line">    file.seekg(<span class="number">0</span>, ios::beg);  </span><br><span class="line">    buffer = <span class="keyword">new</span> <span class="keyword">char</span> [size];  </span><br><span class="line">    file.read(buffer, size);  </span><br><span class="line">    file.close();  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"the complete file is in a buffer"</span>;  </span><br><span class="line">    <span class="keyword">delete</span>[] buffer;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体read，write可参照CSDN专门有一篇博客专门介绍。</p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++输入流</title>
      <link href="/2018/05/28/C++%E8%BE%93%E5%85%A5%E6%B5%81/"/>
      <url>/2018/05/28/C++%E8%BE%93%E5%85%A5%E6%B5%81/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="CIN"><a href="#CIN" class="headerlink" title="CIN"></a>CIN</h3><p>cin是C++编程语言中的标准输入流对象，即istream类的对象。cin主要用于从标准输入读取数据，这里的标准输入，指的是终端的键盘。此外，cout是流的对象，即ostream类的对象，cerr是标准错误输出流的对象，也是ostream 类的对象。这里的标准输出指的是终端键盘，标准错误输出指的是终端的屏幕。<br>在理解cin功能时，不得不提标准输入缓冲区。当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键(\r)会被转换为一个换行符\n，这个换行符\n也会被存储在cin的缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了123456这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。<br>cin读取数据也是从缓冲区中获取数据，缓冲区为空时，cin的成员函数会阻塞等待数据的到来，一旦缓冲区中有数据，就触发cin的成员函数去读取数据。</p><p>使用cin从标准输入读取数据时，通常用到的方法有cin&gt;&gt;，cin.get，cin.getline<br>cin&gt;&gt;&lt;变量1&gt;[&gt;&gt;&lt;变量2&gt;&gt;&gt;…&gt;&gt;&lt;变量n&gt;];</p><p>其中“&gt;&gt;”称为提取运算符，用于读取用户输入的数据，赋给变量。在cin之后“&gt;&gt;&lt;变量&gt;”可重复多次。输入多个数据时数据之间要用空格、TAB、或者ENTER键隔开，系统会自动跳过空格和回车符，将输入的数据赋给各提取运算符的变量。回车符有两个作用一个是分隔符另一个是刷新缓冲区，并通知cin已经输入一行数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">    float c;</span><br><span class="line">    string</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但如果提取运算符的&lt;&lt;后面的变量是字符型，则必须输入字符。单当要获取输入的空格或ENTER键，直接用”&lt;&lt;”不能实现<br>，必须借助于cin.get函数,其一般形式为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cin.get([&lt;字符型变量])</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char a;</span><br><span class="line">    char b;</span><br><span class="line">    a=cin.get();</span><br><span class="line">    cin.get(b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输入一个空格,一个Enter:<br><img src="https://img-blog.csdn.net/20180513224550670?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>注意：<br>（1）从结果可以看出，cin.get()从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取，就出现了如上情况，将换行符读入变量b，输出时换行两次，一次是变量b，一次是endl。<br>（2）cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c)</p><p>gets读取一行<br>gets是C中的库函数，在&lt; stdio.h&gt;申明，从标准输入设备读字符串，可以无限读取，不会判断上限，以回车结束或者EOF时停止读取，所以程序员应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。</p><p>函数原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char *gets( char *buffer );</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char array[20]=&#123;NULL&#125;;</span><br><span class="line">    gets(array);</span><br><span class="line">    cout&lt;&lt;array&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于此函数是C的库函数,所以不建议使用,在C++中使用会报警告.</p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模拟实现atoi函数</title>
      <link href="/2018/05/27/atoi%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/05/27/atoi%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[ <a id="more"></a><h3 id="atoi函数"><a href="#atoi函数" class="headerlink" title="atoi函数"></a>atoi函数</h3><p> atoi函数是把字符串转换成整型数的一个函数，应用在计算机程序和办公软件中。int atoi(const char *nptr) 函数会扫描参数 nptr字符串，跳过前面的空白字符（例如空格，tab缩进）等，可以通过isspace( )函数来检测），直到遇上数字或正负符号才开始做转换，而在遇到非数字或字符串结束符(‘\0’)才结束转换，并将结果返回。如果 nptr不能转换成 int 或者 nptr为空字符串，那么将返回 0 。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"12345"</span>;</span><br><span class="line">    n = atoi(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n=%d\n"</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 输出n=123456</p><h3 id="模拟实现atoi"><a href="#模拟实现atoi" class="headerlink" title="模拟实现atoi"></a>模拟实现atoi</h3><p> 代码实现<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> flag = <span class="number">1</span>;  <span class="comment">//判断符号位  </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == str)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"str is NULL"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (*str == <span class="string">' '</span>)  <span class="comment">//空格  </span></span><br><span class="line">  &#123;</span><br><span class="line">  str++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (*str == <span class="string">'-'</span>)    <span class="comment">//符号位  </span></span><br><span class="line">  &#123;</span><br><span class="line">  flag = <span class="number">-1</span>;</span><br><span class="line">  str++;    <span class="comment">//后移3移位  </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((*str &gt;= <span class="string">'0'</span>) &amp;&amp; (*str &lt;= <span class="string">'9'</span>))<span class="comment">//转化  </span></span><br><span class="line">  &#123;</span><br><span class="line">  number = number * <span class="number">10</span> + *str - <span class="string">'0'</span>;</span><br><span class="line">  str++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag*number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* str = <span class="string">"-123456"</span>;</span><br><span class="line">  <span class="keyword">int</span> tmp = StrToInt(str);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; tmp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p> <img src="https://img-blog.csdn.net/20180527215512598?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>指针数组和数组指针的区别</title>
      <link href="/2018/05/26/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88-md/"/>
      <url>/2018/05/26/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88-md/</url>
      <content type="html"><![CDATA[<a id="more"></a><p>昨天聊了常量指针和指针常量的区别，今天继续一个比较容易混淆的话题，指针数组和数组指针=.=!</p><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>含义：指向数组的的指针<br>(1)数组在内存中的表示<br>创建一个数组就是在内存里面开辟一块连续的空间，比如int a[4];就是在内存里面开辟了一个大小为4*sizeof(int)字节的内存空间。而二维数组是特殊的一维数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//这是一个2*2的二维数组  </span></span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">2</span>];<span class="comment">//数组指针  </span></span><br><span class="line">    p=a;<span class="comment">//令p指向数组a  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里p是一个指向数组的指针。</p><h4 id="让我们理解数组名和数组指针变量：a-a-0-a-1-p-a-1-a-0-1-p-1这些分别代表什么意思呢？"><a href="#让我们理解数组名和数组指针变量：a-a-0-a-1-p-a-1-a-0-1-p-1这些分别代表什么意思呢？" class="headerlink" title="让我们理解数组名和数组指针变量：a,a[0],a[1],p,a+1,a[0]+1,p+1这些分别代表什么意思呢？"></a>让我们理解数组名和数组指针变量：a,a[0],a[1],p,a+1,a[0]+1,p+1这些分别代表什么意思呢？</h4><p>答案：<br>a是一个数组名，类型是指向一维数组的指针，不是变量，a的值是指针常量，即不能有a++或者a=p这些操作。a指向这块连续空间的首地址，值是&amp;a[0][0]。</p><p>a[0]是一维数组名，类型是指向整型的指针，值是&amp;a[0][0]，这个值是一个常量。</p><p>a[1]是一维数组名，类型是指向整型的指针，值是&amp;a[1][0]，这个值是一个常量。</p><p>p是一个数组指针变量，指向一维数组的指针变量，值是&amp;a[0][0]。可以执行p++;p=a等操作。<br>a+1表示指向下一行元素，也可以理解为指向下一个一维数组。</p><p>(a+1)是取出第一行的首地址。</p><p>a[0]+1是指向第0行第1个元素，也可以理解为指向一维数组a[0]的第一个元素。</p><p>p+1同a+1</p><p>(p+1)同_(a+1)</p><p>虽然a跟a[0]值是一样，但类型不一样，表示的意义不一样。通过分析就不难理解为什么_(*(a+i)+j)和a[i][j]等效了。</p><h4 id="数组名与数组指针变量的区别"><a href="#数组名与数组指针变量的区别" class="headerlink" title="数组名与数组指针变量的区别"></a>数组名与数组指针变量的区别</h4><p>区别：数组名是指针，类型是指向元素类型的指针，但值是指针常量，声明数组时编译器会为声明所指定的元素数量保留内存空间。数组指针是指向数组的指针，声明指针变量时编译器只为指针本身保留内存空间。</p><h3 id="指针数组（存放指针的数组）"><a href="#指针数组（存放指针的数组）" class="headerlink" title="指针数组（存放指针的数组）"></a>指针数组（存放指针的数组）</h3><p>指针数组：一个存放int类型的数组称为整型数组，那么存放指针的数组就叫指针数组。</p><pre><code class="c++"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span><span class="function"></span>{      <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;<span class="comment">//p先跟[]结合，然后再跟*结合  </span>    <span class="keyword">int</span> *p[<span class="number">2</span>];<span class="comment">//指针数组,存放指针的数组  </span>    p[<span class="number">0</span>]=&amp;i;      p[<span class="number">1</span>]=&amp;j;      <span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="keyword">sizeof</span>(p));      }</code></pre><p>此例数组p就两个元素，p[0]是指向i的指针，p[1]是指向j的指针。这两个指针都是int型指针，所以p是存放int型指针的数组。sizeof(p)返回数组占用的总空间，所以程序输出是8</p><h4 id="常用举例"><a href="#常用举例" class="headerlink" title="常用举例"></a>常用举例</h4><p>字符排序，可以用指针数组指向不字符串，排序时改变指针指向就避免了大量文本数据的移动。</p>]]></content>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快速排序</title>
      <link href="/2018/05/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/05/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h3><p>是对冒泡排序的一种改进。快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>官方解释：设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。<br>一趟快速排序的算法是：<br>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。<br>尼玛，这都是啥，想必没有见过这个算法的小可爱，对这个官方解释可能是一脸懵逼。所以我就把这个算法通俗的讲一讲。<br>首先要对一堆数字排序我们必须找到一个基准数。而这个基准数可以是这一堆数字中的任意一个，我们定义两个移动的变量从数组的两头向中间检索。从右往左走的变量找到一个小于基准数后停止，从左往右的的变量找到一个大余基准数后停止然后这两个数就交换一下，直到两个变量相遇后就遍历了整个数组，这时候数字的左边都小于基准数，右边大于基准数。然后把数组分成两部分在执行遍历交换后，就完成排序了。<br><img src="https://img-blog.csdn.net/20180515130753470?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图片加载失败"></p><p>具体实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, t, temp;</span><br><span class="line">  <span class="keyword">if</span> (left&gt;right)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  temp = a[left]; <span class="comment">//temp中存的就是基准数</span></span><br><span class="line">  i = left;</span><br><span class="line">  j = right;</span><br><span class="line">  <span class="keyword">while</span> (i != j)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//顺序很重要，要先从右边开始找</span></span><br><span class="line">  <span class="keyword">while</span> (a[j] &gt;= temp &amp;&amp; i&lt;j)</span><br><span class="line">  j--;</span><br><span class="line">  <span class="comment">//再找右边的</span></span><br><span class="line">  <span class="keyword">while</span> (a[i] &lt;= temp &amp;&amp; i&lt;j)</span><br><span class="line">  i++;</span><br><span class="line">  <span class="comment">//交换两个数在数组中的位置</span></span><br><span class="line">  <span class="keyword">if</span> (i&lt;j)</span><br><span class="line">  &#123;</span><br><span class="line">  t = a[i];</span><br><span class="line">  a[i] = a[j];</span><br><span class="line">  a[j] = t;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最终将基准数归位</span></span><br><span class="line">  a[left] = a[i];</span><br><span class="line">  a[i] = temp;</span><br><span class="line">  quicksort(a, left, i - <span class="number">1</span>);<span class="comment">//继续处理左边的，这里是一个递归的过程</span></span><br><span class="line">  quicksort(a, i + <span class="number">1</span>, right);<span class="comment">//继续处理右边的 ，这里是一个递归的过程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span> &#125;;</span><br><span class="line">  quicksort(arr, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180515134156903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这图片加载失败"></p><p>快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>指针常量和常量指针的区别</title>
      <link href="/2018/05/24/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/24/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<a id="more"></a><p>在面试中我们经常会被面试官问到什么是常量指针，什么又是指针常量。可能第一次被问到都会有些懵逼（大神略过）。我今天就来讲一讲这二者的区别。<br>下面开始正题。。。。</p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>指针常量：顾名思义它就是一个常量，但是是指针修饰的。<br>格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p <span class="comment">//指针常量</span></span><br></pre></td></tr></table></figure><p>在这个例子下定义以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a，b；</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p=&amp;a <span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作成功</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作错误</span></span><br></pre></td></tr></table></figure><p>因为声明了指针常量，说明指针变量不允许修改。如同次指针指向一个地址该地址不能被修改，但是该地址里的内容可以被修改</p><h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h2><p>常量指针：如果在定义指针变量的时候，数据类型前用const修饰，被定义的指针变量就是指向常量的指针变量，指向常量的指针变量称为常量指针，格式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a; <span class="comment">//常量指针</span></span><br></pre></td></tr></table></figure><p>在这个例子下定义以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a，b；</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;a <span class="comment">//常量指针</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作错误</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作成功</span></span><br></pre></td></tr></table></figure><p>因为常量指针本质是指针，并且这个指针是一个指向常量的指针，指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变。</p><h2 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h2><p>指向常量的指针常量该怎么写？<br>答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> b = &amp;a;<span class="comment">//指向常量的指针常量</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>函数源码</title>
      <link href="/2018/05/23/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2-md/"/>
      <url>/2018/05/23/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2-md/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="strcpy源码："><a href="#strcpy源码：" class="headerlink" title="strcpy源码："></a>strcpy源码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *strDes, <span class="keyword">const</span> <span class="keyword">char</span> *strSrc)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        assert((strDes != <span class="literal">NULL</span>) &amp;&amp; (strSrc != <span class="literal">NULL</span>));   </span><br><span class="line">        <span class="keyword">char</span> *address = strDes;   </span><br><span class="line">        <span class="keyword">while</span> ((*strDes ++ = *strSrc ++) != <span class="string">'\0'</span>)   </span><br><span class="line">            <span class="literal">NULL</span>;   </span><br><span class="line">        <span class="keyword">return</span> address;   </span><br><span class="line"></span><br><span class="line">注意：<span class="built_in">strcpy</span>只是复制字符串，但不限制复制的数量。很容易造成缓冲溢出，也就是说，不过dest有没有足够的空间来容纳src的字符串，它都会把src指向的字符串全部复制到从dest开始的内存</span><br></pre></td></tr></table></figure><h3 id="strcmp源码："><a href="#strcmp源码：" class="headerlink" title="strcmp源码："></a>strcmp源码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    assert(s != <span class="literal">NULL</span> &amp;&amp; t != <span class="literal">NULL</span>);   </span><br><span class="line">    <span class="keyword">while</span> (*s &amp;&amp; *t &amp;&amp; *s == *t)   </span><br><span class="line">    &#123;   </span><br><span class="line">        ++ s;   </span><br><span class="line">        ++ t;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> (*s - *t);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strcat源码："><a href="#strcat源码：" class="headerlink" title="strcat源码："></a>strcat源码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *strDes, <span class="keyword">const</span> <span class="keyword">char</span> *strSrc)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"></span><br><span class="line"> assert((strDes != <span class="literal">NULL</span>) &amp;&amp; (strSrc != <span class="literal">NULL</span>));   </span><br><span class="line">    <span class="keyword">char</span> *address = strDes;   </span><br><span class="line">    <span class="keyword">while</span> (*strDes != <span class="string">'\0'</span>)   </span><br><span class="line">        ++ strDes;   </span><br><span class="line">    <span class="keyword">while</span> ((*strDes ++ = *strSrc ++) != <span class="string">'\0'</span>)   </span><br><span class="line">        <span class="literal">NULL</span>;   </span><br><span class="line">    <span class="keyword">return</span> address;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：1.不能向形参传递指向字符串常量的指针（本题中dst和src都是指向串常量的指针，字符串常量存储在常量区不能被修改  2.传递的字符数组前一个实参的所分配的内存空间必须足够大</p><h3 id="strlen源码："><a href="#strlen源码：" class="headerlink" title="strlen源码："></a>strlen源码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    assert(str != <span class="literal">NULL</span>);   </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">while</span> (*str ++ != <span class="string">'\0'</span>)   </span><br><span class="line">        ++ len;   </span><br><span class="line">    <span class="keyword">return</span> len;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strstr源码："><a href="#strstr源码：" class="headerlink" title="strstr源码："></a>strstr源码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strSrc, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    assert(strSrc != <span class="literal">NULL</span> &amp;&amp; str != <span class="literal">NULL</span>);   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s = strSrc;   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *t = str;   </span><br><span class="line">    <span class="keyword">for</span> (; *t != <span class="string">'\0'</span>; ++ strSrc)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">for</span> (s = strSrc, t = str; *t != <span class="string">'\0'</span> &amp;&amp; *s == *t; ++s, ++t)   </span><br><span class="line">            <span class="literal">NULL</span>;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*t == <span class="string">'\0'</span>)   </span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">char</span> *) strSrc;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strchr源码："><a href="#strchr源码：" class="headerlink" title="strchr源码："></a>strchr源码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * __<span class="function">cdecl <span class="title">strchr</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                      constchar * <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> ch</span></span></span><br><span class="line"><span class="function"><span class="params">                       )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">while</span> (*<span class="built_in">string</span> &amp;&amp; *<span class="built_in">string</span> != (<span class="keyword">char</span>)ch)</span><br><span class="line">        <span class="built_in">string</span>++;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (*<span class="built_in">string</span> == (<span class="keyword">char</span>)ch)</span><br><span class="line">       <span class="keyword">return</span>((<span class="keyword">char</span> *)<span class="built_in">string</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断言：assert（表达式）如果表达式的值为假，整个程序将退出，并输出一条错误信息。如果表达式的值为真则继续执行后面的语句，使用这个宏前需要包含头文件assert.h<br>结语：函数就向一个黑盒一样，调用它的人给他输入（调用它本身就是一种输入），然后等待一个理想中的输出或者是相应的操作。调用者是希望我们的这个函数能够非常健壮的让他们利用，那么为了使我们的函数拥有一定的鲁棒性。</p>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 程序源码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2018/05/23/hello-world/"/>
      <url>/2018/05/23/hello-world/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="测试博客"><a href="#测试博客" class="headerlink" title="测试博客"></a>测试博客</h2><h3 id="这是一篇测试博客"><a href="#这是一篇测试博客" class="headerlink" title="这是一篇测试博客"></a>这是一篇测试博客</h3><p>第一次使用github+hexo搭建属于自己的博客.<br>日经过不懈的努力终于搭建好了，我非常开心！！</p><pre><code>2018.5.23   邓铭</code></pre>]]></content>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
