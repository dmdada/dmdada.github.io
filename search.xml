<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql基本操作]]></title>
    <url>%2F2018%2F06%2F13%2Fmysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[翻转字符串]]></title>
    <url>%2F2018%2F06%2F11%2F%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目输入：i am a student.输出：student.a am i 分析先总体反转，然后逐个单词反转，首先，将字符串完全翻转一次，得到.tneduts a ma i。然后设置两个指针，对单词进行翻转，也就是局部翻转. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void AllReverse(char *pStart, char *pEnd)//全反转&#123; char pTemp; if (pStart == NULL || pEnd == NULL) return; while (pStart &lt; pEnd) &#123; pTemp = *pStart; *pStart = *pEnd; *pEnd = pTemp; pStart++; pEnd--; &#125;&#125;char *Reverse(char *pData)//单词反转&#123; if (pData == NULL) &#123; return NULL; &#125; char *pStart = pData; char *pEnd = pData; while (*pEnd != '\0') &#123; pEnd++; &#125; pEnd--; AllReverse(pStart, pEnd);//全反转 pStart = pEnd = pData; while (*pStart != '\0') &#123; if (*pStart == ' ') &#123; pStart++; pEnd++; &#125; else if (*pEnd == ' ' || *pEnd == '\0') &#123; AllReverse(pStart, --pEnd); pStart = ++pEnd; &#125; else &#123; pEnd++; &#125; &#125; return pData;&#125;int main()// 主函数&#123; char a_arr[100]; char * str = NULL; gets_s(a_arr); str = Reverse(a_arr); cout &lt;&lt; str; return 0;&#125; 运行结果]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找到数组第一个相同的数]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定一个数组，然找到数组里第一个重复的数字。例： arr[]={1,2,4,3,6,5,6,5,8,9}找到5。 代码1234567891011121314151617181920212223void checknum(int arr[], int num) &#123; int key = arr[0]; int i = 0; for (int j = 0; j &lt; num; j++) &#123; key = arr[j]; for (i = j + 1; i &lt; num; i++) &#123; if (arr[i] == key) &#123; cout &lt;&lt; "该数组有重复数字,数字是：" &lt;&lt; key &lt;&lt; endl; return; &#125; &#125; &#125; cout &lt;&lt; "没有重复的数字"; &#125; int main() &#123; int arr[] = &#123; 1, 2, 3, 4, 5, 4, 7, 8, 9 &#125;; checknum(arr, 9); return 0; 结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[寻找两个链表公共节点]]></title>
    <url>%2F2018%2F06%2F06%2F%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目两个单向链表，找出它们的第一个公共结点。数据类型如下： 12345typedef struct Node&#123; int data; Node* next;&#125;Node; 分析如果两个单向链表有公共的结点，也就是说两个链表从某一结点开始，它们的Next都指向同一个结点。但由于是单向链表的结点，每个结点只有一个Next，因此从第一个公共结点开始，之后它们所有结点都是重合的，不可能再出现分叉。所以，两个有公共结点而部分重合的链表，拓扑形状看起来像一个Y，而不可能像X。看到这个题目，第一反应就是蛮力法：在第一链表上顺序遍历每个结点。每遍历一个结点的时候，在第二个链表上顺序遍历每个结点。如果此时两个链表上的结点是一样的，说明此时两个链表重合，于是找到了它们的公共结点。如果第一个链表的长度为m，第二个链表的长度为n，显然，该方法的时间复杂度为O(mn)。接 下来我们试着去寻找一个线性时间复杂度的算法。我们先把问题简化：如何判断两个单向链表有没有公共结点？前面已经提到，如果两个链表有一个公共结点，那么 该公共结点之后的所有结点都是重合的。那么，它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分，只要分别遍历两个链表到最后一 个结点。如果两个尾结点是一样的，说明它们用重合；否则两个链表没有公共的结点。在上面的思路中，顺序遍历两个链表到尾结点的时候，我们不能保证在两个链表上同时到达尾结点。这是因为两个链表不一定长度一样。但如果假设一个链表比另一个长l个结点，我们先在长的链表上遍历l个结点，之后再同步遍历，这个时候我们就能保证同时到达最后一个结点了。由于两个链表从第一个公共结点考试到链表的尾结点，这一部分是重合的。因此，它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。在这个思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历若干次之后，再同步遍历两个链表，知道找到相同的结点，或者一直到链表结束。此时，如果第一个链表的长度为m，第二个链表的长度为n，该方法的时间复杂度为O(m+n)。 基于这个思路，我们不难写出如下的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;iostream&gt;#include&lt;assert.h&gt;using namespace std;typedef struct Node//数据结构体&#123; int data; Node* next;&#125;Node;Node* findnode(Node* head, int n);Node* init_list(int n)//初始化链表&#123; Node* head = NULL; if (n &lt; 0) &#123; cout &lt;&lt; "链表数目个数有问题" &lt;&lt; endl; &#125; else if (n == 0) &#123; head = NULL; return head; &#125; else &#123; cout &lt;&lt; "请输入 " &lt;&lt; n &lt;&lt; "个数据" &lt;&lt; endl; while (n-- &gt; 0) &#123; Node* ptr = new Node; cin &gt;&gt; ptr-&gt;data; ptr-&gt;next = head; head = ptr; &#125; &#125; return head;&#125;void show(Node *head)//打印链表&#123; if (head == NULL) &#123; cout &lt;&lt; "这是一个空链表" &lt;&lt; endl; &#125; while (head != NULL) &#123; cout &lt;&lt; head-&gt;data &lt;&lt; "-&gt;"; head = head-&gt;next; &#125; cout &lt;&lt; "NULL" &lt;&lt; endl;&#125;int sort_list(Node* head)//遍历链表&#123; int count = 0; if (head == NULL) &#123; cout &lt;&lt; "链表为空" &lt;&lt; endl; &#125; while (head) &#123; head = head-&gt;next; count++; &#125; return count;&#125;Node* findnode(Node* head, int n)&#123; Node* ptr = head; if (NULL == head) &#123; return NULL; &#125; else &#123; while (n--) &#123; ptr = ptr-&gt;next; &#125; &#125; return ptr;&#125;void FindFirstCommonNode(Node* head1, Node* head2)//寻找公共节点&#123; assert(head1); assert(head2); int len1 = sort_list(head1); int len2 = sort_list(head2); int tmp = 0; if (len1 &gt; len2) &#123; tmp = len1 - len2; for (int i = 0; i &lt; tmp; i++) &#123; head1 = head1-&gt;next; &#125; &#125; else &#123; tmp = len2 - len1; for (int i = 0; i &lt; tmp; i++) &#123; head2 = head2-&gt;next; &#125; &#125; while ((head1 != NULL) &amp;&amp; (head2 != NULL) &amp;&amp; (head1 != head2)) &#123; head1 = head1-&gt;next; head2 = head2-&gt;next; &#125; Node* key = head1; cout &lt;&lt; "公共节点为" &lt;&lt; key-&gt;data &lt;&lt; endl;&#125;int main()&#123; int n; int m; cout &lt;&lt; "请输入你想要创建的链表节点个数" &lt;&lt; endl; cin &gt;&gt; n; Node* ptr = init_list(n); show(ptr); cout &lt;&lt; "请输入你想要创建的链表节点个数" &lt;&lt; endl; cin &gt;&gt; m; Node* ptr1 = init_list(m); findnode(ptr1,m-1)-&gt;next = findnode(ptr, 3); show(ptr1); FindFirstCommonNode(ptr, ptr1); return 0;&#125; 截图]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言注释转C++注释]]></title>
    <url>%2F2018%2F06%2F04%2FC%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A%E8%BD%ACC%2B%2B%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[题目要求int a = 10;// 1.一般情况int num = 0;/_ int i = 0; _/ // 2.换行问题/_ int i = 0; /int j = 0;/ int i = 0; _/int j = 0; // 3.匹配问题/_int i = 0;/_xxxxx*/ // 4.多行注释问题/_int i=0;int j = 0;int k = 0;_/int k = 0; // 5.连续注释问题/int a=0;//int b=0;/ // 6.连续的/问题/*/ // 7.C++注释问题// /xxxxxxxxxxxx/ 问题分析 代码片头文件12345678910111213141516171819202122#ifndef __COMMENTCONVERT_HEADFILE__ #define __COMMENTCONVERT_HEADFILE__#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; enum STATE &#123;NUL,C,CPP,END&#125;;void CommentConvert(FILE *pfin, FILE * pfout);void DoNULConvert(FILE *pfin, FILE * pfout, enum STATE * state); void DoCConvert(FILE *pfin, FILE * pfout, enum STATE * state);void DoCPPConvert(FILE *pfin, FILE * pfout, enum STATE * state);#endif 源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include"标头.h"#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void CommentConvert(FILE *pfin, FILE * pfout)&#123; enum STATE state = NUL;//初始化状态 为 无注释状态 while (state != END) &#123; switch (state) &#123; case NUL: &#123; DoNULConvert(pfin, pfout, &amp;state); &#125; break; case C: &#123; DoCConvert(pfin, pfout, &amp;state); &#125; break; case CPP: &#123; DoCPPConvert(pfin, pfout, &amp;state); &#125; break; default: break; &#125; &#125;&#125;void DoNULConvert(FILE *pfin, FILE * pfout, enum STATE * state)&#123; int start = 0; int next = 0; start = fgetc(pfin); switch (start) &#123; case '/': &#123; next = fgetc(pfin); switch (next) &#123; case '*':// 表示进入C语言注释状态 &#123; fputc('/', pfout); fputc('/', pfout); *state = C;//状态转换为 C注释状态 &#125; break; case '/':// 表示进入C++注释状态 &#123; fputc(start, pfout); fputc(next, pfout); *state = CPP; //状态转换为 C++注释状态 &#125; break; default: &#123; fputc(start, pfout); fputc(next, pfout); &#125; break; &#125; &#125; break; case EOF: &#123; fputc(start, pfout); *state = END; &#125; break; default://表示遇到的不是注释 ，状态不变 &#123; fputc(start, pfout); //将读取的字符输出到文件 &#125; break; &#125;&#125;//c状态转换 void DoCConvert(FILE *pfin, FILE * pfout, enum STATE * state)&#123; int start = 0; int next = 0; int then = 0; start = fgetc(pfin); switch (start) &#123; case '*'://遇到'*'表示C语言注释状态 &#123; next = fgetc(pfin); switch (next) &#123; case '/': &#123; then = fgetc(pfin); if (then == '\n') &#123; fputc(then, pfout); &#125; else &#123; fputc('\n', pfout); ungetc(then, pfin); &#125; *state = NUL; &#125; break; default: &#123; fputc(start, pfout); ungetc(next, pfin); &#125; break; &#125; &#125; break; case '\n': &#123; fputc(start, pfout); fputc('/', pfout); fputc('/', pfout); &#125; break; default: fputc(start, pfout); break; &#125;&#125;//c++状态转换void DoCPPConvert(FILE *pfin, FILE * pfout, enum STATE * state)&#123; int start = 0; int next = 0; int then = 0; start = fgetc(pfin); switch (start) &#123; case '\n': &#123; fputc(start, pfout); *state = NUL; &#125; break; default: fputc(start, pfout); break; &#125;&#125; 测试文件123456789101112131415161718192021222324252627#include "标头.h"int main()&#123; FILE *pfin = NULL; FILE *pfout = NULL; pfin = fopen("input.c", "r"); if (pfin == NULL) &#123; perror("input file open:"); exit(EXIT_FAILURE); &#125; pfout = fopen("output.c", "w"); if (pfout == NULL) &#123; perror("output file open:"); fclose(pfin); exit(EXIT_FAILURE); &#125; CommentConvert(pfin, pfout); printf("注释转换成功\n"); fclose(pfin); fclose(pfout); system("pause"); return 0;&#125;]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“链表倒数第K个节点”]]></title>
    <url>%2F2018%2F06%2F03%2F%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，输出该链表中倒数第k个结点。思路：设置两个指针指向头节点分别为p，和ptr；让p指针先走k-1次，然后让ptr跟着p指针一直遍历下去直到遍历完整个链表，这时ptr指针就指向倒数第k个节点了。有些兴趣的同学可以仔细琢磨。很有意思。附上我的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;using namespace std;typedef struct Node//链表结构&#123; int data; Node* next; &#125;Node;Node* init_list( int n)//初始化链表&#123; Node* head = NULL; if (n &lt; 0) &#123; cout &lt;&lt; "链表数目个数有问题" &lt;&lt; endl; &#125; else if(n == 0) &#123; head = NULL; return head; &#125; else &#123; cout&lt;&lt; "请输入 " &lt;&lt; n &lt;&lt; "个数据"&lt;&lt;endl; while (n-- &gt; 0) &#123; Node* ptr = new Node; cin &gt;&gt; ptr-&gt;data; ptr-&gt;next = head; head= ptr; &#125; &#125; return head;&#125;void show(Node *head)//打印链表 &#123; if (head == NULL) &#123; cout &lt;&lt; "这是一个空链表" &lt;&lt; endl; &#125; while (head!=NULL) &#123; cout &lt;&lt; head-&gt;data &lt;&lt; "-&gt;"; head = head-&gt;next; &#125; cout &lt;&lt; "NULL"&lt;&lt;endl; &#125; Node* FindKthToTail(Node* head, int k)//链表节点 &#123; if (NULL == head&amp;&amp;k&lt;=0) &#123; return NULL; &#125; Node* p = head, *ptr = head; for (int i = 0; i &lt; k-1; i++) &#123; if (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; &#125; while (p-&gt;next) &#123; ptr = ptr-&gt;next; p = p-&gt;next; &#125; return ptr; &#125;int main() //主函数 &#123; // Node*ptr3= create_list(); // show(ptr3); int n; cout &lt;&lt; "请输入你想要创建的链表节点个数" &lt;&lt; endl; cin &gt;&gt; n; Node* ptr=init_list(n); show(ptr); //insert(ptr,4,5); // show(ptr); //Node* ptr2=resevertlist(ptr); //show(ptr2); // minus_point(ptr2, 2); // show(ptr2); // Node*ptr3= minus_point(ptr2, 1); // show(ptr3); //int count= sort_list(ptr3); //cout &lt;&lt; count &lt;&lt; endl; Node*ptr4 = FindKthToTail(ptr, 3); cout &lt;&lt; ptr4-&gt;data; return 0; &#125; 运行结果：]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组的查找]]></title>
    <url>%2F2018%2F06%2F01%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目分析矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，因此从左下角开始查找，当要查找数字比左下角数字大时。右移要查找数字比左下角数字小时，上移。例矩阵： 1 2 3 4 5 6 7 8 9 具体算法如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt; using namespace std; int main() &#123; int i, j; int key = 0; int const row = 3; int const col = 3; int arr[row][col] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; cout &lt;&lt; "输入要查找的值" &lt;&lt; endl; cin &gt;&gt; key; /* for (i = 0; i &lt; row; i++) &#123; for (j = 0; j &lt; col; j++) &#123; cin &gt;&gt; arr[row][col]; &#125; &#125;*/ for (i = row - 1, j = 0;(i &gt;= 0 )&amp;&amp; (j &lt; col);) &#123; if (arr[i][j] == key) &#123; cout &lt;&lt; "该数存在!" &lt;&lt; endl; return 0; &#125; if (arr[i][j]&gt;key) &#123; i--; continue; &#125; if (arr[i][j] &lt; key) &#123; j++; &#125; &#125; cout &lt;&lt; "该数不存在" &lt;&lt; endl; return 0; &#125; 运行结果：]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求二进制中1的个数]]></title>
    <url>%2F2018%2F05%2F31%2F%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[方法一：思路：如果一个数与1作与运算则可以发现该数最后一位数为1，否则为0.按照此思路可以有以下代码： 12345678910111213141516171819202122#include &lt;iostream&gt; using namespace std; int main() &#123; int n = 0; cout &lt;&lt; "输入一个数"; cin &gt;&gt; n; int count = 0; while (n) &#123; if (n &amp; 1) &#123; count++; &#125; n &gt;&gt;= 1; &#125; cout &lt;&lt; "1的个数为"&lt;&lt;count&lt;&lt;endl; return 0; &#125; 但是此方法存在缺陷如果输入的数为负数则会无限死循环 方法二：首先把n与1做与运算，判断n的最低位是不是为1。接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1….这样反复左移，每次能判断n的其中一位是不是1.这个解法中循环的次数等于整数二进制的位数，32位的整数需要循环32次 1234567891011121314151617181920212223#include &lt;iostream&gt; using namespace std; int main() &#123; int n = 0; int key = 1; cout &lt;&lt; "输入一个数"; cin &gt;&gt; n; int count = 0; while (key) &#123; if (n &amp; key) &#123; count++; &#125; key &lt;&lt;= 1; &#125; cout &lt;&lt; "1的个数为"&lt;&lt;count&lt;&lt;endl; return 0; &#125; 结果如上图： 方法三思路：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0，那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。 12345678910111213141516171819#include &lt;iostream&gt; using namespace std; int main() &#123; int n = 0; cout &lt;&lt; "输入一个数"; cin &gt;&gt; n; int count = 0; while (n) &#123; n = ((n - 1)&amp; n); count++; &#125; cout &lt;&lt; "1的个数为"&lt;&lt;count&lt;&lt;endl; return 0; &#125;]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程第一课]]></title>
    <url>%2F2018%2F05%2F30%2F%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[第一题有一组数，对于其中任意两个数组，若前面一个大于后面一个数字，则这两个数字组成一个逆序对。请设计一个高效的算法，计算给定数组中的逆序对个数。 给定一个int数组A和它的大小n，请返回A中的逆序对个数。保证n小于等于5000。测试样例：[1,2,3,4,5,6,7,0],8返回：7 答案如下： 123456789101112131415161718192021/*冒泡排序时做了多少次交换就有多少个逆序*/class AntiOrder &#123;public: int count(vector&lt;int&gt; A, int n) &#123; // write code here int count = 0; int i,j; if(n &lt; 2) return n; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n-i-1;j++)&#123; if(A[j]&gt;A[j+1])&#123; swap(A[j],A[j+1]); count++; &#125; &#125; &#125; return count; &#125;&#125;; 第二题：写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。例如输入：1abcd 输出1dcba 答案如下： 12345678910//最简洁#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; for(int i = str.size()-1; i &gt;=0;i--) cout &lt;&lt; str[i];&#125; 方法二：利用栈 12345678910111213141516171819//这样的输出可以利用栈后进先出的结构#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main(void)&#123; char ch; stack&lt;char&gt; ch_stack; while(cin&gt;&gt;ch) &#123; ch_stack.push(ch); &#125; while(!ch_stack.empty()) &#123; cout&lt;&lt;ch_stack.top(); ch_stack.pop(); &#125; return 0;&#125; 方法三： 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; reverse(str.begin(), str.end()); cout &lt;&lt; str; return 0;&#125;]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2F2018%2F05%2F29%2F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件操作C++ 通过以下几个类支持文件的输入输出：ofstream: 写操作（输出）的文件类 (由ostream引申而来)ifstream: 读操作（输入）的文件类(由istream引申而来)fstream: 可同时读写操作的文件类 (由iostream引申而来) 打开文件1.建立联系1ofstream examplefile(&quot;example.txt&quot;);//声明类example并与创建的文件example.txt联系 其中examplefile是ofstream的对象，对象（examplefile）第一个操作通常与一个真正的文件（example.txt）联系起来，改文件由一个流对象（该例子为examplefile）来表示（这些类的一个实例），对改对象进行的操作就是对该对象联系的文件操作。2.判断文件是否打开 1examplefile.is_open()//检查一个文件（examplefile对象所联系的文件）是否被顺利打开 3.向文件中写入数据，并关闭文件 123examplefile &lt;&lt; &quot;This is a line.\n&quot;;examplefile &lt;&lt; &quot;This is another line.\n&quot;;examplefile.close(); ps:为防止流对象被销毁时还联系着打开的文件，析构函数一般将会自动调用关闭函数close 代码示例 123456789101112131415//建立一个文件并写入内容 #include &lt;fstream&gt; using namespace std; int main() &#123; ofstream examplefile("example.txt"); if (examplefile.is_open()) &#123; examplefile &lt;&lt; "This is a line.\n"; examplefile &lt;&lt; "This is another line.\n"; examplefile.close(); &#125; return 0; &#125; 结果： 1examplefile.eof();//eof ，它是ifstream 从类 ios 中继承过来的，当到达文件末尾时返回true 文件读取： 12examplefile.getline(buffer,100);//getline，读取一行字符，直到遇见换行符。getline具有返回值：成功：返回读取的字节数 失败：返回-1。 代码示例： 1234567891011121314151617181920//对文件的读取示例 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;cstdlib&gt; using namespace std; int main () &#123; char buffer[256]; //定义一个数组，用来存放字符 ifstream examplefile("example.txt"); //声明一个对象与要读的文件联系 if (! examplefile.is_open()) //判断是否打开&#123; cout &lt;&lt; "Error opening file"; exit (1); &#125; while (!examplefile.eof()) &#123; examplefile.getline(buffer,100); cout&lt;&lt;buffer&lt;&lt; endl; &#125; return 0; &#125; read和write函数分别为istream和ostream的成员函数，前者被ifstream所继承，后者被ostream所继承。 代码示例：123456789101112131415161718#include &lt;fstream&gt; #include &lt;iostream&gt; using namespace std; int main () &#123; const char * filename = "example.txt"; char * buffer;//buffer是一块内存地址，用来存储或读取数据 long size;//size 是一个整数值，表示要从缓存（buffer）中读出或写入的字符数 ifstream file(filename, ios::in|ios::binary|ios::ate); size = file.tellg(); file.seekg(0, ios::beg); buffer = new char [size]; file.read(buffer, size); file.close(); cout &lt;&lt;"the complete file is in a buffer"; delete[] buffer; return 0; &#125; 具体read，write可参照CSDN专门有一篇博客专门介绍。]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++输入流]]></title>
    <url>%2F2018%2F05%2F28%2FC%2B%2B%E8%BE%93%E5%85%A5%E6%B5%81%2F</url>
    <content type="text"><![CDATA[CINcin是C++编程语言中的标准输入流对象，即istream类的对象。cin主要用于从标准输入读取数据，这里的标准输入，指的是终端的键盘。此外，cout是流的对象，即ostream类的对象，cerr是标准错误输出流的对象，也是ostream 类的对象。这里的标准输出指的是终端键盘，标准错误输出指的是终端的屏幕。在理解cin功能时，不得不提标准输入缓冲区。当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键(\r)会被转换为一个换行符\n，这个换行符\n也会被存储在cin的缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了123456这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。cin读取数据也是从缓冲区中获取数据，缓冲区为空时，cin的成员函数会阻塞等待数据的到来，一旦缓冲区中有数据，就触发cin的成员函数去读取数据。 使用cin从标准输入读取数据时，通常用到的方法有cin&gt;&gt;，cin.get，cin.getlinecin&gt;&gt;&lt;变量1&gt;[&gt;&gt;&lt;变量2&gt;&gt;&gt;…&gt;&gt;&lt;变量n&gt;]; 其中“&gt;&gt;”称为提取运算符，用于读取用户输入的数据，赋给变量。在cin之后“&gt;&gt;&lt;变量&gt;”可重复多次。输入多个数据时数据之间要用空格、TAB、或者ENTER键隔开，系统会自动跳过空格和回车符，将输入的数据赋给各提取运算符的变量。回车符有两个作用一个是分隔符另一个是刷新缓冲区，并通知cin已经输入一行数据。123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; char a; int b; float c; string cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 但如果提取运算符的&lt;&lt;后面的变量是字符型，则必须输入字符。单当要获取输入的空格或ENTER键，直接用”&lt;&lt;”不能实现，必须借助于cin.get函数,其一般形式为:123456789101112131415cin.get([&lt;字符型变量])#include &lt;iostream&gt;using namespace std;int main()&#123; char a; char b; a=cin.get(); cin.get(b); cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 输入一个空格,一个Enter:注意：（1）从结果可以看出，cin.get()从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取，就出现了如上情况，将换行符读入变量b，输出时换行两次，一次是变量b，一次是endl。（2）cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c) gets读取一行gets是C中的库函数，在&lt; stdio.h&gt;申明，从标准输入设备读字符串，可以无限读取，不会判断上限，以回车结束或者EOF时停止读取，所以程序员应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。 函数原型：123456789101112char *gets( char *buffer );#include &lt;iostream&gt;using namespace std;int main()&#123; char array[20]=&#123;NULL&#125;; gets(array); cout&lt;&lt;array&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 由于此函数是C的库函数,所以不建议使用,在C++中使用会报警告.]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟实现atoi函数]]></title>
    <url>%2F2018%2F05%2F27%2Fatoi%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[atoi函数 atoi函数是把字符串转换成整型数的一个函数，应用在计算机程序和办公软件中。int atoi(const char *nptr) 函数会扫描参数 nptr字符串，跳过前面的空白字符（例如空格，tab缩进）等，可以通过isspace( )函数来检测），直到遇上数字或正负符号才开始做转换，而在遇到非数字或字符串结束符(‘\0’)才结束转换，并将结果返回。如果 nptr不能转换成 int 或者 nptr为空字符串，那么将返回 0 。12345678910#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; int n; char *str = "12345"; n = atoi(str); printf("n=%d\n",n); return 0;&#125; 输出n=123456 模拟实现atoi 代码实现 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt; int StrToInt(char *str) &#123; long number = 0; int flag = 1; //判断符号位 if (NULL == str) &#123; printf("str is NULL"); return 0; &#125; while (*str == ' ') //空格 &#123; str++; &#125; if (*str == '-') //符号位 &#123; flag = -1; str++; //后移3移位 &#125; while ((*str &gt;= '0') &amp;&amp; (*str &lt;= '9'))//转化 &#123; number = number * 10 + *str - '0'; str++; &#125; return flag*number; &#125; int main() &#123; char* str = "-123456"; int tmp = StrToInt(str); cout &lt;&lt; tmp&lt;&lt;endl; &#125;]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针数组和数组指针的区别]]></title>
    <url>%2F2018%2F05%2F26%2F%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88-md%2F</url>
    <content type="text"><![CDATA[昨天聊了常量指针和指针常量的区别，今天继续一个比较容易混淆的话题，指针数组和数组指针=.=! 数组指针含义：指向数组的的指针(1)数组在内存中的表示创建一个数组就是在内存里面开辟一块连续的空间，比如int a[4];就是在内存里面开辟了一个大小为4*sizeof(int)字节的内存空间。而二维数组是特殊的一维数组。1234567#include&lt;stdio.h&gt;void main() &#123; int a[2][2]=&#123;1,2,3,4&#125;;//这是一个2*2的二维数组 int (*p)[2];//数组指针 p=a;//令p指向数组a &#125; 这里p是一个指向数组的指针。 让我们理解数组名和数组指针变量：a,a[0],a[1],p,a+1,a[0]+1,p+1这些分别代表什么意思呢？答案：a是一个数组名，类型是指向一维数组的指针，不是变量，a的值是指针常量，即不能有a++或者a=p这些操作。a指向这块连续空间的首地址，值是&amp;a[0][0]。 a[0]是一维数组名，类型是指向整型的指针，值是&amp;a[0][0]，这个值是一个常量。 a[1]是一维数组名，类型是指向整型的指针，值是&amp;a[1][0]，这个值是一个常量。 p是一个数组指针变量，指向一维数组的指针变量，值是&amp;a[0][0]。可以执行p++;p=a等操作。a+1表示指向下一行元素，也可以理解为指向下一个一维数组。 (a+1)是取出第一行的首地址。 a[0]+1是指向第0行第1个元素，也可以理解为指向一维数组a[0]的第一个元素。 p+1同a+1 (p+1)同_(a+1) 虽然a跟a[0]值是一样，但类型不一样，表示的意义不一样。通过分析就不难理解为什么_(*(a+i)+j)和a[i][j]等效了。 数组名与数组指针变量的区别区别：数组名是指针，类型是指向元素类型的指针，但值是指针常量，声明数组时编译器会为声明所指定的元素数量保留内存空间。数组指针是指向数组的指针，声明指针变量时编译器只为指针本身保留内存空间。 指针数组（存放指针的数组）指针数组：一个存放int类型的数组称为整型数组，那么存放指针的数组就叫指针数组。 #include&lt;stdio.h&gt; void main() { int i=1,j=2;//p先跟[]结合，然后再跟*结合 int *p[2];//指针数组,存放指针的数组 p[0]=&amp;i; p[1]=&amp;j; printf("%d",sizeof(p)); } 此例数组p就两个元素，p[0]是指向i的指针，p[1]是指向j的指针。这两个指针都是int型指针，所以p是存放int型指针的数组。sizeof(p)返回数组占用的总空间，所以程序输出是8 常用举例字符排序，可以用指针数组指向不字符串，排序时改变指针指向就避免了大量文本数据的移动。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F05%2F25%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序（Quicksort）是对冒泡排序的一种改进。快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 原理官方解释：设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。一趟快速排序的算法是：1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。尼玛，这都是啥，想必没有见过这个算法的小可爱，对这个官方解释可能是一脸懵逼。所以我就把这个算法通俗的讲一讲。首先要对一堆数字排序我们必须找到一个基准数。而这个基准数可以是这一堆数字中的任意一个，我们定义两个移动的变量从数组的两头向中间检索。从右往左走的变量找到一个小于基准数后停止，从左往右的的变量找到一个大余基准数后停止然后这两个数就交换一下，直到两个变量相遇后就遍历了整个数组，这时候数字的左边都小于基准数，右边大于基准数。然后把数组分成两部分在执行遍历交换后，就完成排序了。 具体实例： 1234567891011121314151617181920212223242526272829303132333435363738394041void quicksort(int* a, int left, int right) &#123; int i, j, t, temp; if (left&gt;right) return; temp = a[left]; //temp中存的就是基准数 i = left; j = right; while (i != j) &#123; //顺序很重要，要先从右边开始找 while (a[j] &gt;= temp &amp;&amp; i&lt;j) j--; //再找右边的 while (a[i] &lt;= temp &amp;&amp; i&lt;j) i++; //交换两个数在数组中的位置 if (i&lt;j) &#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; //最终将基准数归位 a[left] = a[i]; a[i] = temp; quicksort(a, left, i - 1);//继续处理左边的，这里是一个递归的过程 quicksort(a, i + 1, right);//继续处理右边的 ，这里是一个递归的过程 &#125; int main()&#123; int arr[10] = &#123; 8, 2, 3, 1, 6, 5, 4, 7, 0, 9 &#125;; quicksort(arr, 0, 9); for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; arr[i]&lt;&lt;endl; &#125; return 0; &#125; 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针常量和常量指针的区别]]></title>
    <url>%2F2018%2F05%2F24%2F%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在面试中我们经常会被面试官问到什么是常量指针，什么又是指针常量。可能第一次被问到都会有些懵逼（大神略过）。我今天就来讲一讲这二者的区别。下面开始正题。。。。 指针常量指针常量：顾名思义它就是一个常量，但是是指针修饰的。格式为： 1int * const p //指针常量 在这个例子下定义以下代码： 12345int a，b；int * const p=&amp;a //指针常量//那么分为一下两种操作*p=9;//操作成功p=&amp;b;//操作错误 因为声明了指针常量，说明指针变量不允许修改。如同次指针指向一个地址该地址不能被修改，但是该地址里的内容可以被修改 常量指针常量指针：如果在定义指针变量的时候，数据类型前用const修饰，被定义的指针变量就是指向常量的指针变量，指向常量的指针变量称为常量指针，格式如下 1const int *p = &amp;a; //常量指针 在这个例子下定义以下代码： 12345int a，b； const int *p=&amp;a //常量指针//那么分为一下两种操作*p=9;//操作错误p=&amp;b;//操作成功 因为常量指针本质是指针，并且这个指针是一个指向常量的指针，指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变。 附加题指向常量的指针常量该怎么写？答案： 1const int * const b = &amp;a;//指向常量的指针常量]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数源码]]></title>
    <url>%2F2018%2F05%2F23%2F%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2-md%2F</url>
    <content type="text"><![CDATA[strcpy源码：123456789 char *strcpy(char *strDes, const char *strSrc) &#123; assert((strDes != NULL) &amp;&amp; (strSrc != NULL)); char *address = strDes; while ((*strDes ++ = *strSrc ++) != '\0') NULL; return address; 注意：strcpy只是复制字符串，但不限制复制的数量。很容易造成缓冲溢出，也就是说，不过dest有没有足够的空间来容纳src的字符串，它都会把src指向的字符串全部复制到从dest开始的内存 strcmp源码：123456789101112int strcmp(const char *s, const char *t) &#123; assert(s != NULL &amp;&amp; t != NULL); while (*s &amp;&amp; *t &amp;&amp; *s == *t) &#123; ++ s; ++ t; &#125; return (*s - *t); &#125; strcat源码：12345678910111213char *strcat(char *strDes, const char *strSrc) &#123; assert((strDes != NULL) &amp;&amp; (strSrc != NULL)); char *address = strDes; while (*strDes != '\0') ++ strDes; while ((*strDes ++ = *strSrc ++) != '\0') NULL; return address; &#125; 注意：1.不能向形参传递指向字符串常量的指针（本题中dst和src都是指向串常量的指针，字符串常量存储在常量区不能被修改 2.传递的字符数组前一个实参的所分配的内存空间必须足够大 strlen源码：12345678910int strlen(const char *str) &#123; assert(str != NULL); int len = 0; while (*str ++ != '\0') ++ len; return len; &#125; strstr源码：1234567891011121314151617char *strstr(const char *strSrc, const char *str) &#123; assert(strSrc != NULL &amp;&amp; str != NULL); const char *s = strSrc; const char *t = str; for (; *t != '\0'; ++ strSrc) &#123; for (s = strSrc, t = str; *t != '\0' &amp;&amp; *s == *t; ++s, ++t) NULL; if (*t == '\0') return (char *) strSrc; &#125; return NULL; &#125; strchr源码：1234567891011121314char * __cdecl strchr ( constchar * string, int ch )&#123; while (*string &amp;&amp; *string != (char)ch) string++; if (*string == (char)ch) return((char *)string); return(NULL);&#125; 断言：assert（表达式）如果表达式的值为假，整个程序将退出，并输出一条错误信息。如果表达式的值为真则继续执行后面的语句，使用这个宏前需要包含头文件assert.h结语：函数就向一个黑盒一样，调用它的人给他输入（调用它本身就是一种输入），然后等待一个理想中的输出或者是相应的操作。调用者是希望我们的这个函数能够非常健壮的让他们利用，那么为了使我们的函数拥有一定的鲁棒性。]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>程序源码</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2018%2F05%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[测试博客这是一篇测试博客第一次使用github+hexo搭建属于自己的博客.日经过不懈的努力终于搭建好了，我非常开心！！ 2018.5.23 邓铭]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
