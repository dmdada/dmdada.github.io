<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>邓铭的博客</title>
  
  <subtitle>努力不一定成功，不努力一定不成功！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dmdada.top/"/>
  <updated>2018-09-12T03:41:51.389Z</updated>
  <id>http://dmdada.top/</id>
  
  <author>
    <name>邓铭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件测试的方法</title>
    <link href="http://dmdada.top/2018/09/07/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://dmdada.top/2018/09/07/软件测试的方法/</id>
    <published>2018-09-07T14:25:54.000Z</published>
    <updated>2018-09-12T03:41:51.389Z</updated>
    
    <content type="html"><![CDATA[<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>概念：白盒测试是依据被测软件分析程序内部构造，并根据内部构造分析用例，来对内部控制流程进行测试，可完全不顾程序的整体功能实现情况，即已知软件产品的内部实现过程，可以通过测试证明每种内部操作是否符合设计规格的要求，所有内部成分是否已经过检查。<br><a id="more"></a><br>   （2）思想：白盒测试又被称为玻璃盒测试、透明盒测试、开放盒测试、结构化测试、逻辑驱动测试、是基于程序结构的逻辑驱动测试。<br>   (3）测试对象： 函数、算法与数据结构<br>   (4）目的<br>       （1）一般在测试前期进行，通过达到一定的逻辑覆盖率指标，使得软件内部逻辑控制结构上的问题能基本得到消除；<br>       （2）保证内部结构达到一定的覆盖程度，能够给予软件代码质量更大的保证；<br>       （3）白盒测试发现问题后，解决问题的成本较低。</p><p>   (5）白盒测试的常用技术：<br>       （1）静态分析：包括控制流分析、数据流分析、信息流分析<br>       （2）动态分析：逻辑覆盖测试（分支测试、路径测试等）、程序插装等<br>                    逻辑覆盖测试根据覆盖的对象不同，可以分为：语句覆盖、判定（分支）覆盖、条件覆盖、判定条件覆盖、条件组合覆盖、路径覆盖。<br>                    程序插装指调试程序时，在程序中插入一些打印语句，程序执行时打印出我们关心的信息，通过这些信息了解执行过程中程序的一些动态行为。<br>                    逻辑覆盖率的统计通过程序插装来实现。<br>   (6）白盒测试的特点：<br>       （1）测试人员需要了解软件的实现；<br>       （2）可以检测代码中的每条分支和路径；<br>       （3）揭示隐藏在代码中的错误；<br>       （4）对代码的测试比较彻底；<br>       （5）实现代码结构上的优化；<br>       （6）投入较大，成本高；<br>       （7）无法检测代码中遗漏的路径和数据敏感性错误；<br>       （8）不验证规格的正确性。</p><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>(1）)定义：把测试对象看成是一个黑盒，只考虑其整体特性，不考虑其内部具体实现过程。即已知产品的需求规格，但不知其内部实现，可以进行测试证明每个需求是否实现。<br>(2）思想：基于规格的测试，测试类型都来源于质量模型。<br>(3）测试对象：系统、子系统、模块、子模块、函数等。<br>(4）常用的黑盒测试方法：等价类划分法、边界值分析法、因果图分析法、判定表法、状态迁移法等。<br>(5）目的：减少测试时的测试用例数，用尽量少的测试用例完成测试，发现更多的问题。<br>(6）黑盒测试的特点<br>       （1）对于更大的代码单元来说（子系统甚至系统级）比白盒测试效率要高；<br>       （2）测试人员不需要了解软件的实现细节，包括特定的编程语言；<br>       （3）从用户的视角进行测试，很容易被理解和接受；<br>       （4）有助于暴露任何规格不一致或有歧义的问题；<br>       （5）没有清洗和简明的规格，测试用例很难设计；<br>       （6）不能控制内部执行路径，会有很多内部程序路径没有被测试到；<br>       （7）不能直接针对特定的程序段，这些程序可能非常复杂（因此可能隐藏更多的问题）</p><h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><p>（1）定义：按照预先设计的数据和步骤去运行被测软件系统，从而对被测试软件进行检测的一种测试技术。<br>（2）特点：主要分析软件系统在模拟或是真实的环境中执行之前、之中、之后的动态行为。<br>（3）常用技术：动态分析技术<br>（1）定义：对软件系统运行行为进行分析，包含程序在受控的环境下使用特定的输入进行正式的运行，和期望的结果比较以检查系统运行是正确还是不正确。<br>      （2）常用动态分析技术：<br>           1：路径测试<br>           2：分支测试<br>           3：性能测试<br>      （4）常用动态分析工具及功能<br>           1：测试覆盖率分析：用于测试对代码的检测范围；<br>           2：跟踪：跟踪程序执行期间的所有路径<br>           3：调整：度量程序执行过程中所有的资源<br>           4：模拟：模拟系统的部分</p><h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><p> （1）定义：不运行被测试的软件系统，而是采用其他手段和技术对被测试软件进行检测的一种测试技术，例如：代码走读、文档评审、程序分析等。<br>   （2）常用技术：静态分析技术。<br>        （1）定义：静态分析是一种不通过执行程序而分析程序的技术。<br>        （2）功能：检查软件的表示和描述是否一致，没有冲突或者没有歧义<br>        （3）目的：纠正软件系统在描述、表示和规格上的错误，因此是任何进一步测试的前提。<br>        （4）静态分析技术主要有3种不同的程序测试可能性<br>             1：考虑程序是否满足编码规则，语法上是否具有一致性和完整性；<br>             2：考虑文档描述是否规范、准确、便于查阅；<br>             3：考虑程序和文档之间的一致性。<br>        （5）静态分析技术有：控制流分析、数据流分析和信息流分析，下面一一介绍：<br>             控制流分析<br>                 控制流相关概念：<br>                      1、程序元素：一个程序元素通常是一个条件，一个简单的语句或者一块语句（多个连续语句）。<br>                      2、控制流关系：一个程序的控制流关系（Control Flow Relation）叙述了程序元素和他们执行的次序之间的关系。<br>                    　3、控制流图：对应于控制流关系的图被称为控制流图。<br>                  　  4、控制流矩阵：有控制流图得到，反映相邻程序元素之间的先后顺序关系。<br>                 2控制流分析能发现的问题<br>                      通过对控制流信息进行分析，确保写出的程序不应包含：转向并不存在的标号；没用的语句标号；从程序入口进入后无法达到的语句；不能达到停机语句的语句。<br>             数据流分析：<br>                 数据流相关概念:<br>                      数据流分析最初是随着编译系统要生成有效的目标码而出现的，这类方法主要用于代码优化（代码优化主要包含：结构优化即可读性、时间效率和空间效率优化、可移植性优化）。<br>                      数据流分析法关键是数据的引用和定义。<br>                      1、数据的定义：如果程序中某一语句执行时能改变某程序变量V的值，则称V是被该语句定义的。<br>                      2、数据的引用：如果程序中一语句的执行引用了内存中变量V的值，则称V是被该语句引用的。<br>                 2数据流分析步骤<br>                      1、根据代码得到数据流表<br>                      2、分析数据流表找到以下两种错误：<br>                            变量未定义但被引用<br>                            变量定义但未被引用</p><h3 id="手工测试"><a href="#手工测试" class="headerlink" title="手工测试"></a>手工测试</h3><p>(1）定义：手工测试是传统的测试方法，由测试人员手工编写测试用例，执行，观察结果。<br>(2）缺点：测试工作量大，重复多，回归测试难以实现</p><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><p>（1）定义：自动化测试指利用软件测试工具自动实现全部或者部分测试工作：管理、设计、执行和报告，自动化测试节省大量的测试开销，并能够完成一些手工测试无法实现的测试。<br>  （2）自动化测试的意义   :<br>      （1）对程序新版本运行前一版本执行的测试，提高回归测试效率<br>      （2）可以运行更多更频繁的测试<br>      （3）可以执行手工测试困难或不可能做到的测试，比如大量的重复操作或者集成测试<br>      （4）更好的利用资源，比如测试仪器或者被测对象<br>      （5）测试具有一致性和可重复性，及自动化测试的步骤和结果完全一样的测试的复用性，及自动化测试甲苯可以拆分开给其他测试脚本使用<br>      （6）可以更快地将软件推向市场，软件发布前进行高效的回归测试，减少软件发布的时间<br>      （7）增加软件的信任度，通过自动化测试提高了测试效率，可以吧节约的时间拿出来做更多的测试<br>  （3）自动化测试的限制:<br>      （1）不能取代手工测试，自动化测试只能提高测试效率，不能提高测试有效性，即不可能发现更多缺陷更多<br>      （2）对测试设计依赖性极大，测试设计的不好会遗漏问题<br>      （3）自动化测试对软件开发具有很大的依赖性，开发出现变更可能导致前面的自动化测试完全失效<br>      （4）工具本身并不具备想象力，工具不具有智能<br>  （4）自动化测试的误区:<br>      （1）不现实的期望，希望自动化能取代手工测试<br>      （2）缺乏测试实践经验，手工测试都做不好，或者经验积累不够，就尝试自动化，很难成功<br>      （3）期望自动化测试发现大量新缺陷，自动化只能保证测试执行效率，确保已有的问题不会再发生，发现新缺陷不是其目的<br>      （4）安全性错觉，认为进行了自动化测试的软件就是安全的、质量有保证的只有手工测试做好了，明确了测试的观察点，才能把自动化测试做好,所以手工测试是自动化测试的一个基础</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;白盒测试&quot;&gt;&lt;a href=&quot;#白盒测试&quot; class=&quot;headerlink&quot; title=&quot;白盒测试&quot;&gt;&lt;/a&gt;白盒测试&lt;/h3&gt;&lt;p&gt;概念：白盒测试是依据被测软件分析程序内部构造，并根据内部构造分析用例，来对内部控制流程进行测试，可完全不顾程序的整体功能实现情况，即已知软件产品的内部实现过程，可以通过测试证明每种内部操作是否符合设计规格的要求，所有内部成分是否已经过检查。&lt;br&gt;
    
    </summary>
    
    
      <category term="-软件测试" scheme="http://dmdada.top/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境下gdb的使用</title>
    <link href="http://dmdada.top/2018/08/25/Linux%E7%8E%AF%E5%A2%83%E4%B8%8Bgdb%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://dmdada.top/2018/08/25/Linux环境下gdb的使用/</id>
    <published>2018-08-25T15:06:13.000Z</published>
    <updated>2018-08-26T05:14:38.006Z</updated>
    
    <content type="html"><![CDATA[<h3 id="gdb环境搭建"><a href="#gdb环境搭建" class="headerlink" title="gdb环境搭建"></a>gdb环境搭建</h3><p>1.查看是否安装gdb<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep gdb</span><br></pre></td></tr></table></figure></p><p>如果有的话请用以下命令删除<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps+安装包名称</span><br></pre></td></tr></table></figure></p><p>2.安装Texinfo文档系统<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ncurses-devel</span><br></pre></td></tr></table></figure></p><p>3.下载gdb的安装包<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//ftp.gnu.org/gnu/gdb/gdb-7.6.1.tar.gz</span></span><br><span class="line"><span class="comment">//这里建议将安装包重新放到一个新文件夹，例如/home/download</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>4.解压文件夹<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/downloads/</span><br><span class="line">tar -zxvf gdb<span class="number">-7.6</span><span class="number">.1</span>.tar.gz</span><br></pre></td></tr></table></figure></p><p>5.生成makefile<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/downloads/gdb<span class="number">-7.6</span><span class="number">.1</span></span><br><span class="line">./configure</span><br></pre></td></tr></table></figure></p><p>6.安装<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">sudo  make install</span><br></pre></td></tr></table></figure></p><p>7.检查<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -v</span><br></pre></td></tr></table></figure></p><p><img src="http://pajznqooi.bkt.clouddn.com/gdb%E8%B0%83%E8%AF%95.jpg" alt=""><br>结果如图即成功</p><h3 id="gdb调试常用命令"><a href="#gdb调试常用命令" class="headerlink" title="gdb调试常用命令"></a>gdb调试常用命令</h3><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率;</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。<br>continue （简写c ）：继续执行，到下一个断点处（或运行结束）<br>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。<br>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的<br>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。<br>until+行号： 运行至某行，不仅仅用来跳出循环<br>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。<br>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)<br>quit：简记为 q ，退出gdb</p><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>break n （简写b n）:在第n行处设置断点<br>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）<br>b fn1 if a＞b：条件断点设置<br>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button<br>delete 断点号n：删除第n个断点<br>disable 断点号n：暂停第n个断点<br>enable 断点号n：开启第n个断点<br>clear 行号n：清除第n行的断点<br>info b （info breakpoints） ：显示当前程序的断点设置情况<br>delete breakpoints：清除所有断点：</p><h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><p>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。<br>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12<br>list 函数名：将显示“函数名”所在函数的源代码，如：list main<br>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</p><h3 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h3><p>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。<br>print a：将显示整数 a 的值<br>print ++a：将把 a 中的值加1,并显示出来<br>print name：将显示字符串 name 的值<br>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数<br>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数<br>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a<br>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a<br>whatis ：查询变量或函数<br>info function： 查询函数<br>扩展info locals： 显示当前堆栈页的所有变量</p><h3 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h3><p>where/bt ：当前运行的堆栈列表；<br>bt backtrace 显示当前调用堆栈<br>up/down 改变堆栈显示的深度<br>set args 参数:指定运行时的参数<br>show args：查看设置好的参数<br>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</p><h3 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h3><p>layout：用于分割窗口，可以一边查看代码，一边测试：<br>layout src：显示源代码窗口<br>layout asm：显示反汇编窗口<br>layout regs：显示源代码/反汇编和CPU寄存器窗口<br>layout split：显示源代码和反汇编窗口<br>Ctrl + L：刷新窗口</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;gdb环境搭建&quot;&gt;&lt;a href=&quot;#gdb环境搭建&quot; class=&quot;headerlink&quot; title=&quot;gdb环境搭建&quot;&gt;&lt;/a&gt;gdb环境搭建&lt;/h3&gt;&lt;p&gt;1.查看是否安装gdb&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rpm -qa | grep gdb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果有的话请用以下命令删除&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rpm -e --nodeps+安装包名称&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2.安装Texinfo文档系统&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install ncurses-devel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3.下载gdb的安装包&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget http:&lt;span class=&quot;comment&quot;&gt;//ftp.gnu.org/gnu/gdb/gdb-7.6.1.tar.gz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//这里建议将安装包重新放到一个新文件夹，例如/home/download&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://dmdada.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IP数据报格式</title>
    <link href="http://dmdada.top/2018/08/20/TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    <id>http://dmdada.top/2018/08/20/TCP-IP协议族/</id>
    <published>2018-08-20T14:41:37.000Z</published>
    <updated>2018-08-21T09:30:26.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><p>IP数据报的格式能够说明IP协议都具有什么功能，IP数据报分为首部和数据两个部分，首部格式为固定长度的20字节，是所有IP数据报所都具有的。在首部的国定部分后面是一些可选部分。其长度是可变的，下图展示了IP数据报的格式，我们着重并解释其各首部字段意义。<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/IP%E6%95%B0%E6%8D%AE%E6%8A%A5.jpg" alt="404"><br>(1)版本占4位,指IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4(即Pv4)。关于以后要使用的IPv6(即版本6的IP协议)。</p><p>(2)首部长度占4位,可表示的最大十进制数值是15。请注意,首部长度字段所表示数的单位是32位字(1个32位字长是4字节)。因此,首部长度字段的最小值是5(即进制的0101),相当于IP首部长度为5×4=20字节。而当首部长度为1111时(即十进制的15),首部长度就达到最大值15个32位字长即60字节。当IP分组的首部长度不是4字节的整数倍时,必须利用最后的填充字段加以填充。因此IP数据报的数据部分永远在4字节的整数倍时开始,这样在实现IP协议时较为方便。首部长度限制为60字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是20字节(即首部长度为0101),这时不使用任何选项。</p><p>(3)区分服务古8位,用来获得更好的服务。这个字段在旧标准中叫做服务类型,但实际上一直没有被使用过。1998年IETF把这个字段改名为区分服务DS只有在使用区分服务时,这个字段才起作用在一般的情况下都不使用这个字段。</p><p>(4)总长度总长度指首部和数据之和的长度,单位为字节。总长度字段为16位,因此数据报的最大长度为216-1=65535字节。然而实际上传送这样长的数据报在现实中是极少遇到的。我们知道,在IP层下面的每一种数据链路层协议都规定了一个数据帧中的数据字段的最大长度,这称为最大送单元MTU( Maximum transfer Unit)。当一个P数据报封装成链路层的帧时,此数据报的总长度(即首部加上数据部分)一定不能超过下面的数据链路层所规定的MTU值。例如,最常用的以太网就规定其MTU值是1500字节。若所传送的数据报长度超过数据链路层的MTU值,就必须把过长的数据报进行分片处理。</p><p>(5)标识( identification)占16位。IP软件在存储器中维持一个计数器,每产生一个数据报,计数器就加1,并将此值赋给标识字段。但这个“标识”并不是序号,因为IP是无连接服务,数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时,这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报</p><p>(6)标志ag)占3位,但目前只有两位有意义。标志字段中的最低位记为MF( More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。标志字段中间的一位记为DF( Dont Fragment),意思是“不能分片”。只有当DF=0，寸才允许分片。</p><p>(7)片偏移占13位。片偏移指出:较长的分组在分片后,某片在原分组中的相对位置。也就是说,相对于用户数据字段的起点,该片从何处开始。片偏移以8个字节为偏移单位。这就是说,每个分片的长度一定是8字节(64位)的整数倍。<br>(8)生存时间占8位,生存时间字段常用的英文缩写是 TTL(表明据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子(例如从路由器R1转发到R2,再转发到R3,然后又转发到R1),因而白白消耗网络资源。最初的设计是以秒作为TIL值的单位。每经过一个路由器时,就把TIL减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于1秒,就把TIL值减1。当TTL值减为零时,就丢弃这个数据报。然而,随着技术的进步,路由器处理数据报所需的时间不断在缩短,一般都远远小于1秒钟,后来就把TTL字段的功能改为“跳数限制”(但名称不变)。路由器在转发数据报之前就把TIL值减1。若TIL值减小到零,就丢弃这个数据报,不再转发。因此,现在TTL的单位不再是秒,而是跳数。TTL的意义是指明数据报在因特网中至多可经过多少个路由器。显然,数据报能在因特网中经过的路由器的最大数值是255。若把TTL的初始化设置为1,就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器,在被转发之前TIL值就减小到零,因而就会被这个路由器丢弃。<br>(9)协议占8位,协议字段指出此数据报携带的数据是使用何种协议,以便使目的主机的IP层知道应将数据部分上交给哪个处理过程。常用的一些协议和相应的协议字段值如下:</p><table><thead><tr><th>协议名</th><th>ICMP</th><th>IGMP</th><th>IP</th><th>TCP</th><th>EGP</th><th>IGP</th><th>UDP</th><th>IPV6</th><th>ESP</th><th>OSPF</th></tr></thead><tbody><tr><td>协议字段值</td><td>1</td><td>2</td><td>4</td><td>6</td><td>8</td><td>9</td><td>17</td><td>41</td><td>50</td><td>89</td></tr></tbody></table><p>(10)首部检验和占16位。这个字段只检验数据报的首部,但不包括数据部分。这是因为数据报每经过一个路由器,路由器都要重新计算一下首部检验和(一些字段,如生存时间、标志、片偏移等都可能发生变化)。不检验数据部分可减少计算的工作量。为了进步减小计算检验和的工作量,IP首部的检验和不采用复杂的CRC检验码而采用下面的简单计算方法:在发送方,先把IP数据报首部划分为许多16位字的序列,并把检验和字段置零。反码算术运算把所有16位字相加后,将得到的和的反码写入检验和字段。接收方收到数据报后,将首部的所有16位字再使用反码算术运算相加一次。将得到的和取反码,即得出接收方检验和的计算结果。若首部未发生任何变化,则此结果必为0,于是就保留这个数据报。否则即认为出差错,并将此数据报丢弃。下图为校验和计算过程<br><img src="http://pajznqooi.bkt.clouddn.com/%E6%A0%A1%E9%AA%8C%E5%92%8C%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B%E3%80%81.jpg" alt=""><br>(11)源地址：占32位。<br>(12)目的地址：占32位。</p><h3 id="关于IP数据报的可变部分"><a href="#关于IP数据报的可变部分" class="headerlink" title="关于IP数据报的可变部分"></a>关于IP数据报的可变部分</h3><p>IP首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施,内容很丰富。此字段的长度可变,从1个字节到40个字节不等,取决于所选择的项目。某些选项项目只需要1个字节,它只包括1个字节的选项代码。但还有些选项需要多个字节,这些选项一个个拼接起来,中间不需要有分隔符,最后用全0的填充字段补齐成为4字节的整数倍。<br>增加首部的可变部分是为了增加IP数据报的功能,但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用很多路由器都不考虑IP首部的选项字段,因此新的IP版本IPV6就把IP数据报的首部长度做成固定的。这里就不讨论这些选项的细节了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;IP数据报&quot;&gt;&lt;a href=&quot;#IP数据报&quot; class=&quot;headerlink&quot; title=&quot;IP数据报&quot;&gt;&lt;/a&gt;IP数据报&lt;/h3&gt;&lt;p&gt;IP数据报的格式能够说明IP协议都具有什么功能，IP数据报分为首部和数据两个部分，首部格式为固定长度的20字节，是所有IP数据报所都具有的。在首部的国定部分后面是一些可选部分。其长度是可变的，下图展示了IP数据报的格式，我们着重并解释其各首部字段意义。&lt;br&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://dmdada.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>selset、poll、epoll的优缺点</title>
    <link href="http://dmdada.top/2018/08/16/selset%E3%80%81poll%E3%80%81epoll%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <id>http://dmdada.top/2018/08/16/selset、poll、epoll的优缺点/</id>
    <published>2018-08-16T15:13:17.000Z</published>
    <updated>2018-08-17T10:33:12.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>Select用来实现多路复用输入/输出模型<br>&ensp;1.Select系统调用是用来让我们程序监视多个文件描述符的状态变化<br>&ensp;2.程序会停在select这里等待，直到被监视文件描述符有了一个或者多个发生了状态改变；</p><p>函数原型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds,fd_set *writefds,fd_set* exceptfds,struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure></p><p>1.参数ndfs是需要监视的最大的文件描述符值+1。<br>2.rdset,wrset,exset分别对应需要检测的可读文件描述符的集合，可写文件描述符集合及异常文件描述符集合。<br>3.参数timeout为结构timeval, 用来设置Select的等待时间。<br>4.关于fd_set结构:其实这个结果是一个整形数组，更严格的说，它是一个位图，使用位图对应的位来表示需要监视的文件描述符。<br>系统提供了一组fd_set调用接口，用来操作位图。<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd,fd_set * <span class="built_in">set</span>)</span></span>;<span class="comment">//用来清除描述词组set中的相关fd位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd,fd_set * <span class="built_in">set</span>)</span></span>;<span class="comment">//用来测试描述词组set相关fd位是否为真</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set * <span class="built_in">set</span>)</span></span>;<span class="comment">//用来设置描述词组set中相关fd的位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set* <span class="built_in">set</span>)</span></span>;<span class="comment">//用来清除描述词组中set的全部位</span></span><br></pre></td></tr></table></figure><p>函数返回值：<br>1.执行成功返回文件描述符的改变个数。<br>2。如果返回0代表timewait时间超时，没有返回。<br>3.当返回-1，出现错误。</p><p>Select的特点：<br>1.可监控文件描述符个数sizeof(fd_set)的值 ，每个比特位表示监控一个文件描述符。<br>2.将fd加入select监控集的同时还要使用一个数据结构array保存放到select监控集中的fd.用于返回数据与源数据比较，二是select返回会将没事发生的文件描述符删除，但每次开始select需要重新设置，扫描array取得fd最大值maxfd，用于select的第一个参数。</p><p>Select的缺点：<br>1.每次调用select都需要手动设置fd集合，从接口使用角度来说也非常不便。<br>2.每次调用select，都需要从用户态拷贝到内核态，这个开销在fd很大时会很大。<br>3.每次的调用传入的select都需要在内核遍历传进来的所有fd，这个开销在fd很大时会很大。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct poll* fds，<span class="keyword">nfds_t</span> nfds，<span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">//pollfd结构</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">short</span> events;</span><br><span class="line"><span class="keyword">short</span> revents;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：fds是一个poll函数监听的结构列表，每一个元素中，包含了三部分内容：文件描述符，监听的事件、返回事件的集合。<br>ndfs表示fds数组的长度。<br>timeout表示poll函数的超时时间，单位是毫秒（ms)。</p><p>返回值：小于0表示出错，等于0表示等待超时，大于0表示poll由于监听的文件描述符就绪而返回。</p><p>poll的优点：<br>1.不同与select使用3个位图来表示三个fd_set的方式，poll使用一个pollfd的指针实现。<br>2.pollfd结构包含了要监视的event和发生的envent，不再使用select参数-值传递的方式，接口使用比select更方便。<br>3.poll并没有最大数量限制。</p><p>poll的缺点：<br>当poll中监听的文件描述符数目增多时：<br>1.和select一样，poll返回后，需要轮询pollfd来获取就绪的描述符。<br>2.每次调用poll都需要把大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视描述符数量上升，其效率也会线性下降。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是为了处理大量句柄，而对poll的改进。<br>epoll的相关调用.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">//创建一个epoll句柄</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_creat</span><span class="params">(<span class="keyword">int</span> size)</span><span class="comment">//size常忽略</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd,<span class="keyword">int</span> op ,<span class="keyword">int</span> fd,struct epoll_event *event)</span></span>;<span class="comment">//epoll的时间注册函数</span></span><br></pre></td></tr></table></figure></p><p>其中epoll_ctl第一个参数是 epoll_creat的返回值，第二个参数表示动作，用三个宏表示，第三个参数表示要监听的fd,第四个参数是要告诉内核需要监听什么事。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd,struct epoll_evnet* events,<span class="keyword">int</span> maxevents,<span class="keyword">int</span> timeout )</span></span>;</span><br></pre></td></tr></table></figure><p>1.参数events是分配好的epoll_event数组。<br>2.epoll将会把发生的时间赋值到events数组中（events不可以是空指针，内核只负责把数据复制到这个events数组中，不会去帮我们在用户态中分配内存）。<br>3.maxevents告诉enents有多大，这个maxevents的值不能大于创建epoll_creat()时的size。<br>4.参数timeout是超时时间。<br>5.如果调用函数成功，返回对应I/O上已经准备好的文件描述符数目，如果返回0表示已超时，返回小于0表示函数失败。</p><p>因此使用epoll的过程就是三部曲：<br>1.调用epoll_creat创建一个epoll句柄。<br>2.调用epoll_ctr,将要监控的文件描述符进行注册<br>3.调用epoll_wait,等待文件描述符就绪。</p><p>epoll的优点：<br>1.文件描述符数目无上限。<br>2.基于事件就绪通知方式：一旦被监听的某个文件描述符就绪，内核会采用类似于回掉函数，迅速激活文件描述符。<br>3.维护就绪队列：当文件描述符就绪，就会被放到把内核中的一个就绪队列，这样调用epoll_wait就绪文件描述符的时候，只取队列元素即可，操作的时间复杂度是O(1)。<br>4.内存映射机制：内核直接将就绪队列通过mmap的方式映射到用户态，避免了拷贝内存的开销。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Select&quot;&gt;&lt;a href=&quot;#Select&quot; class=&quot;headerlink&quot; title=&quot;Select&quot;&gt;&lt;/a&gt;Select&lt;/h3&gt;&lt;p&gt;Select用来实现多路复用输入/输出模型&lt;br&gt;&amp;ensp;1.Select系统调用是用来让我们程序监视多个文件描述符的状态变化&lt;br&gt;&amp;ensp;2.程序会停在select这里等待，直到被监视文件描述符有了一个或者多个发生了状态改变；&lt;/p&gt;
&lt;p&gt;函数原型：&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/select.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nfds, fd_set* readfds,fd_set *writefds,fd_set* exceptfds,struct timeval *timeout)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;1.参数ndfs是需要监视的最大的文件描述符值+1。&lt;br&gt;2.rdset,wrset,exset分别对应需要检测的可读文件描述符的集合，可写文件描述符集合及异常文件描述符集合。&lt;br&gt;3.参数timeout为结构timeval, 用来设置Select的等待时间。&lt;br&gt;4.关于fd_set结构:其实这个结果是一个整形数组，更严格的说，它是一个位图，使用位图对应的位来表示需要监视的文件描述符。&lt;br&gt;系统提供了一组fd_set调用接口，用来操作位图。&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://dmdada.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>指针和引用的区别</title>
    <link href="http://dmdada.top/2018/08/14/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://dmdada.top/2018/08/14/指针和引用的区别/</id>
    <published>2018-08-14T14:01:42.000Z</published>
    <updated>2018-09-04T11:31:23.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="指针和引用的定义"><a href="#指针和引用的定义" class="headerlink" title="指针和引用的定义"></a>指针和引用的定义</h3><p>指针：指针是一个变量，储存着指向变量的地址，通过对地址的解引用实现对变量的读取或者更改。<br>引用：引用是一个变量的别名，本质上和变量是一个东西.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=&amp;a;</span><br><span class="line"><span class="keyword">int</span> &amp;b=a;</span><br></pre></td></tr></table></figure></p><p>这里定义了一个指针p保存了a的地址，而定义了一个引用b，给a取了一个别名。a和b是一个东西在空间上占用同一个地址。</p><a id="more"></a><h3 id="一些其他的不同"><a href="#一些其他的不同" class="headerlink" title="一些其他的不同"></a>一些其他的不同</h3><p>１.引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。</p><p>２.可以有const指针，但是没有const引用。</p><p>3.指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）。</p><p>4.指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化。</p><p>5.指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。</p><p>6.sizeof引用得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小。</p><p>7.指针和引用的自增(++)运算意义不一样。</p><p>8.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏。</p><h3 id="指针值传递"><a href="#指针值传递" class="headerlink" title="指针值传递"></a>指针值传递</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ptr</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    p=&amp;a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    ptr(p);</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"指针p为NULL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：0x6fc12e  1<br>     指针p为NULL</p><p>因为这里传递的指针也是对p的一份临时拷贝，你不能通过形参而改变实参。要解决这种问题你只能传二级指针或者传引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ptr</span><span class="params">(<span class="keyword">int</span> *&amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">    a=&amp;b;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;*a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>*p=&amp;a;</span><br><span class="line">    ptr(p);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>      0x12ff44 2<br>      0x12ff44 2</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;指针和引用的定义&quot;&gt;&lt;a href=&quot;#指针和引用的定义&quot; class=&quot;headerlink&quot; title=&quot;指针和引用的定义&quot;&gt;&lt;/a&gt;指针和引用的定义&lt;/h3&gt;&lt;p&gt;指针：指针是一个变量，储存着指向变量的地址，通过对地址的解引用实现对变量的读取或者更改。&lt;br&gt;引用：引用是一个变量的别名，本质上和变量是一个东西.&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p=&amp;amp;a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp;b=a;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里定义了一个指针p保存了a的地址，而定义了一个引用b，给a取了一个别名。a和b是一个东西在空间上占用同一个地址。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://dmdada.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>TCP的拥塞控制和流量控制</title>
    <link href="http://dmdada.top/2018/08/10/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <id>http://dmdada.top/2018/08/10/TCP的拥塞控制和流量控制/</id>
    <published>2018-08-10T10:29:42.000Z</published>
    <updated>2018-08-11T04:24:12.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP的的流量控制"><a href="#TCP的的流量控制" class="headerlink" title="TCP的的流量控制"></a>TCP的的流量控制</h3><p>1.利用滑动窗口实现流量控制<br>&emsp;&emsp;一般来说我们希望发送方的发送速率越高，这样数据的传输率可能就变得高一点，但是如果发送方数据传输的过快，接受方可能来不及接收，这就会造成数据的丢失。，所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接受。<br>利用TCP的滑动窗口可以很方便的对流量进行控制</p><p>&emsp;&emsp;现在假设A向B发送消息，在连接建立时B告诉A我的接收窗口是400，因此发送方的发送窗口不能超过接收方的接受窗口的数值，注意TCP的滑动窗口是字节为单位并不是报文段，现在假设每个报文段大小为100字节。<br>并且数据段报文序号初始值为1。<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" alt="404"><br>&emsp;&emsp;我们因该注意到上图接受主机进行了3次流量控制，第一次把窗口减小到rwnd=300,第二次又减小到rwnd=100,第三次减小到0，即不予许再发送了。这种发送暂停的等待状态会持续到主机A收到B新的确认报文，三个确认报文都设置了ACK=1，切记当ACK=1时确认才有意义。<br>现在我们考虑另一种情况，现假设B给A发送0窗口报文后，现在又有了新的缓存空间。所以给A发送窗口值=400的报文段，可此报文段由于网络问题丢失了，此时B在等待A发数据，A在等待B发窗口值改变的报文。如果没有其他措施这种死锁局面就会一直延续下去。<br>为了解决这种问题TCP为每个连接都设置了一个持续计时器，只要对方设置了0窗口，就启动持续计时器开始计时，若果超时就会发送一个零窗口探测报文（只携带一个字节），对方收到探测报文就会给出现在的窗口值，若窗口依然是0，就继续等待，若不是则打破僵局。</p><h3 id="考虑传输效率"><a href="#考虑传输效率" class="headerlink" title="考虑传输效率"></a>考虑传输效率</h3><p>&emsp;&emsp;前面已经讲过,应用进程把数据传送到TCP的发送缓存后,剩下的发送任务就由TCP来控制了。可以用不同的机制来控制TCP报文段的发送时机。例如,第一种机制是TCP维持一个变量,它等于最大报文段长度MSS。只要缓存中存放的数据达到MsS字节时,就组装成一个TCP报文段发送出去。第二种机制是由发送方的应用进程指明要求发送报文段即TCP支持的推送(push)操作。第三种机制是发送方的一个计时器期限到了,这时就把当前已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。<br>&emsp;&emsp;但是,如何控制TCP发送报文段的时机仍然是一个较为复杂的问题。例如,一个交互式用户使用一条 TELNET连接(运输层为TCP协议)。假设用户只发1个字符。加上20字节的首部后,得到21字节长的TCP报文段。再加上20字节的IP首部,形成41字节长的IP数据报。在接收方TCP立即发出确认,构成的数据报是40字节长(假定没有数据发送)。若用户要求远地主机回送这一字符,则又要发回41字节长的IP数据报和40字节长的确认IP数据报。这样,用户仅发1个字符时线路上就需传送总长度为162字节共4个报文段。当线路带宽并不富裕时,这种传送方法的效率的确不高。因此应适当推迟发回确认报文,并尽量使用捎带确认的方法在TCP的实现中广泛使用 Nagle算法。算法如下:若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存,则发送方就把第一个数据字节先发送出去,把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后,再把发送缓存中的所有数据组装成一个报文段发送出去,同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时,用这样的方法可明显地减少所用的网络带宽。 Nagle算法还规定,当到达的数据已达到发送窗口大小的半或已达到报文段的最大长度时,就立即发送一个报文段。这样做,就可以有效地提高网络的吞吐量。<br>&emsp;&emsp;另一个问题叫做糊涂窗口综合症( silly window syndrome)RFC813],有时也会使TCP的性能变坏。设想一种情况:TCP接收方的缓存已满,而交互式的应用进程一次只从接收缓存中读取1个字节(这样就使接收缓存空间仅腾出1个字节),然后向发送方发送确认,并把窗口设置为1个字节(但发送的数据报是40字节长)。接着,发送方又发来1个字节的数据(请注意,发送方发送的IP数据报是41字节长)。接收方发回确认,仍然将窗口设置为1个字节。这样进行下去,使网络的效率很低。<br>&emsp;&emsp;要解决这个问题,可以让接收方等待一段时间,使得或者接收缓存已有足够空间容纳一个最长的报文段,或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一,接收方就发出确认报文,并向发送方通知当前的窗口大小。此外,发送方也不要发送太小的报文段,而是把数据积累成足够大的报文段,或达到接收方缓存的空间的一半大小。<br>上述两种方法可配合使用。使得在发送方不发送很小的报文段的同时,接收方也不要在缓存刚刚有了一点小的空间就急忙把这个很小的窗口大小信息通知给发送方。</p><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><p>&emsp;&emsp;计算机里的链路容量，交换节点的缓存，处理机等这些都是有限的网络资源，若某段时间对资源的需求大于本身资源的负载，就会使网络性能变坏，这时就出现了拥塞。我们可以发现以下条件<br><code>拥塞=对资源的需求&gt;可用资源</code><br>&emsp;&emsp;若网络中有许多资源同时呈现供应不足,网络的性能就要明显变坏,整个网络的吞吐量将随输入负荷的增大而下降。有人可能会说:“只要任意增加一些资源,例如,把结点缓存的存储空间扩大,或把链路更换为更高速率的链路,或把结点处理机的运算速度提高,就可以解决网络拥塞的问题。”其实不然。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法,在许多情况下,不但不能解决拥塞问题,而且还可能使网络的性能更坏。<br>&emsp;&emsp;网络拥塞往往是由许多因素引起的。例如,当某个结点缓存的容量太小时,到达该结点的分组因无存储空间暂存而不得不被丢弃。现在设想将该结点缓存的容量扩展到非常大。于是凡到达该结点的分组均可在结点的缓存队列中排队,不受任何限制。由于输出链路的容量和处理机的速度并未提高,因此在这队列中的绝大多数分组的排队等待时间将会大大增加,结果上层软件只好把它们进行重传(因为早就超时了)。由此可见,简单地扩大缓存的存储空间同样会造成网络资源的严重浪费,因而解决不了网络拥塞的问题。<br>&emsp;&emsp;又如,处理机处理的速率太慢可能引起网络的拥塞。简单地将处理机的速率提高,可能会使上述情况缓解一些,但往往又会将瓶颈转移到其他地方。问题的实质往往是整个系统的各个部分不匹配。只有所有的部分都平衡了,问题才会得到解决。拥塞常常趋于恶化。如果一个路由器没有足够的缓存空间,它就会丢弃一些新到的分组。但当分组被丢弃时,发送这一分组的源点就会重传这一分组,甚至可能还要重传多次这样会引起更多的分组流入网络和被网络中的路由器丢弃。可见拥塞引起的重传并不会缓解网络的拥塞,反而会加剧网络的拥塞。<br>&emsp;&emsp;拥塞控制与流量控制的关系密切,它们之间也存在着一些差别。所谓拥塞控制就是防止过多的数据注入到网络中,这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提,就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程,涉及到所有的主机、所有的路由器,以及与降低网络传输性能有关的所有因素。但TCP连接的端点只要迟迟不能收到对方的确认信息,就猜想在当前网络中的某处很可能发生了拥塞,但这时却无法知道拥塞到底发生在网络的何处,也无法知道发生拥塞的具体原因(是访问某个服务器的通信量过大?还是在某个地区出现了自然灾害)。<br>&emsp;&emsp;相反,流量控制往往指点对点通信量的控制,是个端到端的问题(接收端控制发送端)。流量控制所要做的就是抑制发送端发送数据的速率,以便使接收端来得及接收。可以用个简单例子说明这种区别。设某个光纤网络的链路传输速率为1000Gb/s。有一个巨型计算机向一个PC机以1Gb/s的速率传送文件。显然,网络本身的带宽是足够大的,因而不存在产生拥塞的问题。但流量控制却是必需的,因为巨型计算机必须经常停下来,以便使PC机来得及接收。<br>&emsp;&emsp;但如果有另一个网络,其链路传输速率为1Mb/s,而有1000台大型计算机连接在这个网络上。假定其中的500台计算机分别向其余的500台计算机以100kb/s的速率发送文件。那么现在的问题已不是接收端的大型计算机是否来得及接收,而是整个网络的输入负载是否超过网络所能承受的。拥塞控制和流量控制之所以常常被弄混,是因为某些拥塞控制算法是向发送端发送控制报文,并告诉发送端,网络已出现麻烦,必须放慢发送速率。这点又和流量控制是很相似的。<br>&emsp;&emsp;进行拥塞控制需要付出代价。这首先需要获得网络内部流量分布的信息。在实施拥塞控制时,还需要在结点之间交换信息和各种命令,以便选择控制的策略和实施控制。这样就产生了额外开销。拥塞控制有时需要将一些资源(如缓存、带宽等)分配给个别用户(或些类别的用户)单独使用,这样就使得网络资源不能更好地实现共享。十分明显,在设计拥塞控制策略时,必须全面衡量得失。<br>&emsp;&emsp;在图中的横坐标是提供的负载( offered load),代表单位时间内输入给网络的分组数目。因此提供的负载也称为输入负载或网络负载。纵坐标是吞吐量( throughput),代表单位时间从网络输出的分组数目。具有理想拥塞控制的网络,在吞吐量饱和之前,网络吞吐量应等于提供的负载,故吞吐量曲线是45°的斜线。但当提供的负载超过某一限度时,由于网络资源受限,吞吐量不再增长而保持为水平线,即吞吐量达到饱和。这就表明提供的负载中有一部分损失掉了(例如,输入到网络的某些分组被某个结点丢弃了)。虽然如此,在这种理想的拥塞控制作用下,网络的吞吐量仍然维持在其所能达到的最大值<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" alt="404"><br>但在实际的情况下无拥塞控制计划，随着网络吞吐量增长速率减小，网络会轻度拥塞，继续负载则会死锁。</p><h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><p>&emsp;&emsp;慢开始并不是指窗口值增长速率慢，而是指TCP最开始将窗口值设置为1，然后逐渐增长，这样的方式使得并不是一开始就将过量数据注入网络，先试探一下你，网络是否拥堵，然后在进行逐步增大。<br>为了防止拥塞窗口cwnd增长过大引起网络拥塞,还需要设置一个慢开始门限 ssthresh状态变量(如何设置 ssthresh,后面还要讲)。慢开始门限 ssthresh的用法如下:<br>当cwnd&lt; ssthresh时,使用上述的慢开始算法。<br>当cwnd&gt; ssthresh时,停止使用慢开始算法而改用拥塞避免算法。<br>当cwnd= ssthresh时,既可使用慢开始算法,也可使用拥塞避免算法。<br>&emsp;&emsp;拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大,即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1,而不是加倍。这样,拥塞窗口cwnd按线性规律缓慢增长,比慢开始算法的拥塞窗口增长速率缓慢得多。无论在慢开始阶段还是在拥塞避免阶段,只要发送方判断网络出现拥塞(其根据就是没有按时收到确认),就要把慢开始门限 ssthresh设置为出现拥塞时的发送方窗口值的一半(但不能小于2)。然后把拥塞窗口cwnd重新设置为1,执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数,使得发生拥塞的路由器有足够时间把队列中积<br>压的分组处理完毕。<br>&emsp;&emsp;下图用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。<br><img src="http://pajznqooi.bkt.clouddn.com/%E6%85%A2%E5%BC%80%E5%A7%8B.jpg" alt="404"><br>&emsp;&emsp;在执行慢开始算法时,拥塞窗口cwnd的初始值为1。以后发送方每收到一个对新报文段的确认ACK,就把拥塞窗口值加1,然后开始下一轮的传输(请注意,图的横坐标是传输轮次)。因此拥塞窗口cwd随着传输轮次按指数规律增长。当拥塞窗口cwd增长到慢开始门限值 ssthresh时(即当cwnd=16时),就改为执行拥塞避免算法,拥塞窗口按线性规律增长。</p><h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p>&emsp;&emsp;上面讲的慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法。1990年又增加了两个新的拥塞控制算法。这就是快重传和快恢复<br>提出这两个算法是基于如下的考虑:<br>如果发送方设置的超时计时器时限已到但还没有收到确认,那么很可能是网络出现了拥塞,致使报文段在网络中的某处被丢弃。在这种情况下,TCP马上把拥塞窗口cwnd减小到1,并执行慢开始算法,同时把慢开始门限值 ssthresh减半,如前图所示。这是不使用快重传的情况。<br>那快重传是怎么样的呢，快重传中如某次发送方发送数据丢失，接收方由于后续确认只能确认收到的最低序号确认则会对没收到的序号-1，进行确认并希望收到缺失的序号，如果，发送方连续三次收到了B对某数据的缺失确认则立即发送此数据报文，而不用等待此数据的重传计时器。<br>因此使用传重传能使网络吞吐量提高20%。<br>&emsp;&emsp;与快重传配合使用的还有快恢复算法,其过程有以下两个要点:<br>(1)当发送方连续收到三个重复确认时,就执行“乘法减小”算法,把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意,接下去不执行慢开始算法。<br>(2)由于发送方现在认为网络很可能没有发生拥塞(如果网络发生了严重的拥塞,就不会一连有好几个报文段连续到达接收方,也就不会导致接收方连续发送重复确认),因此与慢开始不同之处是现在不执行慢开始算法(即拥塞窗口cwd现在不设置为1),而是把cwnd值设置为慢开始门限ssthresh减半后的数值,然后开始执行拥塞避免算法(“加法增大”),使拥塞窗口缓慢地线性增大,下图给出了快重传和快恢复的示意图,并标明了“ TCPReno版本”,这是目前使用得很广泛的版本。图中还画出了已经废弃不用的虚线部分( TCP Tahoe版本)。请注意它们的区别就是:新的 TCP Reno版本在快重传之后采用快恢复算法而不是采用慢开始算法<br>&emsp;&emsp;请注意,也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一些(增大3个报文段的长度),即等于 ssthresh+3×MSS。这样做的理由是:既然发送方收到三个重复的确认,就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方<br>的缓存中(接收方发送出三个重复的确认就证明了这个事实)。可见现在网络中并不是堆积了三个分组，而是减少了三个分组，此时可适当加大拥塞窗口。<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%BF%AB%E6%81%A2%E5%A4%8D.jpg" alt="404"><br>&emsp;&emsp;在采用快恢复算法时,慢开始算法只是在TCP连接建立时和网络岀现超时时才使用釆用这样的拥塞控制方法使得TCP的性能有明显的改进<br>在里开始我们就假定了接收方总是有足够大的缓存空间,因而发送窗口的大小由网络的拥塞程度来决定。但实际上接收方的缓存空间总是有限的。接收方根据自己的接收能力设定了接收窗口rwnd,并把这个窗口值写入TCP首部中的窗口字段,传送给发送方。因此,接收窗口又称为通知窗口( advertised window)。因此,从接收方对发送方的流量控制的角度考虑,发送方的发送窗口一定不能超过对方给出的接收窗口值rwnd。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TCP的的流量控制&quot;&gt;&lt;a href=&quot;#TCP的的流量控制&quot; class=&quot;headerlink&quot; title=&quot;TCP的的流量控制&quot;&gt;&lt;/a&gt;TCP的的流量控制&lt;/h3&gt;&lt;p&gt;1.利用滑动窗口实现流量控制&lt;br&gt;&amp;emsp;&amp;emsp;一般来说我们希望发送方的发送速率越高，这样数据的传输率可能就变得高一点，但是如果发送方数据传输的过快，接受方可能来不及接收，这就会造成数据的丢失。，所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接受。&lt;br&gt;利用TCP的滑动窗口可以很方便的对流量进行控制&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;现在假设A向B发送消息，在连接建立时B告诉A我的接收窗口是400，因此发送方的发送窗口不能超过接收方的接受窗口的数值，注意TCP的滑动窗口是字节为单位并不是报文段，现在假设每个报文段大小为100字节。&lt;br&gt;并且数据段报文序号初始值为1。&lt;br&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://dmdada.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP可靠传输的实现</title>
    <link href="http://dmdada.top/2018/08/09/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://dmdada.top/2018/08/09/TCP可靠传输的实现/</id>
    <published>2018-08-09T14:38:32.000Z</published>
    <updated>2018-08-10T10:28:59.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP可靠传输的原理"><a href="#TCP可靠传输的原理" class="headerlink" title="TCP可靠传输的原理"></a>TCP可靠传输的原理</h3><p> 我们都知道，TCP发送的报文段是交付给IP层传送的。但IP层只提供尽最大努力传输，因此是不可靠的，因此TCP必须采用适当的措施才能使两个运输层之间通信变得可靠。<br> 理想的传输条件有以下两个特点：<br> 1.传输信道无差错<br> 2.不管发送方以什么样的发送速率，接收方都能来得及处理发送方发送的消息。<br>然而实际上并不存在这样理想的传输条件，因此我们必须采用一些必要的措施保证实现可靠传输。</p><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p>这里我们讨论单方向的发送和接受，设A为发送方B为接收方。A每发完一个分组就等待B收到分组的确认，然后才发送下一个分组。<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93.jpg" alt="404"><br>上图a介绍了无差错的情况，b图展示若出现差错的应对机制，若B发给A的确认报文在途中丢失，B对于自己的报文丢没有并不清楚，它只等待A传入下个数据包，而A也在等B的确认报文，发现这种情况怎么办呢。超时重传了解一下，超时重传就是为了解决这个问题，当A在一定时间内没有收到B的确认，就认为自己发送的数据报文B没有收到，并且重发这段数据，如果这计时器规定时间内收到了A的确认就撤销计时器。<br>应当注意以下三点：<br>1.A没有收到B的确认报文时，必须暂时的保留已发送的分组副本，以便于超时重传。<br>2.分组和确认必须编码，这样才能知道哪些分组收到了确认，哪些没有收到。<br>3.超时计时器应当设计的比数据在分组传输的平均往返时间要长一些，如果重传时间过长会严重影响效率，但如果过短也会有不必要的重传，浪费资源。</p><h3 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h3><p>若A没有收到B的确认报文，A并不知道是自己的分组丢失还是B的确认丢失，所以重传计时器超时就会重传分组。此时B又收到了分组<br>此时B有两个行动：<br>1.丢弃重复的M1，不向上层交付。<br>2.对A发送确认。<br>可是试想有这样一种可能如图b，B的确认并没有丢失而是由于网络延迟滞留在网络中。<br>此时A会受到重复的确认，处理也很简单。A对重复的=确认并不处理，B依旧会收到重复的分组，然后丢弃重复的M1，并给A发送确认。<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%931.jpg" alt="404"><br>使用以上的确认重传机制就能在不可靠的网络上实现可靠的通信。</p><h3 id="TCP的滑动窗口"><a href="#TCP的滑动窗口" class="headerlink" title="TCP的滑动窗口"></a>TCP的滑动窗口</h3><p>实际上为了提高信道利用率，分组传输并没有每次只发送一个分组，然后等待确认。（这样实在效率太低）。为了提高传输效率，我们必须采用流水线传输，流水线传输使得发送方可以连续发送多个分组，不必每发完一个分组，就停下来等待，显然这样就能获得较高的信道利用率。</p><p>使用流水线传输就要介绍TCP的滑动窗口，现在假定A发送数据B接收数据来讨论TCP的滑动窗口。<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%932.jpg" alt="404"><br>TCP的滑动窗口是以字节为单位的，现假设A收到了来自B的确认报文，其中窗口大小为20字节，确认号为31，而序号30以前的数据都被完好的接受了。<br>我们先说A的发送窗口，发送窗口表示在没有收到B的确认之前窗口里的数据都能持续的发送出去，但这些数据在没有收到B的确认时都必须保留下来，以便于超时重传。显然窗口越大发送方就能在收到确认之前持续发送更多的数据，可以获得更高的传输效率，前提是对方来得及处理这些数据。<br>滑动窗口后沿部分表示已发送并且已经确认的报文，这些可以不用在保留，而前沿部分表示不允许发送的，发送窗口由前沿和后沿共同决定，发送窗口的后沿就两种变化情况不动（没有收到确认），向前移动（收到确认）。发送窗口的前沿一般都是向前移动的，当然也可能不动（没收到确认，窗口值也不变，或者收到确认，窗口值变小）发送窗口前沿也可能向后收缩，这发生在对方通知窗口变小，TCP强烈不推荐这样做。因为可能已经发送了这些数据，但现在又不让发送，可能会产生错误。<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%933.jpg" alt="404"><br>现在假设A发送了31-41的数据，这时窗口未改变。灰色的小方框表示已经发送但没有收到确认的，而发送窗口后九个字节42-50表示没有发送但允许发送的。从上图看出要描述一个发送窗口需要三个指针：p1,p2,p3.<br>小于p1表示已经发送成功的，大于p3表示不可发送的<br>1.p3-p1表示发送窗口<br>2.p2-p1表示已发送尚未确认<br>3.p3-p2表示尚未发送的<br>再看B的接收窗口，接收窗口大小为20字节，B收到了32、33号的数据，没有收到31号所以B只能给出收到的数据最高序号加1，也就是31，期望下次收到31号数据。<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%934.jpg" alt="404"><br>现假定B收到了31号数据并对A确认，窗口依然是20，此时A可以向前移动3个字节，此时A的可发送窗口变大，发送范围为42-53.</p><p>A在继续发送完数据，p2指针p3指针重合此时发送窗口已满，但B的确认并没有到达（丢失或者滞留），等到重传计时器超时，就必须重传这部分数据。直到收到B的确认，然后继续滑动窗口。</p><p>TCP的缓存与窗口的关系：<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%935.jpg" alt="404"></p><p>小思考，若收到的报文段无差错只是没有按序号到达，中间还缺少数据，能否只重传缺少的数据而不用重传已经收到的数据？<br>答案是可以的，选择确定（SACK）是一种可行的办法。要使用选择确认，双方必须商定好，必须在TCP首部增加SOCK选项，以便报告收到不连续的字节块的边界以便于重传。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TCP可靠传输的原理&quot;&gt;&lt;a href=&quot;#TCP可靠传输的原理&quot; class=&quot;headerlink&quot; title=&quot;TCP可靠传输的原理&quot;&gt;&lt;/a&gt;TCP可靠传输的原理&lt;/h3&gt;&lt;p&gt; 我们都知道，TCP发送的报文段是交付给IP层传送的。但IP层只提供尽最大努力传输，因此是不可靠的，因此TCP必须采用适当的措施才能使两个运输层之间通信变得可靠。&lt;br&gt; 理想的传输条件有以下两个特点：&lt;br&gt; 1.传输信道无差错&lt;br&gt; 2.不管发送方以什么样的发送速率，接收方都能来得及处理发送方发送的消息。&lt;br&gt;然而实际上并不存在这样理想的传输条件，因此我们必须采用一些必要的措施保证实现可靠传输。&lt;/p&gt;
&lt;h3 id=&quot;停止等待协议&quot;&gt;&lt;a href=&quot;#停止等待协议&quot; class=&quot;headerlink&quot; title=&quot;停止等待协议&quot;&gt;&lt;/a&gt;停止等待协议&lt;/h3&gt;&lt;p&gt;这里我们讨论单方向的发送和接受，设A为发送方B为接收方。A每发完一个分组就等待B收到分组的确认，然后才发送下一个分组。&lt;br&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://dmdada.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP报文段的首部格式</title>
    <link href="http://dmdada.top/2018/08/09/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F/"/>
    <id>http://dmdada.top/2018/08/09/TCP报文段的首部格式/</id>
    <published>2018-08-09T02:14:26.000Z</published>
    <updated>2018-08-09T03:59:17.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段，一个TCP报文段分为首部和数据两部分，TCP的全部功能体现在首部各字段作用。<br>TCP报文段的前20个字节是固定的，后面有4n个字节根据需要而增加的选项（n为整数）。所以TCP首部最小长度为20字节。<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg" alt="404"></p><p>首部固定字段意义如下：<br>1.源端口和目的端口：各占两个字节，分别写入源端口号和目的端口号。</p><p>2.序号：占4字节，序号范围是[0，2^32-1]一共是4294967296个序号，当序号用完以后，下一个序号就又回到0.在TCP连接中所有字节按序号编号首部中的字段序号标记本报文段所发送的第一个字节的序号。例如本报文段序号为201，携带有100字节的数据，那么最后一个字节数据为300，并且下个报文段数据应当从301开始发送。</p><p>3.确认号：占4个字节 ，是期望收到对方下一个报文段的第一个字节序号，一般由接收方发给发送方的确认报文中将确认号改为期望收到的数据字节编号，总之若确认号为N，则表示N-1之前的数据都已经正确的接接收了。</p><p>4.数据偏移：占4位，表示数据到TCP数据包头部的长度，其实就是表明TCP头部的长度，因为TCP头部固定20字节加上不确定的部分，但4位2进制能最大表示十进制数15，但应注意数据偏移的单位是32位字所以数据偏移最大能表示60字节，因此TCP首部最大为60字节，即选项长度不能超过40字节。</p><p>5.保留：占6位，作为以后使用，目前应该置0</p><p>6.六个控制位：<br>1）紧急URG:当URG置为1时表示此报文段为紧急报文，应当尽快送达，拥有较高的优先级，不需要排队传送。发送方会把经济数据插入到本报文数据的最前面发送，需要注意的是需要和紧急指针配合使用。<br>2）确认ACK：当ACK=1时，确认号才有效，当连接建立时，所有报文段ACK都必须置为1.<br>3）推送PSH：当两个应用交互式通信，有一段应用可能需要对方应用及时的响应，这种情况下可以将PSH位置为1，表示收到消息不用等待缓存区满才向上交付，而是尽快直接交付。<br>4）复位RST： 当RST置为1，表示TCP连接出现严重错误，需要断开并重新建立连接。<br>5）同步SYN:在建立连接用来同步序号，当SYN=1，ACK等于0，标指这是一个请求连接的报文段，如果对方同意连接就将SYN=1,ACK=1。<br>6）终止FIN：用来释放一个连接，当FIN置为1表示已经没有数据发送，已经发送完毕。并要求释放连接。</p><p>7.窗口：占2字节窗口值是[0-2^16-1]之间的整数，窗口告诉发送方从本报文段首部的确认号算起还能接受的数据量，而此窗口值作为发送端设置发送端口的依据。</p><p>8.检验和：占2个字节，用来检验首部和数据这两部分是否出现差错。</p><p>9.紧急指针：占2个字节，紧急指针只有在标志位URG=1时候才有用，它指出紧急数据的字节数，因为紧急数据后面就是普通数据，紧急指针给出了紧急数据在报文段末尾的位置。</p><p>10.选项：长度可变，最大40字节，如果不使用选项，TCP首部大小就为20字节。TCP最开始就只规定了一种选项就是MSS最大报文段长度，但MSS的意思是每个报文中数据字段的最大长度（即报文长度减去TCP首部长度），MSS默认长度位536字节，因此在所有计算机上都能支持的报文段长度为536+20=556字节.随着英特网的发展后来又增加了几个选项：窗口扩大、时间戳等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TCP报文段的首部格式&quot;&gt;&lt;a href=&quot;#TCP报文段的首部格式&quot; class=&quot;headerlink&quot; title=&quot;TCP报文段的首部格式&quot;&gt;&lt;/a&gt;TCP报文段的首部格式&lt;/h3&gt;&lt;p&gt;TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段，一个TCP报文段分为首部和数据两部分，TCP的全部功能体现在首部各字段作用。&lt;br&gt;TCP报文段的前20个字节是固定的，后面有4n个字节根据需要而增加的选项（n为整数）。所以TCP首部最小长度为20字节。&lt;br&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://dmdada.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP的三次握手四次挥手</title>
    <link href="http://dmdada.top/2018/08/09/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://dmdada.top/2018/08/09/TCP的三次握手四次挥手/</id>
    <published>2018-08-09T01:03:02.000Z</published>
    <updated>2018-08-09T10:26:41.169Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>TCP的连接的建立采用客户服务器方式。主动发起连接建立的应用进程称为客户端，被动的等待连接建立的应用进程叫做服务器。<br>先假定主机A运行的是客户端程序，而B运行的是服务器程序。最初两端的TCP进程都处于CLISED状态。建立三次握手过程如下图：<br><a id="more"></a><br>A主动打开连接，B被动打开连接<br><img src="http://pajznqooi.bkt.clouddn.com/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="404"></p><h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><p>1.首先两端都处于CLOSED状态，B的TCP服务器首先创建传输控制块TCB准备接受客户端的连接请求，然后服务器进程就处于LISTEN状态，等待客户的连接请求，如果有就及时做出反应。<br>2.A的TCP进程也是首先创建传输控制模块TCB，然后向B发送连接请求，同时初始化序号seq=x，并将SYN标志位置为1，此阶段为SYN报文段规定并不能携带数据，但也会消耗一个序号，此时TCP客户进程进入SYN-SENT（同步已发送）状态。<br>3.B如果接受连接请求就将确认报文中的ACK，SYN置为1，同时初始化自己的序号seq=y，确认号为ack=x+1.同样的这个报文也不能携带数据，并且也要消耗一个序号，然后B进入SYN-RCVD状态（同步收到）。<br>4.A收到B的确认后还需要再次向B给出确认，确认ACK置1，确认号ack=y+1,而自己的序号为seq=x+1,TCP规定ACK报文可以携带信息，但是如果不携带则不用消耗一个序号，这种情况下下次发送的序号仍然为seq=x+1。这时连接已经建立，A进入ESTAB-LISHED(已建立连接)状态。<br>当B收到A的确认后也进入ESTAB-LISHED状态。</p><p>至此三次握手到此结束</p><p>小思考，为什么要A还要给B发一次确认呢？或者说两次握手不就建立好了吗？</p><p>答：这样是为了防止已经失效的的连接请求再次传送到B,从而产生错误。<br>我们现在试着想一下这样一种正常的情况，A向B发送连接请求，但因为某种原因请求丢失了，A超时重传再次发送连接请求，传输完毕释放连接，A一共发送了两个请求，第一个丢失第二个正常收到，没有失效的连接请求报文段。但我们试想另一种极端的情况，那就是A第一次发送的请求并没有丢失而是因为网络延迟而滞留了，此时滞留的请求被B收到，B会以为这是A的新的一次请求，然后B进行确认应答然后进入连接状态（假设没有三次握手，两次握手就连接），可是B的确认传达到A，由于A并没有申请连接B，所以A不会理睬B的确认应答，也并不会给B发数据。可B一直在等A给他发消息，于是B的服务器资源被白白浪费。</p><p>而采用了三次握手，发生上述情况，由于A不会向B发送确认应当，B也就知道A没有连接的请求。</p><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p>TCP的连接释放过程分为四个步骤，称为四次挥手，我们仍结合双方状态来探究释放的过程</p><p><img src="http://pajznqooi.bkt.clouddn.com/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B2.jpg" alt="404"><br>1.在数据传输完成后双方都可以释放连接，现在双方都处于ESTAB-LISHED状态,现在由A首先先向其TCP发出释放连接报文段，并停止发送数据，主动关闭TCP连接。其通过将FIN位置1，seq=u（等于最后传送成功数据序号+1），同时A进入FIN-WAIT-1状态，等待B的确认。注意FIN报文段不携带数据也会占用一个序号。<br>2.B收到连接释放报文段后发出确认，ACK=1，ack=u+1,自身序号seq=x,同时B进入CLOSE-WAIT(关闭等待状态)，这时TCP服务器通知上层进程，因此从A到B方向的连接就释放了，但由B到A还能发送信息。A收到B的确认应答进入FIN-WAIT-2状态等待B释放自己的报文段。这个状态可能持续一段时间。<br>3.若B没有数据要发送给A，B就会通知A断开连接，此时B的序号为最后发送的数据序号+1，seq=w，ack=u+1,并将FIN置为1，然后进入LAST-ACK(最后确认状态)，并等待A的确认。<br>4.A收到B的连接释放报文段后必须对此发出确认，将ACK置为1，seq=u+1，ack=w+1.此时还并没有释放完毕，A会进入TIME-WAIT（时间等待状态），必须经过时间等待计时器设置的时间2MSL后A才进入CLOSED状态，可能对于现在的网络2分钟可能有点长，因此TCP允许不同实现的具体情况使用更小的MSL值，当时间等待结束，A回收x相应的传输控制块TCB后就结束了此次TCP连接，而B收到A的确认会立即进入CLOSED状态。</p><p>至此四次挥手结束！</p><p>小思考，为什么客户机A需要等待2MSL？<br>答：在这里有两个理由：<br>1.为了保证A发送的确认能够到达B，因为这个报文可能会丢失，而丢失了A可以重传确认并重新启动TIME-WAIT，如果A发送了确认不进行等待而立即释放，会导致B无法收到A的ACK确认从而无法完成B的释放。<br>2。为了防止前面提到的已失效连接请求报文段。A在发送完成最后一个ACK报文段后，在经历2MSL后，可以使所有本连接连续产生的所有报文段从网络中消失，这样使得下一次的新连接中不会出现这种就的请求报文。</p><h3 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h3><p>上面介绍了TCP的正常断开步骤，可日常情况下可能有一些特殊的情况，比如意外的断电使得客户断不能告诉服务端自己断开链接了，此时应当有措施使得服务器不必白白等下去，因此设计了保活计时器，当服务端每次收到客户端数据都会重置保活计时器。，时间的设置通常是两个小时，如果两个小时都没有收到客户的数据，服务器就会发送一个探测报文，以后会间隔75分钟发一次，若连续10次仍然没有客户端的消息，服务器就认为客户端故障，接着关闭这个连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TCP的三次握手&quot;&gt;&lt;a href=&quot;#TCP的三次握手&quot; class=&quot;headerlink&quot; title=&quot;TCP的三次握手&quot;&gt;&lt;/a&gt;TCP的三次握手&lt;/h3&gt;&lt;p&gt;TCP的连接的建立采用客户服务器方式。主动发起连接建立的应用进程称为客户端，被动的等待连接建立的应用进程叫做服务器。&lt;br&gt;先假定主机A运行的是客户端程序，而B运行的是服务器程序。最初两端的TCP进程都处于CLISED状态。建立三次握手过程如下图：&lt;br&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://dmdada.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>虚函数和纯虚函数</title>
    <link href="http://dmdada.top/2018/07/31/%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://dmdada.top/2018/07/31/虚函数和纯虚函数/</id>
    <published>2018-07-31T14:27:04.000Z</published>
    <updated>2018-08-18T15:04:20.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数，用法格式为：virtual 函数返回类型 函数名（参数表） {函数体}；实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。</p><p>简单地说，那些被virtual关键字修饰的成员函数，就是虚函数。虚函数的作用，用专业术语来解释就是实现多态性（Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异，而采用不同的策略。下面来看一段简单的代码。<br><a id="more"></a></p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is A"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is B"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//为了在以后便于区分，我这段main()代码叫做main1</span></span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    a.print();</span><br><span class="line">    b.print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://pajznqooi.bkt.clouddn.com/%E8%99%9A%E5%87%BD%E6%95%B0.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~ A()</span><br><span class="line"> &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  A *a = &amp;b;</span><br><span class="line">  a-&gt;print();</span><br><span class="line">  b.print();</span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://pajznqooi.bkt.clouddn.com/%E8%99%9A%E5%87%BD%E6%95%B02.jpg" alt=""><br> 这里通常将基类的析构函数也声明为虚函数。避免内存泄漏。</p><h3 id="纯虚函数-1"><a href="#纯虚函数-1" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//纯虚函数是一种特殊的虚函数，它的一般格式如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;类名&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">virtual</span> &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=<span class="number">0</span>;</span><br><span class="line">…</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。<br>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。<br>一般而言纯虚函数的函数体是缺省的，但是也可以给出纯虚函数的函数体（此时纯虚函数变为虚函数），这一点经常被人们忽视，调用纯虚函数的方法为baseclass::virtual function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Demon</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Base</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is farther class"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubVirtual</span> :</span><span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Demon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" this is SubVirtual!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"this is subclass Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">base* inst = <span class="keyword">new</span> SubVirtual();</span><br><span class="line">inst-&gt;Demon();</span><br><span class="line">inst-&gt;Base();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://pajznqooi.bkt.clouddn.com/%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B03.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;虚函数&quot;&gt;&lt;a href=&quot;#虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚函数&quot;&gt;&lt;/a&gt;虚函数&lt;/h3&gt;&lt;p&gt;在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数，用法格式为：virtual 函数返回类型 函数名（参数表） {函数体}；实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。&lt;/p&gt;
&lt;p&gt;简单地说，那些被virtual关键字修饰的成员函数，就是虚函数。虚函数的作用，用专业术语来解释就是实现多态性（Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异，而采用不同的策略。下面来看一段简单的代码。&lt;br&gt;
    
    </summary>
    
    
      <category term="-C/C++" scheme="http://dmdada.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>类的的三大特性的总结</title>
    <link href="http://dmdada.top/2018/07/29/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>http://dmdada.top/2018/07/29/类的继承/</id>
    <published>2018-07-29T15:57:22.000Z</published>
    <updated>2018-07-31T14:45:21.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是一指一个对象从另一个对象获得功能的过程，它提供了一种明确表述共性的方法。是一个不断向上抽取的过程。单继承中，一个类只能继承一个类，但一个类可以被多个类所继承。一共有3种不同权限的继承，分别是public、protect、private继承。<br>继承优点：<br>1.提高了代码的复用性。<br>2.让类与类之间产生了关系。有了这个关系，才有了多态的特性。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>什么是封装？<br>封装指隐藏对象的属性和实现细节，仅仅对外提供接口和方法。<br>举一个生动的例子：电视遥控器，就是对电视机操作方法的一种封装，遥控器上的各种按键就是给出的接口，我们用户通过这些接口来控制电视机，但是我们对遥控器实际控制并不清楚，它的原理，或者具体细节，都对我们用户隐藏，这就是一种封装。而在C++中将一个类具体封装起来，只暴露接口函数。能够提高代码重用性，便于使用，当然也更安全。但这样做同时也暴露了缺点，那就是代码不能轻易地去维护，而且封装了过多层会影响效率。<br><a id="more"></a></p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>什么是多态？<br>c++中一共有两种多态，一种是静态的多态，一种是动态的多态。动多态称为运行时多态，而静多态称为编译时多态。静多态大多由模板实现或者是宏，而动多态大多由虚函数来实现，动多态的函数调用机制是执行期才能进行确定，所以它是动态的。总之多态的意义在于让基类的指针指向派生类，从而实现派生类的不同功能。如果你还是不太明白多态的意义，我可以举一个简单的例子。龙生九子，子子不同，龙的九个儿子就是龙的不同表现，同一个模板下，实现不同的形态或者功能就称之为多态。</p><p>多态的实现：<br>函数重载：必须在同一个类中进行 子类无法重载父类的函数，父类同名函数将被名称覆盖，重载是在编译期间根据参数类型和个数决定函数调用<br>函数重写：必须发生于父类与子类之间 并且父类与子类中的函数必须有完全相同的原型 ，使用virtual关键字声明之后能够产生多态(如果不使用virtual，那叫重定义) 多态是在运行期间根据具体对象的类型决定函数调用（注意：基类的析构函数通常建议声明为虚函数，不然容易内存泄漏。</p><p>多态的优势和弊端：<br>优点：多态的出现大大的提高程序的扩展性，以及代码的复用性，减少了编程中编码量，提高了代码的可维护性。<br>缺点：在大工程里如果多态使用大量，编译时过程会极其缓慢。同时多态使得代码的可读性并不那么良好，同时调式起来也比较困难。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;p&gt;继承是一指一个对象从另一个对象获得功能的过程，它提供了一种明确表述共性的方法。是一个不断向上抽取的过程。单继承中，一个类只能继承一个类，但一个类可以被多个类所继承。一共有3种不同权限的继承，分别是public、protect、private继承。&lt;br&gt;继承优点：&lt;br&gt;1.提高了代码的复用性。&lt;br&gt;2.让类与类之间产生了关系。有了这个关系，才有了多态的特性。&lt;/p&gt;
&lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;p&gt;什么是封装？&lt;br&gt;封装指隐藏对象的属性和实现细节，仅仅对外提供接口和方法。&lt;br&gt;举一个生动的例子：电视遥控器，就是对电视机操作方法的一种封装，遥控器上的各种按键就是给出的接口，我们用户通过这些接口来控制电视机，但是我们对遥控器实际控制并不清楚，它的原理，或者具体细节，都对我们用户隐藏，这就是一种封装。而在C++中将一个类具体封装起来，只暴露接口函数。能够提高代码重用性，便于使用，当然也更安全。但这样做同时也暴露了缺点，那就是代码不能轻易地去维护，而且封装了过多层会影响效率。&lt;br&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://dmdada.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>类的成员函数</title>
    <link href="http://dmdada.top/2018/07/18/%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <id>http://dmdada.top/2018/07/18/类的成员函数/</id>
    <published>2018-07-18T15:20:22.000Z</published>
    <updated>2018-07-29T10:32:35.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="六大成员函数"><a href="#六大成员函数" class="headerlink" title="六大成员函数"></a>六大成员函数</h2><p>一、构造函数<br>特点：与类名相同、没有返回值、可以重载、在有效的生命周期只会调用一次、缺省的构造函数不能用Virtual/const修饰，构造函数有自己的初始化列表。初始化列表完成类中非静态成员变量的初始化，尽量避免用成员初始化成员。<br>初始化中，用const类型成员必须初始化。</p><p>二、拷贝构造函数<br>特点：用对象创建对象 参数为类类型的引用，这里必须用引用传递，不然会无限循环递归。而用引用的另一个原因是效率很高。</p><p>三、析构函数<br>特点：形式为~类名，没有参数和返回值，不能重载，在实现多态时最好在基类将构造函数声明为虚函数。<br><a id="more"></a><br>四、赋值运算符重载<br>常见可重载的运算符：++、– 、<em> 、-&gt;、=<br>不可重载的运算符：</em> 、::、？：、sizeof</p><p>五、取地址运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test * <span class="keyword">operator</span>&amp;()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>六、const修饰的取地址操作符的重载<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test * <span class="keyword">operator</span>&amp;()  <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;六大成员函数&quot;&gt;&lt;a href=&quot;#六大成员函数&quot; class=&quot;headerlink&quot; title=&quot;六大成员函数&quot;&gt;&lt;/a&gt;六大成员函数&lt;/h2&gt;&lt;p&gt;一、构造函数&lt;br&gt;特点：与类名相同、没有返回值、可以重载、在有效的生命周期只会调用一次、缺省的构造函数不能用Virtual/const修饰，构造函数有自己的初始化列表。初始化列表完成类中非静态成员变量的初始化，尽量避免用成员初始化成员。&lt;br&gt;初始化中，用const类型成员必须初始化。&lt;/p&gt;
&lt;p&gt;二、拷贝构造函数&lt;br&gt;特点：用对象创建对象 参数为类类型的引用，这里必须用引用传递，不然会无限循环递归。而用引用的另一个原因是效率很高。&lt;/p&gt;
&lt;p&gt;三、析构函数&lt;br&gt;特点：形式为~类名，没有参数和返回值，不能重载，在实现多态时最好在基类将构造函数声明为虚函数。&lt;br&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://dmdada.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的层序遍历</title>
    <link href="http://dmdada.top/2018/07/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://dmdada.top/2018/07/16/二叉树的层序遍历/</id>
    <published>2018-07-16T15:31:17.000Z</published>
    <updated>2018-07-27T15:01:16.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="层序遍历算法"><a href="#层序遍历算法" class="headerlink" title="层序遍历算法"></a>层序遍历算法</h3><p>二叉树的层序遍历：从根开始，依次向下，对于每一层从左向右遍历。<br>同二叉树的前中后序遍历不同的是，前中后序采用的是堆，而二叉树层序遍历采用的是队列。<br>因此前中后序遍历可以采用递归算法，而层序遍历却不行！<br><a id="more"></a></p><h3 id="层序遍历的模拟实现"><a href="#层序遍历的模拟实现" class="headerlink" title="层序遍历的模拟实现"></a>层序遍历的模拟实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTree</span>//二叉树结构</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> vec;</span><br><span class="line">  BinaryTree* left;</span><br><span class="line">  BinaryTree* right;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) <span class="comment">//返回为一个数组</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; ret;</span><br><span class="line">ret.push(root);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">while</span> (!ret.empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode*tmp= ret.front();</span><br><span class="line">result.push_back(tmp-&gt;val);</span><br><span class="line">ret.pop();</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret.push(tmp-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret.push(tmp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;层序遍历算法&quot;&gt;&lt;a href=&quot;#层序遍历算法&quot; class=&quot;headerlink&quot; title=&quot;层序遍历算法&quot;&gt;&lt;/a&gt;层序遍历算法&lt;/h3&gt;&lt;p&gt;二叉树的层序遍历：从根开始，依次向下，对于每一层从左向右遍历。&lt;br&gt;同二叉树的前中后序遍历不同的是，前中后序采用的是堆，而二叉树层序遍历采用的是队列。&lt;br&gt;因此前中后序遍历可以采用递归算法，而层序遍历却不行！&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://dmdada.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的链式存储实现</title>
    <link href="http://dmdada.top/2018/07/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://dmdada.top/2018/07/15/二叉树的链式存储实现/</id>
    <published>2018-07-15T07:05:36.000Z</published>
    <updated>2018-07-15T15:40:52.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h2><p>数组表示法用于完全二叉树的存储表示非常有效，但表示一般二叉树则不是很理想。此外，在一棵树中进行插入和删除操作时，为了反应结点层次的变动，可能需要移动许多的结点，这样降低了算法的效率，而使用了链表表示可以克服这样的缺点。<br>根据二叉树的定义，可以设计出二叉树节点的构造。二叉树的每一个结点至少应该包括三个域：数据、左孩子、右孩子。这种链表结构一般被叫做二叉链表。使用这种链表可以很方便的表示和找到它的子女，但找到它的双亲却很困难。为了便于查找双亲，我们还可以增加一个双亲指针域，这种结构被称为三叉链表。<br>结构如下：<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A82.jpg" alt="这里写图片描述"></p><h3 id="二叉链表的类定义"><a href="#二叉链表的类定义" class="headerlink" title="二叉链表的类定义"></a>二叉链表的类定义</h3><p>三叉链表和二叉链表类似，本文只讨论二叉链表。下面给出二叉链表的类定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEAD_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEAD_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>  DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data;</span><br><span class="line">BinTreeNode *leftchild, *righutchild;</span><br><span class="line">&#125;Binarynode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinaryTree()</span><br><span class="line">:root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">BinaryTree(BinaryTree&amp; s);</span><br><span class="line">~BinaryTree();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatBinTree</span><span class="params">(Binarynode*&amp;subTree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ceratBinTree</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Binarynode *<span class="title">find</span><span class="params">()</span></span>;<span class="comment">//搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//中序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//后序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Binarynode* subTree)</span></span>;<span class="comment">//统计节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hight</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hight</span><span class="params">(Binarynode* subTree)</span></span>;<span class="comment">//求树高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BinaryTree* <span class="title">copy</span><span class="params">(Binarynode*&amp;Tree)</span></span>;<span class="comment">//复制二叉树</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Binarynode *root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="二叉链表的实现"><a href="#二叉链表的实现" class="headerlink" title="二叉链表的实现"></a>二叉链表的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>  DataType;</span><br><span class="line">DataType RefValue = <span class="string">'#'</span>;<span class="comment">//输入结束符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data;</span><br><span class="line">BinTreeNode *leftchild, *rightchild;</span><br><span class="line">&#125;Binarynode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinaryTree()</span><br><span class="line">:root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">BinaryTree(BinaryTree&amp; s);</span><br><span class="line">~BinaryTree();</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Binarynode *<span class="title">find</span><span class="params">(DataType &amp;item)</span></span>;<span class="comment">//搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatBinTree</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatBinTree</span><span class="params">(Binarynode*&amp;subTree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//中序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//后序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Binarynode* subTree)</span></span>;<span class="comment">//统计节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hight</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hight</span><span class="params">(Binarynode* subTree)</span></span>;<span class="comment">//求树高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Binarynode* <span class="title">copy</span><span class="params">(Binarynode*&amp;Tree)</span></span>;<span class="comment">//复制二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">(Binarynode*&amp;Tree)</span></span>;<span class="comment">//销毁</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Binarynode *root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> BinaryTree::IsEmpty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Binarynode* BinaryTree::find(DataType&amp; item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (item != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Binarynode *tmp = root;</span><br><span class="line">Binarynode*tmpl = tmp-&gt;leftchild;</span><br><span class="line">Binarynode*tmpr = tmp-&gt;rightchild;</span><br><span class="line">DataType temp = root-&gt;data;</span><br><span class="line"><span class="keyword">while</span> (tmpl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp != item)</span><br><span class="line">&#123;</span><br><span class="line">tmpl = tmpl-&gt;leftchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i find it"</span>;</span><br><span class="line"><span class="keyword">return</span> tmpl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (tmpr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp != item)</span><br><span class="line">&#123;</span><br><span class="line">tmpr = tmpr-&gt;rightchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i find it "</span>;</span><br><span class="line"><span class="keyword">return</span> tmpr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"can't find it"</span>;</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::PreOrder()</span><br><span class="line">&#123;</span><br><span class="line">PreOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::PreOrder(Binarynode*subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; subTree-&gt;data;</span><br><span class="line">PreOrder(subTree-&gt;leftchild);</span><br><span class="line">PreOrder(subTree-&gt;rightchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::InOrder()</span><br><span class="line">&#123;</span><br><span class="line">InOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::InOrder(Binarynode* subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">InOrder(subTree-&gt;leftchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; subTree-&gt;data;</span><br><span class="line">InOrder(subTree-&gt;rightchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">void</span> BinaryTree::PostOrder()</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::PostOrder(Binarynode*subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(subTree-&gt;leftchild);</span><br><span class="line">PostOrder(subTree-&gt;rightchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; subTree-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::Hight()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Hight(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::Hight(Binarynode* subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> dep1 = Hight(subTree-&gt;leftchild);</span><br><span class="line"><span class="keyword">int</span> dep2 = Hight(subTree-&gt;rightchild);</span><br><span class="line"><span class="keyword">if</span> (dep1&gt;dep2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dep1 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dep2 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::count()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> count(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::count(Binarynode*subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + count(subTree-&gt;leftchild) + count(subTree-&gt;rightchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BinaryTree::copy()</span><br><span class="line">&#123;</span><br><span class="line">copy(root);</span><br><span class="line">&#125;</span><br><span class="line">Binarynode* BinaryTree::copy(Binarynode*&amp;Tree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Binarynode *tmp = <span class="keyword">new</span> Binarynode;</span><br><span class="line">tmp-&gt;data = Tree-&gt;data;</span><br><span class="line">tmp-&gt;leftchild = copy(Tree-&gt;leftchild);</span><br><span class="line">tmp-&gt;rightchild = copy(Tree-&gt;rightchild);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::creatBinTree(Binarynode*&amp;subTree)</span><br><span class="line">&#123;</span><br><span class="line">DataType item;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; item;</span><br><span class="line"><span class="keyword">if</span> (item != RefValue)</span><br><span class="line">&#123;</span><br><span class="line">subTree = <span class="keyword">new</span> Binarynode;</span><br><span class="line">subTree-&gt;data = item;</span><br><span class="line"><span class="keyword">if</span> (subTree == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"存储分配错误"</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">creatBinTree(subTree-&gt;leftchild);</span><br><span class="line">creatBinTree(subTree-&gt;rightchild);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">subTree = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::creatBinTree()</span><br><span class="line">&#123;</span><br><span class="line">creatBinTree(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BinaryTree::destory(Binarynode*&amp;Tree)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Tree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">destory(Tree-&gt;leftchild);</span><br><span class="line">destory(Tree-&gt;rightchild);</span><br><span class="line"><span class="keyword">delete</span> Tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryTree::~BinaryTree()</span><br><span class="line">&#123;</span><br><span class="line">destory(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BinaryTree::BinaryTree(BinaryTree &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">root = copy(s.root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BinaryTree subTree;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入节点，空结点以#代替:"</span>;</span><br><span class="line">subTree.creatBinTree();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"前序遍历："</span>;</span><br><span class="line">subTree.PreOrder();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="string">"中序遍历："</span>;</span><br><span class="line">subTree.InOrder();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"后序遍历："</span>;</span><br><span class="line">subTree.PostOrder();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"结点个数："</span>&lt;&lt;subTree.count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"树的高度："</span>&lt;&lt;subTree.Hight()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.jpg" alt=""></p><h3 id="关于链表的输入"><a href="#关于链表的输入" class="headerlink" title="关于链表的输入"></a>关于链表的输入</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A83.jpg" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉链表&quot;&gt;&lt;a href=&quot;#二叉链表&quot; class=&quot;headerlink&quot; title=&quot;二叉链表&quot;&gt;&lt;/a&gt;二叉链表&lt;/h2&gt;&lt;p&gt;数组表示法用于完全二叉树的存储表示非常有效，但表示一般二叉树则不是很理想。此外，在一棵树中进行插入和删除操作时，为了反应结点层次的变动，可能需要移动许多的结点，这样降低了算法的效率，而使用了链表表示可以克服这样的缺点。&lt;br&gt;根据二叉树的定义，可以设计出二叉树节点的构造。二叉树的每一个结点至少应该包括三个域：数据、左孩子、右孩子。这种链表结构一般被叫做二叉链表。使用这种链表可以很方便的表示和找到它的子女，但找到它的双亲却很困难。为了便于查找双亲，我们还可以增加一个双亲指针域，这种结构被称为三叉链表。&lt;br&gt;结构如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://dmdada.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://dmdada.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Pairs-对组介绍</title>
    <link href="http://dmdada.top/2018/07/12/Pairs-%E5%AF%B9%E7%BB%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://dmdada.top/2018/07/12/Pairs-对组介绍/</id>
    <published>2018-07-12T14:44:00.000Z</published>
    <updated>2018-07-12T15:42:57.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队组"><a href="#队组" class="headerlink" title="队组"></a>队组</h2><p>class Pair 可以将两个值视作一个单元。C++标准库库内多处使用了这个Class，尤其是容器map和multimap，就是使用了Pairs来管理键值对，任何函数返回两个值也需要pair.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>  <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">Pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    pair()</span><br><span class="line">    :first(T1(),second(T2))</span><br><span class="line">    &#123;&#125;</span><br><span class="line">      pair(<span class="keyword">const</span> pair&lt;U,V&gt;&amp;p)</span><br><span class="line">      :first (p.first),second(p.second)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>注意，pair被定义为struct，而不是class，这样所有成员都是public,因此可以直接存储pair的个别值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>:pair&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt;p;</span><br></pre></td></tr></table></figure></p><p>上述defalut构造函数生成一个pair时，以int（）和float（）来初始化p,这两个构造函数为0值；<br>如果pair对象被复制，调用的是由系统隐式生成的的哪个copy构造函数，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>:：pair&lt;<span class="keyword">int</span>,<span class="keyword">const</span> <span class="keyword">char</span>*&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;)</span></span>;</span><br><span class="line"><span class="keyword">void</span> foo&#123;</span><br><span class="line">  <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">const</span> <span class="keyword">char</span>*&gt;p(<span class="number">42</span>,<span class="string">"hello"</span>);</span><br><span class="line">  f(p);</span><br><span class="line">  g(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="pair之间的比较"><a href="#pair之间的比较" class="headerlink" title="pair之间的比较"></a>pair之间的比较</h2><p>为了比较两个pair对象，C++标准程序库提供了大家惯用的操作符。如果两个pair对象内的所有元素相等，这两个pair对象就被视为相等。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> ,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">pair</span>&lt;T,T2&gt;&amp;<span class="title">X</span>,<span class="title">const</span> <span class="title">pair</span> &lt;T,T2&gt;&amp;<span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.first==y.first&amp;&amp;x.second==y.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当两个pairs相互比较时，第一元素具有较高的优先级，所以如果两个pairs的第一元素不相等，其比较结果就称为整个比较行为的结果。如果第一元素相等，才继续比较第二元素，并把比较结果当作整体比较结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>&lt;const pair&lt;T1,T2&gt;&amp;X,const pair&lt;T1,T2&gt;&amp;y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">  return x.first&lt;y.first||(!(y.first/,x.first)&amp;&amp;x.second&lt;y.second);</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p><p>其他的比较操作符，也差不多相似。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;队组&quot;&gt;&lt;a href=&quot;#队组&quot; class=&quot;headerlink&quot; title=&quot;队组&quot;&gt;&lt;/a&gt;队组&lt;/h2&gt;&lt;p&gt;class Pair 可以将两个值视作一个单元。C++标准库库内多处使用了这个Class，尤其是容器map和multimap，就是使用了Pairs来管理键值对，任何函数返回两个值也需要pair.&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;  &lt;span class=&quot;title&quot;&gt;T1&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;T2&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;  &lt;span class=&quot;title&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Pair&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; T1 first_type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; T2 second_type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pair()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    :first(T1(),second(T2))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      pair(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; pair&amp;lt;U,V&amp;gt;&amp;amp;p)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      :first (p.first),second(p.second)&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++标准程序库" scheme="http://dmdada.top/tags/C-%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://dmdada.top/2018/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://dmdada.top/2018/07/09/二叉树/</id>
    <published>2018-07-09T14:38:40.000Z</published>
    <updated>2018-07-15T07:04:57.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。<br>二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。<br>一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为log2(n+1)。深度为k的完全二叉树，至少有2^(k-1)个节点，至多有2^k-1个节点。<br><a id="more"></a></p><h3 id="二叉树相关知识"><a href="#二叉树相关知识" class="headerlink" title="二叉树相关知识"></a>二叉树相关知识</h3><p>满二叉树：在一棵二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层，则这样的二叉树称作满二叉树。<br>完全二叉树：如果一颗具有n个节点的二叉树的结构与满二叉树的前n个节点的结构相同，这样的二叉树称为完全二叉树。</p><h3 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h3><p>1:若规定根节点的层数为0，则一棵非空二叉树的第i层上最多有2^i(i&gt;=0)个节点。<br>2: 若规定只有根节点的二叉树的深度为0，则深度为k的二叉树的最大节点数是2^(k+1)-1(k&gt;=-1)。<br>3:对于一棵非空的二叉树，如果叶节点个数为n0，度为2的节点个数为n2，则有n0=n2+1。<br>4:具有n个节点的完全二叉树的深度k为大于或等于ln(n+1)-1的最小整数。<br>5:对于具有n个节点的完全二叉树，如果按照从上至下和从左至右的顺序对所有节点序号从0开始顺序编号，则对于序号为i(0&lt;=i&lt;n)的节点有：<br> 1)如果i〉0，则序号为i节点的双亲节点的序号为(i-1)/2(/为整除)；如果i=0，则序号为i节点为根节点，无双亲节点。<br> 2)如果2i+1&lt;n,则序号为i节点的左孩子节点的序号为2i+1；如果2i+1&gt;=n,则序号为i节点无左孩子。<br> 3)如果2i+2&lt;n,则序号为i节点的右孩子节点的序号为2i+2;如果2i+2&gt;=n，则序号为i节点无右孩子。</p><h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h3><p>1.二叉树的顺序存储结构<br> 利用性质5，对于完全二叉树可以利用一维数组存储，如果不是完全二叉树，则可以补空节点，使成为完全二叉树在进行存储，<br> 但是对于非完全二叉树，可能要浪费很多的空间。所以并不是很理想。<br>2.二叉树的链式存储结构<br>  二叉树的链式存储结构就是用指针建立二叉树中节点之间的关系，二叉树最常用的链式存储结构是二叉链表。二叉树的二叉链表存储结构是一种常用的二叉树存储结构。二叉链表存储结构的优点是结构简单，可以方便的构造任何形状的二叉树，并可以方便的实现二叉树的大多数操作。<br>  二叉链表存储结构的缺点是，查找当前节点的双亲节点操作实现比较麻烦。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h3&gt;&lt;p&gt;在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。&lt;br&gt;二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。&lt;br&gt;一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为log2(n+1)。深度为k的完全二叉树，至少有2^(k-1)个节点，至多有2^k-1个节点。&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://dmdada.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>简单UDP网络程序</title>
    <link href="http://dmdada.top/2018/07/07/%E7%AE%80%E5%8D%95UDP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F/"/>
    <id>http://dmdada.top/2018/07/07/简单UDP网络程序/</id>
    <published>2018-07-07T07:23:25.000Z</published>
    <updated>2018-07-07T07:33:41.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现简单UDP客户端和服务器端"><a href="#实现简单UDP客户端和服务器端" class="headerlink" title="实现简单UDP客户端和服务器端"></a>实现简单UDP客户端和服务器端</h3><p>实现简单的基于UDP协议的客户端和服务器端聊天小程序。</p><a id="more"></a><h4 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                                                                                                                                     </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;                                                                                                                                </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;                                                                                                                                </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;                                                                                                                                 </span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">sockaddr</span>;</span>                                                                                                                      </span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockaddr_in</span>;</span>                                                                                                                </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;                                                                                                                      </span><br><span class="line">   <span class="keyword">int</span> sock = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);                                                                                                              </span><br><span class="line">   <span class="keyword">if</span> (sock&lt;<span class="number">0</span>)                                                                                                                                           </span><br><span class="line">   &#123;                                                                                                                                                     </span><br><span class="line">   perror(<span class="string">"socket"</span>);                                                                                                                                     </span><br><span class="line">   <span class="keyword">return</span> <span class="number">2</span>;                                                                                                                                             </span><br><span class="line">   &#125;                                                                                                                                                     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local</span>;</span>                                                                                                                            </span><br><span class="line">    local.sin_family=AF_INET;                                                                                                                            </span><br><span class="line">    local.sin_port=htons(atoi(argv[<span class="number">1</span>]));                                                                                                                 </span><br><span class="line">    local.sin_addr.s_addr=htonl(INADDR_ANY);                                                                                                             </span><br><span class="line">  <span class="keyword">if</span> (bind(sock,(struct sockaddr*)&amp;local,<span class="keyword">sizeof</span>(local))&lt;<span class="number">0</span>)                                                                                               </span><br><span class="line">  &#123;                                                                                                                                                      </span><br><span class="line">  perror(<span class="string">"bind"</span>);                                                                                                                                        </span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;                                                                                                                                              </span><br><span class="line">  &#125;                                                                                                                                                      </span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>];                                                                                                                                        </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span>                                                                                                                             </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)                                                                                                                                               </span><br><span class="line">  &#123;                                                                                                                                                      </span><br><span class="line">    <span class="keyword">socklen_t</span> len= <span class="keyword">sizeof</span>(client);                                                                                                                       </span><br><span class="line">    <span class="keyword">ssize_t</span> s=recvfrom(sock,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,<span class="number">0</span>,(struct sockaddr*)&amp;client,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(s&gt;<span class="number">0</span>)                                                                                                                                              </span><br><span class="line">    &#123;                                                                                                                                                    </span><br><span class="line">  buf[s]=<span class="number">0</span>;                                                                                                                                              </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[%s:%d]: %s\n"</span>,inet_ntoa(client.sin_addr),ntohs(client.sin_port),buf);                                                                         </span><br><span class="line">      sendto(sock,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>,(struct sockaddr*)&amp;client,<span class="keyword">sizeof</span>(client));                                                                           </span><br><span class="line">    &#125;                                                                                                                                                    </span><br><span class="line">  &#125;                                                                                                                                                      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                            </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                                                                                                                                     </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;                                                                                                                                </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;                                                                                                                                </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;                                                                                                                                 </span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">sockaddr</span>;</span>                                                                                                                      </span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockaddr_in</span>;</span>                                                                                                                </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;                                                                                                                      </span><br><span class="line">    <span class="keyword">int</span> sock=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);                                                                                                               </span><br><span class="line">   <span class="keyword">if</span> (sock&lt;<span class="number">0</span>) &#123;                                                                                                                                         </span><br><span class="line">     perror(<span class="string">"socket"</span>);                                                                                                                                   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">2</span>;                                                                                                                                           </span><br><span class="line"></span><br><span class="line">   &#125;                                                                                                                                                     </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span>                                                                                                                            </span><br><span class="line">   server.sin_family=AF_INET;                                                                                                                            </span><br><span class="line">   server.sin_port=htons(atoi(argv[<span class="number">2</span>]));                                                                                                                 </span><br><span class="line">   server.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);                                                                                                            </span><br><span class="line">  <span class="keyword">char</span> buff[<span class="number">1024</span>];                                                                                                                                       </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">peer</span>;</span>                                                                                                                               </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)                                                                                                                                               </span><br><span class="line">  &#123;                                                                                                                                                      </span><br><span class="line">  <span class="keyword">socklen_t</span> len =<span class="keyword">sizeof</span>(peer);                                                                                                                           </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter： "</span>);                                                                                                                                </span><br><span class="line">  fflush(<span class="built_in">stdout</span>);                                                                                                                                        </span><br><span class="line">  <span class="keyword">ssize_t</span> s=read(<span class="number">0</span>,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>);                                                                                                                 </span><br><span class="line">  <span class="keyword">if</span>(s&gt;<span class="number">0</span>)                                                                                                                                                </span><br><span class="line">  &#123;                                                                                                                                                      </span><br><span class="line">    buff[s<span class="number">-1</span>]=<span class="number">0</span>;                                                                                                                                         </span><br><span class="line">    sendto(sock,buff,<span class="built_in">strlen</span>(buff),<span class="number">0</span>,(struct sockaddr*)&amp;server,<span class="keyword">sizeof</span>(server));                                                                           </span><br><span class="line">    <span class="keyword">ssize_t</span> _s=recvfrom(sock,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>,<span class="number">0</span>,(struct sockaddr*)&amp;peer,&amp;len);</span><br><span class="line">    <span class="keyword">if</span> (_s&gt;<span class="number">0</span>) &#123;                                                                                                                                          </span><br><span class="line">      buff[_s]=<span class="number">0</span>;                                                                                                                                        </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"server echo %s\n"</span>,buff);                                                                                                                    </span><br><span class="line">    &#125;                                                                                                                                                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;                                                                                                                                                      </span><br><span class="line">  &#125;                                                                                                                                                      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                            </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>1.运行服务器<br><img src="http://pajznqooi.bkt.clouddn.com/UDP1.jpg" alt="404"><br>2.检查端口</p><p><img src="http://pajznqooi.bkt.clouddn.com/UDP2.jpg" alt="404"></p><p>3.运行客户端<br><img src="http://pajznqooi.bkt.clouddn.com/UDP3.jpg" alt="404"></p><p>4.查看服务器端<br><img src="http://pajznqooi.bkt.clouddn.com/UDP4.jpg" alt="404"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现简单UDP客户端和服务器端&quot;&gt;&lt;a href=&quot;#实现简单UDP客户端和服务器端&quot; class=&quot;headerlink&quot; title=&quot;实现简单UDP客户端和服务器端&quot;&gt;&lt;/a&gt;实现简单UDP客户端和服务器端&lt;/h3&gt;&lt;p&gt;实现简单的基于UDP协议的客户端和服务器端聊天小程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://dmdada.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>模板</title>
    <link href="http://dmdada.top/2018/07/01/%E6%A8%A1%E6%9D%BF/"/>
    <id>http://dmdada.top/2018/07/01/模板/</id>
    <published>2018-07-01T12:55:08.000Z</published>
    <updated>2018-07-05T14:38:35.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>模板是实现代码重用机制的一种工具，它可以实现数据类型的参数化，即将数据类型定义为参数，而由编译系统在处理具体函数调用时，根据实参类型来匹配函数模板中的对应形参并在确认后生成一个重载函数，从而真正实现代码重用。</p><p>C++中，允许用户构造函数模板，创建支持多种不同数据类型的形参但却具有通用功能的函数；也允许构造类模板，使的类中某些数据成员，成员函数的参数和返回值可以是任意数据类型。使用模板可以从一个函数生成多个函数或者从一个类模板生成多个类，建立一个模板后，编译器将根据使用时的实际数据类型使其实例化，生成可执行的代码，实例化的函数模板称为模板函数；实例化的类称为模板类。模板、模板函数、模板类以及对象关系如下：<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/%E6%A8%A1%E6%9D%BF.png" alt="404"><br>模板使用方法：<br><code>templete&lt;&lt;类型形参表》&lt;返回类型&gt;&lt;函数名&gt;(模板形参表){...}</code><br><!--more--></p><h3 id="模板函数的使用"><a href="#模板函数的使用" class="headerlink" title="模板函数的使用"></a>模板函数的使用</h3><pre><code class="c++"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;                                                                                                                                       </span></span><span class="keyword">using</span> <span class="keyword">namespace</span>  <span class="built_in">std</span>;                                                                                                                                    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                                                                                                       <span class="function">T <span class="title">Power</span><span class="params">(T base,<span class="keyword">int</span> exponent)</span>                                                                                                                             </span><span class="function"></span>{                                                                                                                                                         T value =base;                                                                                                                                           <span class="keyword">while</span>(--exponent&gt;<span class="number">0</span>)                                                                                                                                      {                                                                                                                                                       value*=base;                                                                                                                                             <span class="keyword">return</span> value;                                                                                                                                             }                                                                                                                                                       }                                                                                                                                                        <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                                                                                                                                               </span><span class="function"></span>{                                                                                                                                                          <span class="built_in">cout</span>&lt;&lt;<span class="string">"18^1="</span>&lt;&lt;Power(<span class="number">18</span>,<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;                                                                                                                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"5^3="</span>&lt;&lt;Power(<span class="number">5</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;                                                                                                                          <span class="built_in">cout</span>&lt;&lt;<span class="string">"2.6^7="</span>&lt;&lt;Power(<span class="number">2.6</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;                                                                                                                      <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                              }</code></pre><p>结果：<br><img src="http://pajznqooi.bkt.clouddn.com/%E6%A8%A1%E6%9D%BF1.jpg" alt="404"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h3&gt;&lt;p&gt;模板是实现代码重用机制的一种工具，它可以实现数据类型的参数化，即将数据类型定义为参数，而由编译系统在处理具体函数调用时，根据实参类型来匹配函数模板中的对应形参并在确认后生成一个重载函数，从而真正实现代码重用。&lt;/p&gt;
&lt;p&gt;C++中，允许用户构造函数模板，创建支持多种不同数据类型的形参但却具有通用功能的函数；也允许构造类模板，使的类中某些数据成员，成员函数的参数和返回值可以是任意数据类型。使用模板可以从一个函数生成多个函数或者从一个类模板生成多个类，建立一个模板后，编译器将根据使用时的实际数据类型使其实例化，生成可执行的代码，实例化的函数模板称为模板函数；实例化的类称为模板类。模板、模板函数、模板类以及对象关系如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://dmdada.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Vector</title>
    <link href="http://dmdada.top/2018/06/29/Vector/"/>
    <id>http://dmdada.top/2018/06/29/Vector/</id>
    <published>2018-06-29T15:48:16.000Z</published>
    <updated>2018-07-07T05:49:23.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>名词解释：vector 是同一种类型的对象的集合,每个对象都有一个对应的整数索引值 。<br>和 string 对象一样,标准库将负责管理与存储元素相关的内存。我们把 vector称为容器,是因为它可以包含其他对象，能够存放任意类型的动态数组，增加和压缩数据。一个容器中的所有对象都必须是同一种类型的 。<br>vector 是一个类模板(class template)。使用模板可以编写一个类定义或函数定义,而用于多个不同的数据类型。因此,我们可以定义保存 string 对象的 vector,或保存 int 值的 vector,又或是保存自定义的类类型对象(如Sales_items 对象)的 vector。vector 不是一种数据类型,而只是一个类模板,可用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。<br><a id="more"></a></p><h3 id="vectors运用实例"><a href="#vectors运用实例" class="headerlink" title="vectors运用实例"></a>vectors运用实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;                                                                                                                                     </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;                                                                                                                                       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;                                                                                                                                       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;                                                                                                                                    </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sentence;</span><br><span class="line">sentence.reserve(<span class="number">5</span>);</span><br><span class="line">sentence.push_back(<span class="string">"hello,"</span>);</span><br><span class="line">sentence.push_back(<span class="string">"how"</span>);</span><br><span class="line">sentence.push_back(<span class="string">"are"</span>);</span><br><span class="line">sentence.push_back(<span class="string">"you"</span>);</span><br><span class="line">sentence.push_back(<span class="string">"？"</span>);</span><br><span class="line">copy(sentence.begin(), sentence.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size():"</span> &lt;&lt; sentence.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size():"</span> &lt;&lt; sentence.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity():"</span> &lt;&lt; sentence.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">swap(sentence[<span class="number">1</span>], sentence[<span class="number">3</span>]);</span><br><span class="line">sentence.insert(find(sentence.begin(), sentence.end(), <span class="string">"？"</span>), <span class="string">"always"</span>);</span><br><span class="line">sentence.back() = <span class="string">"!"</span>;</span><br><span class="line">copy(sentence.begin(), sentence.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"max():"</span> &lt;&lt; sentence.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size();"</span> &lt;&lt; sentence.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity()"</span> &lt;&lt; sentence.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/vector.jpg" alt="404"></p><p>实验结果可能如此，注意我说的是“可能”，是的当max_size()和capacity（）的结果由实作版本决定，从这个例子中你可以看到，当容量不足时，此一实作版本将容量扩充1。所以你可以试着运行一下看看有没有和我不同。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Vector&quot;&gt;&lt;a href=&quot;#Vector&quot; class=&quot;headerlink&quot; title=&quot;Vector&quot;&gt;&lt;/a&gt;Vector&lt;/h3&gt;&lt;p&gt;名词解释：vector 是同一种类型的对象的集合,每个对象都有一个对应的整数索引值 。&lt;br&gt;和 string 对象一样,标准库将负责管理与存储元素相关的内存。我们把 vector称为容器,是因为它可以包含其他对象，能够存放任意类型的动态数组，增加和压缩数据。一个容器中的所有对象都必须是同一种类型的 。&lt;br&gt;vector 是一个类模板(class template)。使用模板可以编写一个类定义或函数定义,而用于多个不同的数据类型。因此,我们可以定义保存 string 对象的 vector,或保存 int 值的 vector,又或是保存自定义的类类型对象(如Sales_items 对象)的 vector。vector 不是一种数据类型,而只是一个类模板,可用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://dmdada.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="http://dmdada.top/2018/06/28/Markdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://dmdada.top/2018/06/28/Markdown语法/</id>
    <published>2018-06-28T15:05:57.000Z</published>
    <updated>2018-07-05T14:38:35.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown编辑器写博客"><a href="#Markdown编辑器写博客" class="headerlink" title="Markdown编辑器写博客"></a>Markdown编辑器写博客</h2><p>新功能：</p><ul><li><strong>Markdown和扩展Markdown简洁的语法</strong></li><li><strong>代码块高亮</strong></li><li><strong>图片链接和图片上传</strong></li><li><strong><em>LaTex</em>数学公式</strong></li><li><strong>UML序列图和流程图</strong></li><li><strong>离线写博客</strong></li><li><strong>导入导出Markdown文件</strong></li><li><strong>丰富的快捷键</strong></li></ul><hr><a id="more"></a><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>加粗    <code>Ctrl + B</code></li><li>斜体    <code>Ctrl + I</code></li><li>引用    <code>Ctrl + Q</code></li><li>插入链接    <code>Ctrl + L</code></li><li>插入代码    <code>Ctrl + K</code></li><li>插入图片    <code>Ctrl + G</code></li><li>提升标题    <code>Ctrl + H</code></li><li>有序列表    <code>Ctrl + O</code></li><li>无序列表    <code>Ctrl + U</code></li><li>横线    <code>Ctrl + R</code></li><li>撤销    <code>Ctrl + Z</code></li><li>重做    <code>Ctrl + Y</code></li></ul><h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</a></p></blockquote><p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net" target="_blank" rel="noopener">链接</a>等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 表格</span><br><span class="line"></span><br><span class="line">**Markdown　Extra**　表格语法：</span><br><span class="line"></span><br><span class="line">项目     | 价格</span><br><span class="line">-------- | ---</span><br><span class="line">Computer | $1600</span><br><span class="line">Phone    | $12</span><br><span class="line">Pipe     | $1</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>项目</th><th>价格</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可以使用冒号来定义对齐方式：</span><br><span class="line"></span><br><span class="line">| 项目      |    价格 | 数量  |</span><br><span class="line">| :-------- | --------:| :--: |</span><br><span class="line">| Computer  | 1600 元 |  5   |</span><br><span class="line">| Phone     |   12 元 |  12  |</span><br><span class="line">| Pipe      |    1 元 | 234  |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">1600 元</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">12 元</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">1 元</td><td style="text-align:center">234</td></tr></tbody></table><p>###定义列表</p><p><strong>Markdown　Extra</strong>　定义列表语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">项目１</span><br><span class="line">项目２</span><br><span class="line">:   定义 A</span><br><span class="line">:   定义 B</span><br><span class="line"></span><br><span class="line">项目３</span><br><span class="line">:   定义 C</span><br><span class="line"></span><br><span class="line">:   定义 D</span><br><span class="line"></span><br><span class="line">&gt; 定义D内容</span><br></pre></td></tr></table></figure><p>项目１<br>项目２<br>:   定义 A<br>:   定义 B</p><p>项目３<br>:   定义 C</p><p>:   定义 D</p><pre><code>&gt; 定义D内容</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><p>###脚注<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生成一个脚注[^footnote].</span><br><span class="line">[^footnote]: 这里是 **脚注** 的 *内容*.</span><br></pre></td></tr></table></figure></p><p>生成一个脚注[^footnote].<br> [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p><p>[TOC]</p><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用MathJax渲染*LaTex* 数学公式，详见[math.stackexchange.com][1].</span><br><span class="line"></span><br><span class="line"> - 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</span><br><span class="line"> - 块级公式：</span><br><span class="line"></span><br><span class="line">$$x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$</span><br></pre></td></tr></table></figure><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href="http://math.stackexchange.com/" target="_blank" rel="noopener">math.stackexchange.com</a>.</p><ul><li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li><li>块级公式：</li></ul><p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><p>`</p><p>更多LaTex语法请参考 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">这儿</a>.</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：<br><code>sequence张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure><p>或者流程图：</p><p>flow<br>st=&gt;start: 开始<br>e=&gt;end: 结束<br>op=&gt;operation: 我的操作<br>cond=&gt;condition: 确认？</p><p>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>序列图</strong> 语法，参考 <a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">这儿</a>,</li><li>关于 <strong>流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">这儿</a>.</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Markdown编辑器写博客&quot;&gt;&lt;a href=&quot;#Markdown编辑器写博客&quot; class=&quot;headerlink&quot; title=&quot;Markdown编辑器写博客&quot;&gt;&lt;/a&gt;Markdown编辑器写博客&lt;/h2&gt;&lt;p&gt;新功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Markdown和扩展Markdown简洁的语法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码块高亮&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图片链接和图片上传&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;LaTex&lt;/em&gt;数学公式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UML序列图和流程图&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;离线写博客&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;导入导出Markdown文件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;丰富的快捷键&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="实用知识" scheme="http://dmdada.top/tags/%E5%AE%9E%E7%94%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
