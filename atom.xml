<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>邓铭的博客</title>
  
  <subtitle>努力不一定成功，不努力一定不成功！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dmdada.top/"/>
  <updated>2018-07-18T15:20:22.894Z</updated>
  <id>http://dmdada.top/</id>
  
  <author>
    <name>邓铭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://dmdada.top/2018/07/18/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://dmdada.top/2018/07/18/布隆过滤器/</id>
    <published>2018-07-18T15:20:22.000Z</published>
    <updated>2018-07-18T15:20:22.894Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树的层序遍历</title>
    <link href="http://dmdada.top/2018/07/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://dmdada.top/2018/07/16/二叉树的层序遍历/</id>
    <published>2018-07-16T15:31:17.000Z</published>
    <updated>2018-07-18T14:55:00.128Z</updated>
    
    <content type="html"><![CDATA[<h3 id="层序遍历算法"><a href="#层序遍历算法" class="headerlink" title="层序遍历算法"></a>层序遍历算法</h3><p>二叉树的层序遍历：从根开始，依次向下，对于每一层从左向右遍历。<br>同二叉树的前中后序遍历不同的是，前中后序采用的是堆，而二叉树层序遍历采用的是队列。<br>因此前中后序遍历可以采用递归算法，而层序遍历却不行！</p><h3 id="层序遍历的模拟实现"><a href="#层序遍历的模拟实现" class="headerlink" title="层序遍历的模拟实现"></a>层序遍历的模拟实现</h3><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;层序遍历算法&quot;&gt;&lt;a href=&quot;#层序遍历算法&quot; class=&quot;headerlink&quot; title=&quot;层序遍历算法&quot;&gt;&lt;/a&gt;层序遍历算法&lt;/h3&gt;&lt;p&gt;二叉树的层序遍历：从根开始，依次向下，对于每一层从左向右遍历。&lt;br&gt;同二叉树的前中后序遍历不同的是，前中后序采用的是堆，而二叉树层序遍历采用的是队列。&lt;br&gt;因此前中后序遍历可以采用递归算法，而层序遍历却不行！&lt;/p&gt;
&lt;h3 id=&quot;层序遍历的模拟实现&quot;&gt;&lt;a href=&quot;#层序遍历的模拟实现&quot; class=&quot;headerlink&quot; title=&quot;层序遍历的模拟实现&quot;&gt;&lt;/a&gt;层序遍历的模拟实现&lt;/h3&gt;&lt;h3 id=&quot;结果&quot;&gt;&lt;a href=&quot;#结果&quot; class=&quot;headerlink&quot; title=&quot;结果&quot;&gt;&lt;/a&gt;结果&lt;/h3&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://dmdada.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的链式存储实现</title>
    <link href="http://dmdada.top/2018/07/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://dmdada.top/2018/07/15/二叉树的链式存储实现/</id>
    <published>2018-07-15T07:05:36.000Z</published>
    <updated>2018-07-15T15:40:52.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h2><p>数组表示法用于完全二叉树的存储表示非常有效，但表示一般二叉树则不是很理想。此外，在一棵树中进行插入和删除操作时，为了反应结点层次的变动，可能需要移动许多的结点，这样降低了算法的效率，而使用了链表表示可以克服这样的缺点。<br>根据二叉树的定义，可以设计出二叉树节点的构造。二叉树的每一个结点至少应该包括三个域：数据、左孩子、右孩子。这种链表结构一般被叫做二叉链表。使用这种链表可以很方便的表示和找到它的子女，但找到它的双亲却很困难。为了便于查找双亲，我们还可以增加一个双亲指针域，这种结构被称为三叉链表。<br>结构如下：<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A82.jpg" alt="这里写图片描述"></p><h3 id="二叉链表的类定义"><a href="#二叉链表的类定义" class="headerlink" title="二叉链表的类定义"></a>二叉链表的类定义</h3><p>三叉链表和二叉链表类似，本文只讨论二叉链表。下面给出二叉链表的类定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEAD_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEAD_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>  DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data;</span><br><span class="line">BinTreeNode *leftchild, *righutchild;</span><br><span class="line">&#125;Binarynode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinaryTree()</span><br><span class="line">:root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">BinaryTree(BinaryTree&amp; s);</span><br><span class="line">~BinaryTree();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatBinTree</span><span class="params">(Binarynode*&amp;subTree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ceratBinTree</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Binarynode *<span class="title">find</span><span class="params">()</span></span>;<span class="comment">//搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//中序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//后序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Binarynode* subTree)</span></span>;<span class="comment">//统计节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hight</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hight</span><span class="params">(Binarynode* subTree)</span></span>;<span class="comment">//求树高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BinaryTree* <span class="title">copy</span><span class="params">(Binarynode*&amp;Tree)</span></span>;<span class="comment">//复制二叉树</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Binarynode *root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="二叉链表的实现"><a href="#二叉链表的实现" class="headerlink" title="二叉链表的实现"></a>二叉链表的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>  DataType;</span><br><span class="line">DataType RefValue = <span class="string">'#'</span>;<span class="comment">//输入结束符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data;</span><br><span class="line">BinTreeNode *leftchild, *rightchild;</span><br><span class="line">&#125;Binarynode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinaryTree()</span><br><span class="line">:root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">BinaryTree(BinaryTree&amp; s);</span><br><span class="line">~BinaryTree();</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Binarynode *<span class="title">find</span><span class="params">(DataType &amp;item)</span></span>;<span class="comment">//搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatBinTree</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatBinTree</span><span class="params">(Binarynode*&amp;subTree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//中序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Binarynode *subTree)</span></span>;<span class="comment">//后序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Binarynode* subTree)</span></span>;<span class="comment">//统计节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hight</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hight</span><span class="params">(Binarynode* subTree)</span></span>;<span class="comment">//求树高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Binarynode* <span class="title">copy</span><span class="params">(Binarynode*&amp;Tree)</span></span>;<span class="comment">//复制二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">(Binarynode*&amp;Tree)</span></span>;<span class="comment">//销毁</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Binarynode *root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> BinaryTree::IsEmpty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Binarynode* BinaryTree::find(DataType&amp; item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (item != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Binarynode *tmp = root;</span><br><span class="line">Binarynode*tmpl = tmp-&gt;leftchild;</span><br><span class="line">Binarynode*tmpr = tmp-&gt;rightchild;</span><br><span class="line">DataType temp = root-&gt;data;</span><br><span class="line"><span class="keyword">while</span> (tmpl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp != item)</span><br><span class="line">&#123;</span><br><span class="line">tmpl = tmpl-&gt;leftchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i find it"</span>;</span><br><span class="line"><span class="keyword">return</span> tmpl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (tmpr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp != item)</span><br><span class="line">&#123;</span><br><span class="line">tmpr = tmpr-&gt;rightchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i find it "</span>;</span><br><span class="line"><span class="keyword">return</span> tmpr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"can't find it"</span>;</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::PreOrder()</span><br><span class="line">&#123;</span><br><span class="line">PreOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::PreOrder(Binarynode*subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; subTree-&gt;data;</span><br><span class="line">PreOrder(subTree-&gt;leftchild);</span><br><span class="line">PreOrder(subTree-&gt;rightchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::InOrder()</span><br><span class="line">&#123;</span><br><span class="line">InOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::InOrder(Binarynode* subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">InOrder(subTree-&gt;leftchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; subTree-&gt;data;</span><br><span class="line">InOrder(subTree-&gt;rightchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">void</span> BinaryTree::PostOrder()</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::PostOrder(Binarynode*subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(subTree-&gt;leftchild);</span><br><span class="line">PostOrder(subTree-&gt;rightchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; subTree-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::Hight()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Hight(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::Hight(Binarynode* subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> dep1 = Hight(subTree-&gt;leftchild);</span><br><span class="line"><span class="keyword">int</span> dep2 = Hight(subTree-&gt;rightchild);</span><br><span class="line"><span class="keyword">if</span> (dep1&gt;dep2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dep1 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dep2 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::count()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> count(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::count(Binarynode*subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + count(subTree-&gt;leftchild) + count(subTree-&gt;rightchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BinaryTree::copy()</span><br><span class="line">&#123;</span><br><span class="line">copy(root);</span><br><span class="line">&#125;</span><br><span class="line">Binarynode* BinaryTree::copy(Binarynode*&amp;Tree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Binarynode *tmp = <span class="keyword">new</span> Binarynode;</span><br><span class="line">tmp-&gt;data = Tree-&gt;data;</span><br><span class="line">tmp-&gt;leftchild = copy(Tree-&gt;leftchild);</span><br><span class="line">tmp-&gt;rightchild = copy(Tree-&gt;rightchild);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::creatBinTree(Binarynode*&amp;subTree)</span><br><span class="line">&#123;</span><br><span class="line">DataType item;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; item;</span><br><span class="line"><span class="keyword">if</span> (item != RefValue)</span><br><span class="line">&#123;</span><br><span class="line">subTree = <span class="keyword">new</span> Binarynode;</span><br><span class="line">subTree-&gt;data = item;</span><br><span class="line"><span class="keyword">if</span> (subTree == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"存储分配错误"</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">creatBinTree(subTree-&gt;leftchild);</span><br><span class="line">creatBinTree(subTree-&gt;rightchild);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">subTree = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BinaryTree::creatBinTree()</span><br><span class="line">&#123;</span><br><span class="line">creatBinTree(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BinaryTree::destory(Binarynode*&amp;Tree)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Tree != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">destory(Tree-&gt;leftchild);</span><br><span class="line">destory(Tree-&gt;rightchild);</span><br><span class="line"><span class="keyword">delete</span> Tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryTree::~BinaryTree()</span><br><span class="line">&#123;</span><br><span class="line">destory(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BinaryTree::BinaryTree(BinaryTree &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">root = copy(s.root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BinaryTree subTree;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入节点，空结点以#代替:"</span>;</span><br><span class="line">subTree.creatBinTree();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"前序遍历："</span>;</span><br><span class="line">subTree.PreOrder();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="string">"中序遍历："</span>;</span><br><span class="line">subTree.InOrder();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"后序遍历："</span>;</span><br><span class="line">subTree.PostOrder();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"结点个数："</span>&lt;&lt;subTree.count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"树的高度："</span>&lt;&lt;subTree.Hight()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.jpg" alt=""></p><h3 id="关于链表的输入"><a href="#关于链表的输入" class="headerlink" title="关于链表的输入"></a>关于链表的输入</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A83.jpg" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉链表&quot;&gt;&lt;a href=&quot;#二叉链表&quot; class=&quot;headerlink&quot; title=&quot;二叉链表&quot;&gt;&lt;/a&gt;二叉链表&lt;/h2&gt;&lt;p&gt;数组表示法用于完全二叉树的存储表示非常有效，但表示一般二叉树则不是很理想。此外，在一棵树中进行插入和删除操作时，为了反应结点层次的变动，可能需要移动许多的结点，这样降低了算法的效率，而使用了链表表示可以克服这样的缺点。&lt;br&gt;根据二叉树的定义，可以设计出二叉树节点的构造。二叉树的每一个结点至少应该包括三个域：数据、左孩子、右孩子。这种链表结构一般被叫做二叉链表。使用这种链表可以很方便的表示和找到它的子女，但找到它的双亲却很困难。为了便于查找双亲，我们还可以增加一个双亲指针域，这种结构被称为三叉链表。&lt;br&gt;结构如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://dmdada.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://dmdada.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Pairs-对组介绍</title>
    <link href="http://dmdada.top/2018/07/12/Pairs-%E5%AF%B9%E7%BB%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://dmdada.top/2018/07/12/Pairs-对组介绍/</id>
    <published>2018-07-12T14:44:00.000Z</published>
    <updated>2018-07-12T15:42:57.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队组"><a href="#队组" class="headerlink" title="队组"></a>队组</h2><p>class Pair 可以将两个值视作一个单元。C++标准库库内多处使用了这个Class，尤其是容器map和multimap，就是使用了Pairs来管理键值对，任何函数返回两个值也需要pair.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>  <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">Pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    pair()</span><br><span class="line">    :first(T1(),second(T2))</span><br><span class="line">    &#123;&#125;</span><br><span class="line">      pair(<span class="keyword">const</span> pair&lt;U,V&gt;&amp;p)</span><br><span class="line">      :first (p.first),second(p.second)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>注意，pair被定义为struct，而不是class，这样所有成员都是public,因此可以直接存储pair的个别值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>:pair&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt;p;</span><br></pre></td></tr></table></figure></p><p>上述defalut构造函数生成一个pair时，以int（）和float（）来初始化p,这两个构造函数为0值；<br>如果pair对象被复制，调用的是由系统隐式生成的的哪个copy构造函数，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>:：pair&lt;<span class="keyword">int</span>,<span class="keyword">const</span> <span class="keyword">char</span>*&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;)</span></span>;</span><br><span class="line"><span class="keyword">void</span> foo&#123;</span><br><span class="line">  <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">const</span> <span class="keyword">char</span>*&gt;p(<span class="number">42</span>,<span class="string">"hello"</span>);</span><br><span class="line">  f(p);</span><br><span class="line">  g(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="pair之间的比较"><a href="#pair之间的比较" class="headerlink" title="pair之间的比较"></a>pair之间的比较</h2><p>为了比较两个pair对象，C++标准程序库提供了大家惯用的操作符。如果两个pair对象内的所有元素相等，这两个pair对象就被视为相等。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> ,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">pair</span>&lt;T,T2&gt;&amp;<span class="title">X</span>,<span class="title">const</span> <span class="title">pair</span> &lt;T,T2&gt;&amp;<span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.first==y.first&amp;&amp;x.second==y.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当两个pairs相互比较时，第一元素具有较高的优先级，所以如果两个pairs的第一元素不相等，其比较结果就称为整个比较行为的结果。如果第一元素相等，才继续比较第二元素，并把比较结果当作整体比较结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>&lt;const pair&lt;T1,T2&gt;&amp;X,const pair&lt;T1,T2&gt;&amp;y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">  return x.first&lt;y.first||(!(y.first/,x.first)&amp;&amp;x.second&lt;y.second);</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p><p>其他的比较操作符，也差不多相似。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;队组&quot;&gt;&lt;a href=&quot;#队组&quot; class=&quot;headerlink&quot; title=&quot;队组&quot;&gt;&lt;/a&gt;队组&lt;/h2&gt;&lt;p&gt;class Pair 可以将两个值视作一个单元。C++标准库库内多处使用了这个Class，尤其是容器map和multimap，就是使用了Pairs来管理键值对，任何函数返回两个值也需要pair.&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;  &lt;span class=&quot;title&quot;&gt;T1&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;T2&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;  &lt;span class=&quot;title&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Pair&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; T1 first_type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; T2 second_type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pair()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    :first(T1(),second(T2))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      pair(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; pair&amp;lt;U,V&amp;gt;&amp;amp;p)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      :first (p.first),second(p.second)&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++标准程序库" scheme="http://dmdada.top/tags/C-%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://dmdada.top/2018/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://dmdada.top/2018/07/09/二叉树/</id>
    <published>2018-07-09T14:38:40.000Z</published>
    <updated>2018-07-15T07:04:57.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。<br>二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。<br>一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为log2(n+1)。深度为k的完全二叉树，至少有2^(k-1)个节点，至多有2^k-1个节点。<br><a id="more"></a></p><h3 id="二叉树相关知识"><a href="#二叉树相关知识" class="headerlink" title="二叉树相关知识"></a>二叉树相关知识</h3><p>满二叉树：在一棵二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层，则这样的二叉树称作满二叉树。<br>完全二叉树：如果一颗具有n个节点的二叉树的结构与满二叉树的前n个节点的结构相同，这样的二叉树称为完全二叉树。</p><h3 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h3><p>1:若规定根节点的层数为0，则一棵非空二叉树的第i层上最多有2^i(i&gt;=0)个节点。<br>2: 若规定只有根节点的二叉树的深度为0，则深度为k的二叉树的最大节点数是2^(k+1)-1(k&gt;=-1)。<br>3:对于一棵非空的二叉树，如果叶节点个数为n0，度为2的节点个数为n2，则有n0=n2+1。<br>4:具有n个节点的完全二叉树的深度k为大于或等于ln(n+1)-1的最小整数。<br>5:对于具有n个节点的完全二叉树，如果按照从上至下和从左至右的顺序对所有节点序号从0开始顺序编号，则对于序号为i(0&lt;=i&lt;n)的节点有：<br> 1)如果i〉0，则序号为i节点的双亲节点的序号为(i-1)/2(/为整除)；如果i=0，则序号为i节点为根节点，无双亲节点。<br> 2)如果2i+1&lt;n,则序号为i节点的左孩子节点的序号为2i+1；如果2i+1&gt;=n,则序号为i节点无左孩子。<br> 3)如果2i+2&lt;n,则序号为i节点的右孩子节点的序号为2i+2;如果2i+2&gt;=n，则序号为i节点无右孩子。</p><h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h3><p>1.二叉树的顺序存储结构<br> 利用性质5，对于完全二叉树可以利用一维数组存储，如果不是完全二叉树，则可以补空节点，使成为完全二叉树在进行存储，<br> 但是对于非完全二叉树，可能要浪费很多的空间。所以并不是很理想。<br>2.二叉树的链式存储结构<br>  二叉树的链式存储结构就是用指针建立二叉树中节点之间的关系，二叉树最常用的链式存储结构是二叉链表。二叉树的二叉链表存储结构是一种常用的二叉树存储结构。二叉链表存储结构的优点是结构简单，可以方便的构造任何形状的二叉树，并可以方便的实现二叉树的大多数操作。<br>  二叉链表存储结构的缺点是，查找当前节点的双亲节点操作实现比较麻烦。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h3&gt;&lt;p&gt;在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。&lt;br&gt;二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。&lt;br&gt;一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为log2(n+1)。深度为k的完全二叉树，至少有2^(k-1)个节点，至多有2^k-1个节点。&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://dmdada.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>简单UDP网络程序</title>
    <link href="http://dmdada.top/2018/07/07/%E7%AE%80%E5%8D%95UDP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F/"/>
    <id>http://dmdada.top/2018/07/07/简单UDP网络程序/</id>
    <published>2018-07-07T07:23:25.000Z</published>
    <updated>2018-07-07T07:33:41.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现简单UDP客户端和服务器端"><a href="#实现简单UDP客户端和服务器端" class="headerlink" title="实现简单UDP客户端和服务器端"></a>实现简单UDP客户端和服务器端</h3><p>实现简单的基于UDP协议的客户端和服务器端聊天小程序。</p><a id="more"></a><h4 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                                                                                                                                     </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;                                                                                                                                </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;                                                                                                                                </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;                                                                                                                                 </span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">sockaddr</span>;</span>                                                                                                                      </span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockaddr_in</span>;</span>                                                                                                                </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;                                                                                                                      </span><br><span class="line">   <span class="keyword">int</span> sock = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);                                                                                                              </span><br><span class="line">   <span class="keyword">if</span> (sock&lt;<span class="number">0</span>)                                                                                                                                           </span><br><span class="line">   &#123;                                                                                                                                                     </span><br><span class="line">   perror(<span class="string">"socket"</span>);                                                                                                                                     </span><br><span class="line">   <span class="keyword">return</span> <span class="number">2</span>;                                                                                                                                             </span><br><span class="line">   &#125;                                                                                                                                                     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local</span>;</span>                                                                                                                            </span><br><span class="line">    local.sin_family=AF_INET;                                                                                                                            </span><br><span class="line">    local.sin_port=htons(atoi(argv[<span class="number">1</span>]));                                                                                                                 </span><br><span class="line">    local.sin_addr.s_addr=htonl(INADDR_ANY);                                                                                                             </span><br><span class="line">  <span class="keyword">if</span> (bind(sock,(struct sockaddr*)&amp;local,<span class="keyword">sizeof</span>(local))&lt;<span class="number">0</span>)                                                                                               </span><br><span class="line">  &#123;                                                                                                                                                      </span><br><span class="line">  perror(<span class="string">"bind"</span>);                                                                                                                                        </span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;                                                                                                                                              </span><br><span class="line">  &#125;                                                                                                                                                      </span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>];                                                                                                                                        </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span>                                                                                                                             </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)                                                                                                                                               </span><br><span class="line">  &#123;                                                                                                                                                      </span><br><span class="line">    <span class="keyword">socklen_t</span> len= <span class="keyword">sizeof</span>(client);                                                                                                                       </span><br><span class="line">    <span class="keyword">ssize_t</span> s=recvfrom(sock,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,<span class="number">0</span>,(struct sockaddr*)&amp;client,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(s&gt;<span class="number">0</span>)                                                                                                                                              </span><br><span class="line">    &#123;                                                                                                                                                    </span><br><span class="line">  buf[s]=<span class="number">0</span>;                                                                                                                                              </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[%s:%d]: %s\n"</span>,inet_ntoa(client.sin_addr),ntohs(client.sin_port),buf);                                                                         </span><br><span class="line">      sendto(sock,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>,(struct sockaddr*)&amp;client,<span class="keyword">sizeof</span>(client));                                                                           </span><br><span class="line">    &#125;                                                                                                                                                    </span><br><span class="line">  &#125;                                                                                                                                                      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                            </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                                                                                                                                     </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;                                                                                                                                </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;                                                                                                                                </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;                                                                                                                                 </span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">sockaddr</span>;</span>                                                                                                                      </span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockaddr_in</span>;</span>                                                                                                                </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;                                                                                                                      </span><br><span class="line">    <span class="keyword">int</span> sock=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);                                                                                                               </span><br><span class="line">   <span class="keyword">if</span> (sock&lt;<span class="number">0</span>) &#123;                                                                                                                                         </span><br><span class="line">     perror(<span class="string">"socket"</span>);                                                                                                                                   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">2</span>;                                                                                                                                           </span><br><span class="line"></span><br><span class="line">   &#125;                                                                                                                                                     </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span>                                                                                                                            </span><br><span class="line">   server.sin_family=AF_INET;                                                                                                                            </span><br><span class="line">   server.sin_port=htons(atoi(argv[<span class="number">2</span>]));                                                                                                                 </span><br><span class="line">   server.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);                                                                                                            </span><br><span class="line">  <span class="keyword">char</span> buff[<span class="number">1024</span>];                                                                                                                                       </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">peer</span>;</span>                                                                                                                               </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)                                                                                                                                               </span><br><span class="line">  &#123;                                                                                                                                                      </span><br><span class="line">  <span class="keyword">socklen_t</span> len =<span class="keyword">sizeof</span>(peer);                                                                                                                           </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"please enter： "</span>);                                                                                                                                </span><br><span class="line">  fflush(<span class="built_in">stdout</span>);                                                                                                                                        </span><br><span class="line">  <span class="keyword">ssize_t</span> s=read(<span class="number">0</span>,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>);                                                                                                                 </span><br><span class="line">  <span class="keyword">if</span>(s&gt;<span class="number">0</span>)                                                                                                                                                </span><br><span class="line">  &#123;                                                                                                                                                      </span><br><span class="line">    buff[s<span class="number">-1</span>]=<span class="number">0</span>;                                                                                                                                         </span><br><span class="line">    sendto(sock,buff,<span class="built_in">strlen</span>(buff),<span class="number">0</span>,(struct sockaddr*)&amp;server,<span class="keyword">sizeof</span>(server));                                                                           </span><br><span class="line">    <span class="keyword">ssize_t</span> _s=recvfrom(sock,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>,<span class="number">0</span>,(struct sockaddr*)&amp;peer,&amp;len);</span><br><span class="line">    <span class="keyword">if</span> (_s&gt;<span class="number">0</span>) &#123;                                                                                                                                          </span><br><span class="line">      buff[_s]=<span class="number">0</span>;                                                                                                                                        </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"server echo %s\n"</span>,buff);                                                                                                                    </span><br><span class="line">    &#125;                                                                                                                                                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;                                                                                                                                                      </span><br><span class="line">  &#125;                                                                                                                                                      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                            </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>1.运行服务器<br><img src="http://pajznqooi.bkt.clouddn.com/UDP1.jpg" alt="404"><br>2.检查端口</p><p><img src="http://pajznqooi.bkt.clouddn.com/UDP2.jpg" alt="404"></p><p>3.运行客户端<br><img src="http://pajznqooi.bkt.clouddn.com/UDP3.jpg" alt="404"></p><p>4.查看服务器端<br><img src="http://pajznqooi.bkt.clouddn.com/UDP4.jpg" alt="404"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现简单UDP客户端和服务器端&quot;&gt;&lt;a href=&quot;#实现简单UDP客户端和服务器端&quot; class=&quot;headerlink&quot; title=&quot;实现简单UDP客户端和服务器端&quot;&gt;&lt;/a&gt;实现简单UDP客户端和服务器端&lt;/h3&gt;&lt;p&gt;实现简单的基于UDP协议的客户端和服务器端聊天小程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://dmdada.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>模板</title>
    <link href="http://dmdada.top/2018/07/01/%E6%A8%A1%E6%9D%BF/"/>
    <id>http://dmdada.top/2018/07/01/模板/</id>
    <published>2018-07-01T12:55:08.000Z</published>
    <updated>2018-07-05T14:38:35.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>模板是实现代码重用机制的一种工具，它可以实现数据类型的参数化，即将数据类型定义为参数，而由编译系统在处理具体函数调用时，根据实参类型来匹配函数模板中的对应形参并在确认后生成一个重载函数，从而真正实现代码重用。</p><p>C++中，允许用户构造函数模板，创建支持多种不同数据类型的形参但却具有通用功能的函数；也允许构造类模板，使的类中某些数据成员，成员函数的参数和返回值可以是任意数据类型。使用模板可以从一个函数生成多个函数或者从一个类模板生成多个类，建立一个模板后，编译器将根据使用时的实际数据类型使其实例化，生成可执行的代码，实例化的函数模板称为模板函数；实例化的类称为模板类。模板、模板函数、模板类以及对象关系如下：<br><a id="more"></a><br><img src="http://pajznqooi.bkt.clouddn.com/%E6%A8%A1%E6%9D%BF.png" alt="404"><br>模板使用方法：<br><code>templete&lt;&lt;类型形参表》&lt;返回类型&gt;&lt;函数名&gt;(模板形参表){...}</code><br><!--more--></p><h3 id="模板函数的使用"><a href="#模板函数的使用" class="headerlink" title="模板函数的使用"></a>模板函数的使用</h3><pre><code class="c++"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;                                                                                                                                       </span></span><span class="keyword">using</span> <span class="keyword">namespace</span>  <span class="built_in">std</span>;                                                                                                                                    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                                                                                                       <span class="function">T <span class="title">Power</span><span class="params">(T base,<span class="keyword">int</span> exponent)</span>                                                                                                                             </span><span class="function"></span>{                                                                                                                                                         T value =base;                                                                                                                                           <span class="keyword">while</span>(--exponent&gt;<span class="number">0</span>)                                                                                                                                      {                                                                                                                                                       value*=base;                                                                                                                                             <span class="keyword">return</span> value;                                                                                                                                             }                                                                                                                                                       }                                                                                                                                                        <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                                                                                                                                               </span><span class="function"></span>{                                                                                                                                                          <span class="built_in">cout</span>&lt;&lt;<span class="string">"18^1="</span>&lt;&lt;Power(<span class="number">18</span>,<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;                                                                                                                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"5^3="</span>&lt;&lt;Power(<span class="number">5</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;                                                                                                                          <span class="built_in">cout</span>&lt;&lt;<span class="string">"2.6^7="</span>&lt;&lt;Power(<span class="number">2.6</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;                                                                                                                      <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                              }</code></pre><p>结果：<br><img src="http://pajznqooi.bkt.clouddn.com/%E6%A8%A1%E6%9D%BF1.jpg" alt="404"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h3&gt;&lt;p&gt;模板是实现代码重用机制的一种工具，它可以实现数据类型的参数化，即将数据类型定义为参数，而由编译系统在处理具体函数调用时，根据实参类型来匹配函数模板中的对应形参并在确认后生成一个重载函数，从而真正实现代码重用。&lt;/p&gt;
&lt;p&gt;C++中，允许用户构造函数模板，创建支持多种不同数据类型的形参但却具有通用功能的函数；也允许构造类模板，使的类中某些数据成员，成员函数的参数和返回值可以是任意数据类型。使用模板可以从一个函数生成多个函数或者从一个类模板生成多个类，建立一个模板后，编译器将根据使用时的实际数据类型使其实例化，生成可执行的代码，实例化的函数模板称为模板函数；实例化的类称为模板类。模板、模板函数、模板类以及对象关系如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://dmdada.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Vector</title>
    <link href="http://dmdada.top/2018/06/29/Vector/"/>
    <id>http://dmdada.top/2018/06/29/Vector/</id>
    <published>2018-06-29T15:48:16.000Z</published>
    <updated>2018-07-07T05:49:23.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>名词解释：vector 是同一种类型的对象的集合,每个对象都有一个对应的整数索引值 。<br>和 string 对象一样,标准库将负责管理与存储元素相关的内存。我们把 vector称为容器,是因为它可以包含其他对象，能够存放任意类型的动态数组，增加和压缩数据。一个容器中的所有对象都必须是同一种类型的 。<br>vector 是一个类模板(class template)。使用模板可以编写一个类定义或函数定义,而用于多个不同的数据类型。因此,我们可以定义保存 string 对象的 vector,或保存 int 值的 vector,又或是保存自定义的类类型对象(如Sales_items 对象)的 vector。vector 不是一种数据类型,而只是一个类模板,可用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。<br><a id="more"></a></p><h3 id="vectors运用实例"><a href="#vectors运用实例" class="headerlink" title="vectors运用实例"></a>vectors运用实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;                                                                                                                                     </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;                                                                                                                                       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;                                                                                                                                       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;                                                                                                                                    </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sentence;</span><br><span class="line">sentence.reserve(<span class="number">5</span>);</span><br><span class="line">sentence.push_back(<span class="string">"hello,"</span>);</span><br><span class="line">sentence.push_back(<span class="string">"how"</span>);</span><br><span class="line">sentence.push_back(<span class="string">"are"</span>);</span><br><span class="line">sentence.push_back(<span class="string">"you"</span>);</span><br><span class="line">sentence.push_back(<span class="string">"？"</span>);</span><br><span class="line">copy(sentence.begin(), sentence.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"max_size():"</span> &lt;&lt; sentence.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size():"</span> &lt;&lt; sentence.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity():"</span> &lt;&lt; sentence.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">swap(sentence[<span class="number">1</span>], sentence[<span class="number">3</span>]);</span><br><span class="line">sentence.insert(find(sentence.begin(), sentence.end(), <span class="string">"？"</span>), <span class="string">"always"</span>);</span><br><span class="line">sentence.back() = <span class="string">"!"</span>;</span><br><span class="line">copy(sentence.begin(), sentence.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"max():"</span> &lt;&lt; sentence.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size();"</span> &lt;&lt; sentence.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity()"</span> &lt;&lt; sentence.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/vector.jpg" alt="404"></p><p>实验结果可能如此，注意我说的是“可能”，是的当max_size()和capacity（）的结果由实作版本决定，从这个例子中你可以看到，当容量不足时，此一实作版本将容量扩充1。所以你可以试着运行一下看看有没有和我不同。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Vector&quot;&gt;&lt;a href=&quot;#Vector&quot; class=&quot;headerlink&quot; title=&quot;Vector&quot;&gt;&lt;/a&gt;Vector&lt;/h3&gt;&lt;p&gt;名词解释：vector 是同一种类型的对象的集合,每个对象都有一个对应的整数索引值 。&lt;br&gt;和 string 对象一样,标准库将负责管理与存储元素相关的内存。我们把 vector称为容器,是因为它可以包含其他对象，能够存放任意类型的动态数组，增加和压缩数据。一个容器中的所有对象都必须是同一种类型的 。&lt;br&gt;vector 是一个类模板(class template)。使用模板可以编写一个类定义或函数定义,而用于多个不同的数据类型。因此,我们可以定义保存 string 对象的 vector,或保存 int 值的 vector,又或是保存自定义的类类型对象(如Sales_items 对象)的 vector。vector 不是一种数据类型,而只是一个类模板,可用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://dmdada.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="http://dmdada.top/2018/06/28/Markdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://dmdada.top/2018/06/28/Markdown语法/</id>
    <published>2018-06-28T15:05:57.000Z</published>
    <updated>2018-07-05T14:38:35.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown编辑器写博客"><a href="#Markdown编辑器写博客" class="headerlink" title="Markdown编辑器写博客"></a>Markdown编辑器写博客</h2><p>新功能：</p><ul><li><strong>Markdown和扩展Markdown简洁的语法</strong></li><li><strong>代码块高亮</strong></li><li><strong>图片链接和图片上传</strong></li><li><strong><em>LaTex</em>数学公式</strong></li><li><strong>UML序列图和流程图</strong></li><li><strong>离线写博客</strong></li><li><strong>导入导出Markdown文件</strong></li><li><strong>丰富的快捷键</strong></li></ul><hr><a id="more"></a><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>加粗    <code>Ctrl + B</code></li><li>斜体    <code>Ctrl + I</code></li><li>引用    <code>Ctrl + Q</code></li><li>插入链接    <code>Ctrl + L</code></li><li>插入代码    <code>Ctrl + K</code></li><li>插入图片    <code>Ctrl + G</code></li><li>提升标题    <code>Ctrl + H</code></li><li>有序列表    <code>Ctrl + O</code></li><li>无序列表    <code>Ctrl + U</code></li><li>横线    <code>Ctrl + R</code></li><li>撤销    <code>Ctrl + Z</code></li><li>重做    <code>Ctrl + Y</code></li></ul><h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</a></p></blockquote><p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net" target="_blank" rel="noopener">链接</a>等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 表格</span><br><span class="line"></span><br><span class="line">**Markdown　Extra**　表格语法：</span><br><span class="line"></span><br><span class="line">项目     | 价格</span><br><span class="line">-------- | ---</span><br><span class="line">Computer | $1600</span><br><span class="line">Phone    | $12</span><br><span class="line">Pipe     | $1</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>项目</th><th>价格</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可以使用冒号来定义对齐方式：</span><br><span class="line"></span><br><span class="line">| 项目      |    价格 | 数量  |</span><br><span class="line">| :-------- | --------:| :--: |</span><br><span class="line">| Computer  | 1600 元 |  5   |</span><br><span class="line">| Phone     |   12 元 |  12  |</span><br><span class="line">| Pipe      |    1 元 | 234  |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">1600 元</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">12 元</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">1 元</td><td style="text-align:center">234</td></tr></tbody></table><p>###定义列表</p><p><strong>Markdown　Extra</strong>　定义列表语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">项目１</span><br><span class="line">项目２</span><br><span class="line">:   定义 A</span><br><span class="line">:   定义 B</span><br><span class="line"></span><br><span class="line">项目３</span><br><span class="line">:   定义 C</span><br><span class="line"></span><br><span class="line">:   定义 D</span><br><span class="line"></span><br><span class="line">&gt; 定义D内容</span><br></pre></td></tr></table></figure><p>项目１<br>项目２<br>:   定义 A<br>:   定义 B</p><p>项目３<br>:   定义 C</p><p>:   定义 D</p><pre><code>&gt; 定义D内容</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><p>###脚注<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生成一个脚注[^footnote].</span><br><span class="line">[^footnote]: 这里是 **脚注** 的 *内容*.</span><br></pre></td></tr></table></figure></p><p>生成一个脚注[^footnote].<br> [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p><p>[TOC]</p><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用MathJax渲染*LaTex* 数学公式，详见[math.stackexchange.com][1].</span><br><span class="line"></span><br><span class="line"> - 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</span><br><span class="line"> - 块级公式：</span><br><span class="line"></span><br><span class="line">$$x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$</span><br></pre></td></tr></table></figure><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href="http://math.stackexchange.com/" target="_blank" rel="noopener">math.stackexchange.com</a>.</p><ul><li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li><li>块级公式：</li></ul><p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><p>`</p><p>更多LaTex语法请参考 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">这儿</a>.</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：<br><code>sequence张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure><p>或者流程图：</p><p>flow<br>st=&gt;start: 开始<br>e=&gt;end: 结束<br>op=&gt;operation: 我的操作<br>cond=&gt;condition: 确认？</p><p>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>序列图</strong> 语法，参考 <a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">这儿</a>,</li><li>关于 <strong>流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">这儿</a>.</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Markdown编辑器写博客&quot;&gt;&lt;a href=&quot;#Markdown编辑器写博客&quot; class=&quot;headerlink&quot; title=&quot;Markdown编辑器写博客&quot;&gt;&lt;/a&gt;Markdown编辑器写博客&lt;/h2&gt;&lt;p&gt;新功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Markdown和扩展Markdown简洁的语法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码块高亮&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图片链接和图片上传&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;LaTex&lt;/em&gt;数学公式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UML序列图和流程图&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;离线写博客&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;导入导出Markdown文件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;丰富的快捷键&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="实用知识" scheme="http://dmdada.top/tags/%E5%AE%9E%E7%94%A8%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>汉诺塔</title>
    <link href="http://dmdada.top/2018/06/27/%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <id>http://dmdada.top/2018/06/27/汉诺塔/</id>
    <published>2018-06-27T14:31:19.000Z</published>
    <updated>2018-07-05T14:38:35.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><h3 id="由来及传说"><a href="#由来及传说" class="headerlink" title="由来及传说"></a>由来及传说</h3><p>由来：法国数学家爱德华·卢卡斯曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。<br>不管这个传说的可信度有多大，如果考虑一下把64片金片，由一根针上移到另一根针上，并且始终保持上小下大的顺序。这需要多少次移动呢?这里需要递归的方法。假设有n片，移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7，且f(k+1)=2*f(k)+1。此后不难证明f(n)=2^n-1。n=64时，<br>假如每秒钟一次，共需多长时间呢？一个平年365天有31536000 秒，闰年366天有31622400秒，平均每年31556952秒，计算一下：<br>18446744073709551615秒<br>这表明移完这些金片需要5845.54亿年以上，而地球存在至今不过45亿年，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，不说太阳系和银河系，至少地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。</p><p>印度传说：和汉诺塔故事相似的，还有另外一个印度传说：舍罕王打算奖赏国际象棋的发明人──宰相西萨·班·达依尔。国王问他想要什么，他对国王说：“陛下，请您在这张棋盘的第1个小格里赏给我一粒麦子，在第2个小格里给2粒，第3个小格给4粒，以后每一小格都比前一小格加一倍。请您把这样摆满棋盘上所有64格的麦粒，都赏给您的仆人吧！”国王觉得这个要求太容易满足了，就命令给他这些麦粒。当人们把一袋一袋的麦子搬来开始计数时，国王才发现：就是把全印度甚至全世界的麦粒全拿来，也满足不了那位宰相的要求。<br>那么，宰相要求得到的麦粒到底有多少呢？总数为<br>1+2+2^2 + … +2^63=2^64-1<br>等于移完汉诺塔所需的步骤数。我们已经知道这个数字有多么大了。人们估计，全世界两千年也难以生产这么多麦子！<br><a id="more"></a></p><h3 id="C语言汉诺塔的实现"><a href="#C语言汉诺塔的实现" class="headerlink" title="C语言汉诺塔的实现"></a>C语言汉诺塔的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;                                                                                                                                    </span></span></span><br><span class="line">  <span class="number">2</span> <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> form,<span class="keyword">char</span> to)</span>                                                                                                                   </span></span><br><span class="line"><span class="function">  3 </span>&#123;                                                                                                                                                    </span><br><span class="line">  <span class="number">4</span> <span class="built_in">printf</span>(<span class="string">"%d号盘从%c移到%c\n"</span>,n,form,to);                                                                                                              </span><br><span class="line">  <span class="number">5</span> &#125;                                                                                                                                                    </span><br><span class="line">  <span class="number">6</span>                                                                                                                                                      </span><br><span class="line">  <span class="number">7</span> <span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p1,<span class="keyword">int</span> p2,<span class="keyword">int</span> p3)</span>                                                                                                               </span></span><br><span class="line"><span class="function">  8 </span>&#123;                                                                                                                                                    </span><br><span class="line">  <span class="number">9</span>   <span class="keyword">if</span> (n==<span class="number">1</span>) &#123;                                                                                                                                        </span><br><span class="line"> <span class="number">10</span>     move(n,p1,p3);                                                                                                                                   </span><br><span class="line"> <span class="number">11</span>   &#125;                                                                                                                                                  </span><br><span class="line"> <span class="number">12</span>   <span class="keyword">else</span>&#123;                                                                                                                                              </span><br><span class="line"> <span class="number">13</span>     hanoi(n<span class="number">-1</span>,p1,p3,p2);                                                                                                                             </span><br><span class="line"> <span class="number">14</span>     move(n,p1,p3);                                                                                                                                   </span><br><span class="line"> <span class="number">15</span>     hanoi(n<span class="number">-1</span>,p2,p1,p3);                                                                                                                             </span><br><span class="line"> <span class="number">16</span>   &#125;                                                                                                                                                  </span><br><span class="line"> <span class="number">17</span> &#125;                                                                                                                                                    </span><br><span class="line"> <span class="number">18</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                                                                                                                                           </span></span><br><span class="line"><span class="function"> 19 </span>&#123;                                                                                                                                                    </span><br><span class="line"> <span class="number">20</span>   <span class="built_in">printf</span>(<span class="string">"请输入盘子的数量!\n"</span>);                                                                                                                     </span><br><span class="line"> <span class="number">21</span>   <span class="keyword">int</span> num=<span class="number">0</span>;                                                                                                                                         </span><br><span class="line"> <span class="number">22</span>   <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);                                                                                                                                  </span><br><span class="line"> <span class="number">23</span>   hanoi(num,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);                                                                                                                            </span><br><span class="line"> <span class="number">24</span>   <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                                          </span><br><span class="line"> <span class="number">25</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E6%B1%89%E8%AF%BA%E5%A1%94.jpg" alt="这里写图片描述"><br><img src="http://pajznqooi.bkt.clouddn.com/%E6%B1%89%E8%AF%BA%E5%A1%941.jpg" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;汉诺塔&quot;&gt;&lt;a href=&quot;#汉诺塔&quot; class=&quot;headerlink&quot; title=&quot;汉诺塔&quot;&gt;&lt;/a&gt;汉诺塔&lt;/h3&gt;&lt;p&gt;汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。&lt;/p&gt;
&lt;h3 id=&quot;由来及传说&quot;&gt;&lt;a href=&quot;#由来及传说&quot; class=&quot;headerlink&quot; title=&quot;由来及传说&quot;&gt;&lt;/a&gt;由来及传说&lt;/h3&gt;&lt;p&gt;由来：法国数学家爱德华·卢卡斯曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。&lt;br&gt;不管这个传说的可信度有多大，如果考虑一下把64片金片，由一根针上移到另一根针上，并且始终保持上小下大的顺序。这需要多少次移动呢?这里需要递归的方法。假设有n片，移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7，且f(k+1)=2*f(k)+1。此后不难证明f(n)=2^n-1。n=64时，&lt;br&gt;假如每秒钟一次，共需多长时间呢？一个平年365天有31536000 秒，闰年366天有31622400秒，平均每年31556952秒，计算一下：&lt;br&gt;18446744073709551615秒&lt;br&gt;这表明移完这些金片需要5845.54亿年以上，而地球存在至今不过45亿年，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，不说太阳系和银河系，至少地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。&lt;/p&gt;
&lt;p&gt;印度传说：和汉诺塔故事相似的，还有另外一个印度传说：舍罕王打算奖赏国际象棋的发明人──宰相西萨·班·达依尔。国王问他想要什么，他对国王说：“陛下，请您在这张棋盘的第1个小格里赏给我一粒麦子，在第2个小格里给2粒，第3个小格给4粒，以后每一小格都比前一小格加一倍。请您把这样摆满棋盘上所有64格的麦粒，都赏给您的仆人吧！”国王觉得这个要求太容易满足了，就命令给他这些麦粒。当人们把一袋一袋的麦子搬来开始计数时，国王才发现：就是把全印度甚至全世界的麦粒全拿来，也满足不了那位宰相的要求。&lt;br&gt;那么，宰相要求得到的麦粒到底有多少呢？总数为&lt;br&gt;1+2+2^2 + … +2^63=2^64-1&lt;br&gt;等于移完汉诺塔所需的步骤数。我们已经知道这个数字有多么大了。人们估计，全世界两千年也难以生产这么多麦子！&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://dmdada.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串中第一个只出现两次的字符</title>
    <link href="http://dmdada.top/2018/06/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://dmdada.top/2018/06/26/字符串中第一个只出现两次的字符/</id>
    <published>2018-06-26T14:15:46.000Z</published>
    <updated>2018-07-05T14:38:47.799Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>找到字符串中第一个只出现两次的字符<br>例 字符串”abbcdefacdefba”<br>第一个只出现一次的字符是c</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>设置两个指针分别遍历数组<br>若指针1等于指针2则计数器加1，遍历完后若计数器为1则输出字符，并结束遍历</p><a id="more"></a><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findstr</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">char</span> tmp = <span class="string">'a'</span>;</span><br><span class="line"> <span class="keyword">char</span>*src = str+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (*str != <span class="string">'\0'</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> count = <span class="number">0</span>;</span><br><span class="line"> src = str+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (*src != <span class="string">'\0'</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (*str == *src)</span><br><span class="line"> &#123;</span><br><span class="line">   count++;</span><br><span class="line">   tmp = *src;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"> src++;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"找到字符是：%c\n"</span>,tmp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> str++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"没找到"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"abacdebaf"</span>;</span><br><span class="line">findstr(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%AD%97%E7%AC%A6.jpg" alt="这里写图片描述"><br><img src="http://pajznqooi.bkt.clouddn.com/%E5%AD%97%E7%AC%A62.jpg" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;找到字符串中第一个只出现两次的字符&lt;br&gt;例 字符串”abbcdefacdefba”&lt;br&gt;第一个只出现一次的字符是c&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;p&gt;设置两个指针分别遍历数组&lt;br&gt;若指针1等于指针2则计数器加1，遍历完后若计数器为1则输出字符，并结束遍历&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://dmdada.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://dmdada.top/2018/06/24/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://dmdada.top/2018/06/24/选择排序/</id>
    <published>2018-06-24T14:48:23.000Z</published>
    <updated>2018-07-05T14:38:35.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>名词解释：选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>设置双重循环第一重循环从数组第一个元素开始，第二重循环从数组第二个元素开始，然后找出第二重循环中小于第一重循环的最小数，然后与第一重循环的首元素之交换。<br>图解：<br><img src="http://pajznqooi.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="这里写图片描述"><br><a id="more"></a></p><h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h3><p>时间复杂度：<code>O（n2)</code><br>空间复杂度：<code>O(1)</code><br>算法稳定性：不稳定算法</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selectionsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max; <span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">max = i;</span><br><span class="line"><span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; size; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[max]&gt;arr[j])</span><br><span class="line"></span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i != max)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">arr[i] = arr[max];</span><br><span class="line">arr[max] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">30</span>,<span class="number">300</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">Selectionsort(<span class="built_in">array</span>,num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h3&gt;&lt;p&gt;名词解释：选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。&lt;/p&gt;
&lt;h2 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h2&gt;&lt;p&gt;设置双重循环第一重循环从数组第一个元素开始，第二重循环从数组第二个元素开始，然后找出第二重循环中小于第一重循环的最小数，然后与第一重循环的首元素之交换。&lt;br&gt;图解：&lt;br&gt;&lt;img src=&quot;http://pajznqooi.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://dmdada.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="http://dmdada.top/2018/06/23/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://dmdada.top/2018/06/23/基数排序/</id>
    <published>2018-06-23T14:15:09.000Z</published>
    <updated>2018-07-05T14:38:35.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>名词解释：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。<br>历史渊源：基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机(Tabulation Machine)上的贡献。它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p><a id="more"></a><p>第一步<br>以LSD为例，假设原来有一串数值如下所示：<br>73, 22, 93, 43, 55, 14, 28, 65, 39, 81<br>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：<br>0<br>1 81<br>2 22<br>3 73 93 43<br>4 14<br>5 55 65<br>6<br>7<br>8 28<br>9 39<br>第二步<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>81, 22, 73, 93, 43, 14, 55, 65, 28, 39<br>接着再进行一次分配，这次是根据十位数来分配：<br>0<br>1 14<br>2 22 28<br>3 39<br>4 43<br>5 55<br>6 65<br>7 73<br>8 81<br>9 93<br>第三步<br>接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。<br>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</p><p>图解：<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png" alt="这里写图片描述"></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>时间效率 ：设待排序列为n个记录，d个关键码，关键码的取值范围为radix，则进行链式基数排序的时间复杂度为<code>O(d(n+radix))</code>，其中，一趟分配时间复杂度为<code>O(n)</code>，一趟收集时间复杂度为<code>O(radix)</code>，共进行d趟分配和收集。<br>空间效率：需要<code>2*radix</code>个指向队列的辅助空间，以及用于静态链表的n个指针故为<code>O(2*radix)</code></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Maxbit</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>; <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (arr[i]&gt;p)</span><br><span class="line">&#123;</span><br><span class="line">p *= <span class="number">10</span>;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = Maxbit(arr, num);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *tmp = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line"><span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">count[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">&#123;</span><br><span class="line">k = (arr[j] / index) % <span class="number">10</span>;</span><br><span class="line">count[k]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">count[j] = count[j - <span class="number">1</span>] + count[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = num - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">k = (arr[j] / index) % <span class="number">10</span>;</span><br><span class="line">tmp[count[k] - <span class="number">1</span>] = arr[j];</span><br><span class="line">count[k]--;</span><br><span class="line">&#125;</span><br><span class="line">index *= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">&#123;</span><br><span class="line">arr[j] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] tmp;</span><br><span class="line"><span class="keyword">delete</span>[] count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">30</span>,<span class="number">300</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">bucketsort(<span class="built_in">array</span>,num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基数排序&quot;&gt;&lt;a href=&quot;#基数排序&quot; class=&quot;headerlink&quot; title=&quot;基数排序&quot;&gt;&lt;/a&gt;基数排序&lt;/h3&gt;&lt;p&gt;名词解释：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。&lt;br&gt;历史渊源：基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机(Tabulation Machine)上的贡献。它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://dmdada.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://dmdada.top/2018/06/21/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://dmdada.top/2018/06/21/归并排序/</id>
    <published>2018-06-21T14:39:40.000Z</published>
    <updated>2018-07-05T14:38:35.457Z</updated>
    
    <content type="html"><![CDATA[<h3 id="归并排序（Mergesort"><a href="#归并排序（Mergesort" class="headerlink" title="归并排序（Mergesort)"></a>归并排序（Mergesort)</h3><p>名词解释 ：归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br><a id="more"></a></p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>归并排序采用分而治之思想将数组内容划分成许多个单位，使每个单位内序列为有序再合并各个有序的序列。<br>图解如下：<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F1.png" alt="这里写图片描述"></p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述:"></a>算法描述:</h3><p>时间复杂度:<code>O(n log n)</code><br>空间复杂度:<code>O（n)</code><br>算法稳定性：稳定</p><p>算法实现步骤：<br>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。<br>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置。<br>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。<br>重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>实现归并排序首先要实现两个有序数组的合并：<br>算法如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemeryArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> b[], <span class="keyword">int</span> m, <span class="keyword">int</span> c[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j, k;  </span><br><span class="line"></span><br><span class="line">    i = j = k = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; b[j])  </span><br><span class="line">            c[k++] = a[i++];  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            c[k++] = b[j++];   </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)  </span><br><span class="line">        c[k++] = a[i++];  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m)  </span><br><span class="line">        c[k++] = b[j++];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了合并以后就完成了算法的主体，全部实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergetarr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> tmp[])</span><span class="comment">//合并算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line">i = left; k = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">j = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=right )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i]&lt;=arr[j])</span><br><span class="line">&#123;</span><br><span class="line">tmp[k++]=arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">tmp[k++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j&lt;=right)</span><br><span class="line">&#123;</span><br><span class="line">tmp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">arr[left + i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">mergetsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right,<span class="keyword">int</span> tmp[])</span><span class="comment">//归并排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left&lt;right )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">mergetsort(arr,left,mid,tmp);<span class="comment">//左边归并</span></span><br><span class="line">mergetsort(arr, mid+<span class="number">1</span>, right,tmp);<span class="comment">//右边归并</span></span><br><span class="line">mergetarr(arr, left, right, tmp);<span class="comment">//合并左右</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">13</span>,<span class="number">25</span>,<span class="number">14</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">89</span>,<span class="number">56</span>,<span class="number">14</span>,<span class="number">25</span>,<span class="number">58</span>,<span class="number">78</span>,<span class="number">36</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">22</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">mergetsort(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>])<span class="number">-1</span>,p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;归并排序（Mergesort&quot;&gt;&lt;a href=&quot;#归并排序（Mergesort&quot; class=&quot;headerlink&quot; title=&quot;归并排序（Mergesort)&quot;&gt;&lt;/a&gt;归并排序（Mergesort)&lt;/h3&gt;&lt;p&gt;名词解释 ：归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://dmdada.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法的稳定性</title>
    <link href="http://dmdada.top/2018/06/21/%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    <id>http://dmdada.top/2018/06/21/算法的稳定性/</id>
    <published>2018-06-21T09:00:39.000Z</published>
    <updated>2018-07-05T14:38:35.489Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>名词解释：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。</p><h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><p>对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。<br><a id="more"></a><br>举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n &amp;&amp; flag == <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt;arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;                             </span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">temp = a[j];</span><br><span class="line">a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">a[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*此算法本来是稳定的但是如果将判断条件改为a[j].key &gt;=a[j+1].key，</span></span><br><span class="line"><span class="comment">则会影响原来数值相同数据的的位置，就会变成不稳定的排序方法*/</span></span><br></pre></td></tr></table></figure></p><h3 id="常见算法的稳定性分析"><a href="#常见算法的稳定性分析" class="headerlink" title="常见算法的稳定性分析"></a>常见算法的稳定性分析</h3><p>堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。</p><p>其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就 是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。</p><p>八大排序分析：<br>(1)冒泡排序<br>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无 聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。<br>(2)选择排序<br>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。<br>(3)插入排序<br>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。<br>(4)快速排序<br>快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。<br>(5)归并排序<br>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。<br>(6)基数排序<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。<br>(7)希尔排序(shell)<br>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。<br>(8)堆排序<br>我们知道堆的结构是节点i的孩子为2<em>i和2</em>i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p><h3 id="稳定性的意义"><a href="#稳定性的意义" class="headerlink" title="稳定性的意义"></a>稳定性的意义</h3><p>不需要用到稳定性： 如果只是简单的进行数字的排序，那么稳定性将毫无意义，如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧将毫无意义，如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧将毫无意义。</p><p>需要用到稳定性： 排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法，例如要排序的内容是一组原本按照价格高低排序的货物，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的货物依旧保持着价格高低的排序，只有销量不同的才会重新排序，因此如果需求不需要保持初始的排序意义，那么使用稳定性算法和不稳定算法是一样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;排序算法的稳定性&quot;&gt;&lt;a href=&quot;#排序算法的稳定性&quot; class=&quot;headerlink&quot; title=&quot;排序算法的稳定性&quot;&gt;&lt;/a&gt;排序算法的稳定性&lt;/h3&gt;&lt;p&gt;名词解释：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。&lt;/p&gt;
&lt;h3 id=&quot;判断方法&quot;&gt;&lt;a href=&quot;#判断方法&quot; class=&quot;headerlink&quot; title=&quot;判断方法&quot;&gt;&lt;/a&gt;判断方法&lt;/h3&gt;&lt;p&gt;对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://dmdada.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://dmdada.top/2018/06/20/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://dmdada.top/2018/06/20/希尔排序/</id>
    <published>2018-06-20T11:23:08.000Z</published>
    <updated>2018-07-05T14:38:35.495Z</updated>
    
    <content type="html"><![CDATA[<h3 id="希尔排序（Shell’s-Sort"><a href="#希尔排序（Shell’s-Sort" class="headerlink" title="希尔排序（Shell’s Sort)"></a>希尔排序（Shell’s Sort)</h3><p>名词解释：希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>1.插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。<br>2.但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>教科书表达：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2(小于d1）重复上述的分组和排序，直至所取的增量 =1(  &lt;  …&lt; &lt; d2 &lt; d1)，即所有记录放在同一组中进行直接插入排序为止。<br>简单来说：一个书架放着一排书，现在从第一本书起每数X本书，就在那本书上贴红色贴纸，贴完红色贴纸后，再次从第二本书起每数X本书就贴上蓝色贴纸（跟之前颜色不同即可），重复贴纸过程，直到所有书都贴满贴纸。接着对有相同颜色贴纸的书做插入排序。然后撕掉所有贴纸后重新对书进行贴纸，这次则每数Y本书就贴纸（Y &lt; X）,所有书贴满后再进行插入排序。重复贴纸排序、贴纸排序这个过程，直到最后每数1本书就贴纸（也就是每本书都贴同样颜色贴纸），再插入排序为止。<br>话不多说，看图<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt="这里写图片描述"><br><a id="more"></a></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>稳定性：由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。<br>时间复杂度：<code>O(n^2)</code><br>空间复杂度：<code>O(1)</code></p><p>常见排序算法一般按平均时间复杂度分为两类：<br><code>O(n^2)</code>：冒泡排序、选择排序、插入排序<br><code>O(nlogn)</code>：归并排序、快速排序、堆排序<br>1w和10w数据效率如下：</p><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F3.png" alt="这里写代码片"></p><h3 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h3><p>正如我们所知道的希尔排序的增量序列是影响希尔排序效率的最关键因素，至今为止还没有一个最完美的增量序列公式。可究竟应该选取什么样的增量才是最好，目前还是一个数学难题。<br>看如下两个增量序列：<br>n/2、n/4、n/8…1<br>1、3、7…2^k-1<br>第一个序列称为希尔增量序列，使用希尔增量时，希尔排序在最坏情况下的时间复杂度为O(n*n)。<br>第二个序列称为Hibbard增量序列，使用Hibbard增量时，希尔排序在最坏情况下的时间复杂度为O(n^3/2)。　<br>10w数据对比如下图：<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F4.png" alt="这里写图片描述"></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> size)</span><span class="comment">//希尔排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size&lt;=<span class="number">0</span>||arr==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> div = <span class="number">0</span>; <span class="keyword">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (div = size / <span class="number">2</span>; div &gt;= <span class="number">1</span>; div /= <span class="number">2</span>)<span class="comment">//定义增量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; div; i++)<span class="comment">//分成div组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; size; j += div)<span class="comment">//对数据插入排序</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (k = i; k &lt; size - div; k += div)&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[k])</span><br><span class="line">&#123;</span><br><span class="line">swap(arr[j], arr[k]);<span class="comment">//交换数据的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">13</span>,<span class="number">25</span>,<span class="number">14</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">22</span>&#125;;</span><br><span class="line">shellsort(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]));</span><br><span class="line"><span class="comment">/*for (auto it: array)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; it;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;希尔排序（Shell’s-Sort&quot;&gt;&lt;a href=&quot;#希尔排序（Shell’s-Sort&quot; class=&quot;headerlink&quot; title=&quot;希尔排序（Shell’s Sort)&quot;&gt;&lt;/a&gt;希尔排序（Shell’s Sort)&lt;/h3&gt;&lt;p&gt;名词解释：希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。&lt;/p&gt;
&lt;p&gt;希尔排序是基于插入排序的以下两点性质而提出改进方法的：&lt;br&gt;1.插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。&lt;br&gt;2.但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。&lt;/p&gt;
&lt;h3 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h3&gt;&lt;p&gt;教科书表达：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2(小于d1）重复上述的分组和排序，直至所取的增量 =1(  &amp;lt;  …&amp;lt; &amp;lt; d2 &amp;lt; d1)，即所有记录放在同一组中进行直接插入排序为止。&lt;br&gt;简单来说：一个书架放着一排书，现在从第一本书起每数X本书，就在那本书上贴红色贴纸，贴完红色贴纸后，再次从第二本书起每数X本书就贴上蓝色贴纸（跟之前颜色不同即可），重复贴纸过程，直到所有书都贴满贴纸。接着对有相同颜色贴纸的书做插入排序。然后撕掉所有贴纸后重新对书进行贴纸，这次则每数Y本书就贴纸（Y &amp;lt; X）,所有书贴满后再进行插入排序。重复贴纸排序、贴纸排序这个过程，直到最后每数1本书就贴纸（也就是每本书都贴同样颜色贴纸），再插入排序为止。&lt;br&gt;话不多说，看图&lt;br&gt;&lt;img src=&quot;http://pajznqooi.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://dmdada.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://dmdada.top/2018/06/18/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://dmdada.top/2018/06/18/堆排序/</id>
    <published>2018-06-18T14:45:53.000Z</published>
    <updated>2018-07-05T14:38:35.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆排序（-Heap-Sort"><a href="#堆排序（-Heap-Sort" class="headerlink" title="堆排序（ Heap Sort )"></a>堆排序（ Heap Sort )</h3><p>堆排序要用到堆，那什么是堆呢？可以参考我的一博客<a href="https://blog.csdn.net/weibo_dm/article/details/80718839" target="_blank" rel="noopener">什么是堆？</a></p><p>名词解释：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd）和威廉姆斯(J．Williams）在1964年共同发明了著名的堆排序算法。<br><a id="more"></a></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用Heapify实现的。<br>平均性能：<code>O(N*logN)</code></p><p>其他性能:由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。<br>堆排序是就地排序，辅助空间为O(1)。<br>堆排序是不稳定的排序方法（当数组中有相等元素时，堆排序算法对这些元素的处理方法不止一种）。（排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前 和排序后他们的相对位置不发生变化）。</p><h3 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h3><p>1.将无序序列构建成一个堆，根据升序降序需求选择大顶堆（升序）或小顶堆（降序）。<br>2.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端。<br>3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p><p>将堆化为数组：<br><img src="http://pajznqooi.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F.jpg" alt="这里写图片描述"></p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span><span class="comment">//调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> maxIdx = index;</span><br><span class="line"><span class="keyword">if</span> (left&lt;len &amp;&amp; arr[left] &gt; arr[maxIdx]) maxIdx = left;</span><br><span class="line"><span class="keyword">if</span> (right&lt;len &amp;&amp; arr[right] &gt; arr[maxIdx]) maxIdx = right;  <span class="comment">// maxIdx是3个数中最大数的下标</span></span><br><span class="line"><span class="keyword">if</span> (maxIdx != index)                 <span class="comment">// 如果maxidx被更新</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[maxIdx], arr[index]);<span class="comment">//交换</span></span><br><span class="line">adjust(arr, len, maxIdx);       <span class="comment">// 递归调整其他不满足堆性质的部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span><span class="comment">//堆排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="comment">// 对每一个非叶结点进行堆调整(从最后一个非叶结点开始)</span></span><br><span class="line">&#123;</span><br><span class="line">adjust(arr, size, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">swap(arr[<span class="number">0</span>], arr[i]);           <span class="comment">// 将当前最大的放置到数组末尾</span></span><br><span class="line">adjust(arr, i, <span class="number">0</span>);              <span class="comment">// 将未完成排序的部分继续进行堆排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">8</span>] = &#123; <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span> &#125;;</span><br><span class="line">heapSort(<span class="built_in">array</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">/*for (auto it: array)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; it;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://pajznqooi.bkt.clouddn.com/%E5%A0%86%E6%8E%92%E5%BA%8F2.jpg" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堆排序（-Heap-Sort&quot;&gt;&lt;a href=&quot;#堆排序（-Heap-Sort&quot; class=&quot;headerlink&quot; title=&quot;堆排序（ Heap Sort )&quot;&gt;&lt;/a&gt;堆排序（ Heap Sort )&lt;/h3&gt;&lt;p&gt;堆排序要用到堆，那什么是堆呢？可以参考我的一博客&lt;a href=&quot;https://blog.csdn.net/weibo_dm/article/details/80718839&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;什么是堆？
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;名词解释：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &amp;gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd）和威廉姆斯(J．Williams）在1964年共同发明了著名的堆排序算法。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://dmdada.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是堆</title>
    <link href="http://dmdada.top/2018/06/17/%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86/"/>
    <id>http://dmdada.top/2018/06/17/什么是堆/</id>
    <published>2018-06-17T09:36:40.000Z</published>
    <updated>2018-07-05T14:38:35.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h2><p>堆是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。<br>堆的性质：<br>1.堆中某个节点的值总是不大于或不小于其父节点的值。<br>2.堆总是一棵完全二叉树。<br><a id="more"></a></p><h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><p>将根节点最大的堆叫做最大堆或大顶堆，根节点最小的堆叫做最小堆或小顶堆。常见的堆有二叉堆、斐波那契堆等。<br>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。<br>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)<br>若将和此次序列对应的一维数组（即以一维数组作此序列的存储结构）看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。由此，若序列{k1,k2,…,kn}是堆，则堆顶元素（或完全二叉树的根）必为序列中n个元素的最小值（或最大值）。<br>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：<br>大堆：<br><img src="http://pajznqooi.bkt.clouddn.com/2.jpg" alt="网络故障"><br>小堆：<br><img src="http://pajznqooi.bkt.clouddn.com/3.jpg" alt="网络故障"></p><h2 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h2><p>build:建立一个空堆；<br>insert:向堆中插入一个新元素；<br>update：将新元素提升使其符合堆的性质；<br>get：获取当前堆顶元素的值；<br>delete：删除堆顶元素；<br>heapify：使删除堆顶元素的堆再次成为堆。<br>某些堆实现还支持其他的一些操作，如斐波那契堆支持检查一个堆中是否存在某个元素。</p><h2 id="建堆效率"><a href="#建堆效率" class="headerlink" title="建堆效率"></a>建堆效率</h2><p>n个结点的堆，高度d =log2n。根为第0层，则第i层结点个数为2i，考虑一个元素在堆中向下移动的距离。大约一半的结点深度为d-1，不移动（叶）。四分之一的结点深度为d-2，而它们至多能向下移动一层。树中每向上一层，结点的数目为前一层的一半，而子树高度加一。<br>这种算法时间代价为Ο（n)由于堆有log n层深，插入结点、删除普通元素和删除最小元素的平均时间代价和时间复杂度都是Ο（log n）。</p><h2 id="关于堆的操作实现"><a href="#关于堆的操作实现" class="headerlink" title="关于堆的操作实现"></a>关于堆的操作实现</h2><p>在程序中，堆用于动态分配和释放程序所使用的对象。在以下情况中调用堆操作：<br>1.事先不知道程序所需对象的数量和大小。<br>2.对象太大，不适合使用堆栈分配器。<br>堆使用运行期间分配给代码和堆栈以外的部分内存。<br>传统上，操作系统和运行时库随附了堆实现。当进程开始时，操作系统创建称为进程堆的默认堆。如果没有使用其他堆，则使用进程堆分配块。语言运行时库也可在一个进程内创建单独的堆。（例如，C 运行时库创建自己的堆。）除这些专用堆外，应用程序或许多加载的动态链接库 (DLL) 之一也可以创建并使用单独的堆。Win32 提供了一组丰富的 API用于创建和使用专用堆。有关堆函数的优秀教程，请参阅 MSDN 平台 SDK 节点。<br>当应用程序或 DLL 创建专用堆时，这些堆驻留于进程空间中并且在进程范围内是可访问的。某一给定堆分配的任何数据应为同一堆所释放。（从一个堆分配并释放给另一个堆没有意义。）<br>在所有虚拟内存系统中，堆位于操作系统的虚拟内存管理器之上。语言运行时堆也驻留在虚拟内存之上。某些情况下，这些堆在操作系统堆的上层，但语言运行时堆通过分配大的块来执行自己的内存管理。绕开操作系统堆来使用虚拟内存函数可使堆更好地分配和使用块。<br>典型的堆实现由前端分配器和后端分配器组成。前端分配器维护固定大小块的自由列表。当堆收到分配调用后，它尝试从前端列表中查找自由块。如果此操作失败，则堆将被迫从后端（保留和提交虚拟内存）分配一个大块来满足请求。通常的实现具有每个块分配的开销，这花费了执行周期，也减少了可用存储区。<br>单个全局锁可防止多线程同时使用堆。此锁主要用于保护堆数据结构不受多线程的任意访问。当堆操作过于频繁时，此锁会对性能造成负面影响。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">JBMinHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//申请堆空间</span></span><br><span class="line">    T *_minHeap = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> _index,_maxSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    JBMinHeap(<span class="keyword">int</span> maxSize) &#123;</span><br><span class="line">        _maxSize = maxSize;</span><br><span class="line">        _minHeap = <span class="keyword">new</span> T[_maxSize];</span><br><span class="line">        _index = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    JBMinHeap(JBMinHeap &amp;h) &#123;</span><br><span class="line">        _index = h._index;</span><br><span class="line">        _maxSize = h._maxSize;</span><br><span class="line">        _minHeap = <span class="keyword">new</span> T[_maxSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;_maxSize) &#123;</span><br><span class="line">            *_minHeap[i] = *h._minHeap[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~JBMinHeap() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[]_minHeap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取整个最小堆的头部指针</span></span><br><span class="line">    <span class="function">T * <span class="title">getMinHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _minHeap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断堆是不是空的</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _index == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _index++;</span><br><span class="line">        _minHeap[_index] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _index == _maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//堆进行向下调整</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="comment">//队进行向上调整</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjustUp</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="comment">//建堆运算</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMinHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (_index<span class="number">-1</span>)/<span class="number">2</span>;i &gt;<span class="number">-1</span>;i--) &#123;<span class="comment">//直接从倒数第二层 逐层向下调整</span></span><br><span class="line">            adjustDown(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">JBMinHeap</span>&lt;T&gt;:</span>:adjustDown(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index&lt;_index)</span><br><span class="line">    &#123;</span><br><span class="line">        T temp = _minHeap[index];<span class="comment">//将当前索引的位置的值保存下来</span></span><br><span class="line">        <span class="keyword">int</span> oneC = <span class="number">2</span> * index + <span class="number">1</span>;<span class="comment">//获取到两个孩子的位置</span></span><br><span class="line">        <span class="keyword">int</span> twoC = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (oneC == _index) &#123;<span class="comment">//若第一个孩子是整个堆最后一个位置 则直接执行交换操作并结束执行</span></span><br><span class="line">                _minHeap[index] = _minHeap[oneC];</span><br><span class="line">                _minHeap[oneC] = temp;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (twoC &gt;_index) &#123;<span class="comment">//如果第二个孩子的索引位置越界 结束执行</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_minHeap[oneC] &lt;= _minHeap[twoC]) &#123;<span class="comment">//正常情况的数据交互执行</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt; _minHeap[oneC]) &#123;</span><br><span class="line">                _minHeap[index] = _minHeap[oneC];</span><br><span class="line">                _minHeap[oneC] = temp;</span><br><span class="line">                index = oneC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//如果该处索引值已经是比两个孩子小 则结束循环</span></span><br><span class="line">                index = _index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; _minHeap[twoC]) &#123;</span><br><span class="line">                _minHeap[index] = _minHeap[twoC];</span><br><span class="line">                _minHeap[twoC] = temp;</span><br><span class="line">                index = twoC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                index = _index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">JBMinHeap</span>&lt;T&gt;:</span>:adjustUp(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; _index) &#123;<span class="comment">//大于堆的最大值直接return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index&gt;<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T temp = _minHeap[index];</span><br><span class="line">        <span class="keyword">int</span> father = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (father &gt;= <span class="number">0</span>) &#123;<span class="comment">//若果索引没有出界就执行想要的操作</span></span><br><span class="line">            <span class="keyword">if</span> (temp &lt; _minHeap[father]) &#123;</span><br><span class="line">                _minHeap[index] = _minHeap[father];</span><br><span class="line">                _minHeap[father] = temp;</span><br><span class="line">                index=father;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//若果已经是比父亲大 则直接结束循环</span></span><br><span class="line">                index = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//出界就结束循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;堆-heap&quot;&gt;&lt;a href=&quot;#堆-heap&quot; class=&quot;headerlink&quot; title=&quot;堆(heap)&quot;&gt;&lt;/a&gt;堆(heap)&lt;/h2&gt;&lt;p&gt;堆是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。&lt;br&gt;堆的性质：&lt;br&gt;1.堆中某个节点的值总是不大于或不小于其父节点的值。&lt;br&gt;2.堆总是一棵完全二叉树。&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://dmdada.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>空间复杂度</title>
    <link href="http://dmdada.top/2018/06/15/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://dmdada.top/2018/06/15/空间复杂度/</id>
    <published>2018-06-15T15:20:35.000Z</published>
    <updated>2018-07-05T14:38:35.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>  前面刚讲了时间复杂度，有兴趣的去看看<a href="https://blog.csdn.net/weibo_dm/article/details/80710491" target="_blank" rel="noopener">什么是时间复杂度？</a><br>名词解释：空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。</p><h3 id="度量方法"><a href="#度量方法" class="headerlink" title="度量方法"></a>度量方法</h3><p> 类似于 时间复杂度的讨论，一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。空间复杂度(SpaceComplexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\”进行的，是节省存储的算法，有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。<br><a id="more"></a></p><h3 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h3><p>分析一个算法所占用的存储空间要从各方面综合考虑。如对于递归算法来说，一般都比较简短，算法本身所占用的存储空间较少，但运行时需要一个附加堆栈，从而占用较多的临时工作单元；若写成非递归算法，一般可能比较长，算法本身占用的存储空间较多，但运行时将可能需要较少的存储单元。<br>一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。若一个算法为 [2]  递归算法，其空间复杂度为递归所使用的堆栈空间的大小，它等于一次调用所分配的临时存储空间的大小乘以被调用的次数(即为递归调用的次数加1，这个1表示开始进行的一次非递归调用)。算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)；当一个算法的空间复杂度与n成线性比例关系时，可表示为O(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。<br>故一个算的空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。所以它强调的是使用的辅助空间的的大小，而不是指所有的数据所占用的空间。<br>以斐波那契算法为例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>* <span class="title">fib</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    assert(n&gt;=<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>* ptr=<span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[n+<span class="number">1</span>];  </span><br><span class="line">    ptr[<span class="number">0</span>]=<span class="number">0</span>;  </span><br><span class="line">    ptr[<span class="number">1</span>]=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        ptr[i]=ptr[i<span class="number">-1</span>]+ptr[i<span class="number">-2</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ptr;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/*对于这种算法，函数真正执行次数为n-1,所以忽略常数后，时间复杂度为O(n);</span></span><br><span class="line"><span class="comment">因为开辟了n+1个空间，有n+1个辅助空间，所以空间复杂度为O(n).*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    assert(n&gt;=<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> first=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> second=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        ret=first+second;  </span><br><span class="line">        first=second;  </span><br><span class="line">        second=ret;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/*这是非递归的另一种算法，函数真正执行次数依然为n-1,所以忽略常数后，时间复杂度还是O(n);</span></span><br><span class="line"><span class="comment">由于采用变量交换的方式，所以在这里辅助空间个数为一个常数，空间复杂度为O(1).*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    assert(n&gt;=<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> (n&lt;<span class="number">2</span>)?(n):(fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>));  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/*递归算法的时间复杂度计算方法是:递归总次数*每次递归次数；</span></span><br><span class="line"><span class="comment">递归算法的时间复杂度计算方法是：递归深度*每次递归所需的辅助空间个数.</span></span><br><span class="line"><span class="comment">可以得出斐波那契递归算法时间复杂度：O（2^N），空间复杂度为:O(N)*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value=fib(<span class="number">15</span>);  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; value &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    system(<span class="string">"pause"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度与空间复杂度的联系"><a href="#时间复杂度与空间复杂度的联系" class="headerlink" title="时间复杂度与空间复杂度的联系"></a>时间复杂度与空间复杂度的联系</h3><p>对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。算法的时间复杂度和空间复杂度合称为算法的复杂度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;空间复杂度&quot;&gt;&lt;a href=&quot;#空间复杂度&quot; class=&quot;headerlink&quot; title=&quot;空间复杂度&quot;&gt;&lt;/a&gt;空间复杂度&lt;/h3&gt;&lt;p&gt;  前面刚讲了时间复杂度，有兴趣的去看看&lt;a href=&quot;https://blog.csdn.net/weibo_dm/article/details/80710491&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;什么是时间复杂度？
&lt;/a&gt;&lt;br&gt;名词解释：空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。&lt;/p&gt;
&lt;h3 id=&quot;度量方法&quot;&gt;&lt;a href=&quot;#度量方法&quot; class=&quot;headerlink&quot; title=&quot;度量方法&quot;&gt;&lt;/a&gt;度量方法&lt;/h3&gt;&lt;p&gt; 类似于 时间复杂度的讨论，一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。空间复杂度(SpaceComplexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\”进行的，是节省存储的算法，有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://dmdada.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度</title>
    <link href="http://dmdada.top/2018/06/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://dmdada.top/2018/06/15/时间复杂度/</id>
    <published>2018-06-15T15:19:39.000Z</published>
    <updated>2018-07-05T14:38:35.486Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>算法复杂度分为时间复杂度和空间复杂度。其作用： 时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。（算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度）。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。</p><h3 id="时间复杂度计算方法"><a href="#时间复杂度计算方法" class="headerlink" title="时间复杂度计算方法"></a>时间复杂度计算方法</h3><p>1.一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。<br>分析：随着模块n的增大，算法执行的时间的增长率和 f(n) 的增长率成正比，所以 f(n) 越小，算法的时间复杂度越低，算法的效率越高。<br>2.在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级（它的同数量级有以下：1，log2n，n，n log2n ，n的平方，n的三次方，2的n次方，n!），找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数c，则时间复杂度T(n) = O(f(n))。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>循环如下：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">for(i=1; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    for(j=1; j&lt;=n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][j] = 0;//该步骤属于基本操作执行次数：n的平方次</span><br><span class="line">        for(k=1; k&lt;=n; ++k)</span><br><span class="line">        c[i][j] += a[i][k] * b[k][j];//该步骤属于基本操作执行次数：n的三次方次</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//则有，根据上面括号里的同数量级，我们可以确定n的三次方为T（n）的同数量级。</span><br><span class="line">//则有，然后根据 T(n)/f(n) 求极限可得到常数c。</span><br><span class="line">//则该算法的时间复杂度：T(n) = O(n^3) 注：n^3即是n的3次方。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例2</span><br><span class="line">//如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，</span><br><span class="line">//则将并列循环的时间复杂度相加。</span><br><span class="line"></span><br><span class="line">　　for (i=1; i&lt;=n; i++)</span><br><span class="line">　　&#123;</span><br><span class="line">　　x++;</span><br><span class="line">　　&#125;</span><br><span class="line">　　for (i=1; i&lt;=n; i++)</span><br><span class="line">　　&#123;</span><br><span class="line">　　for (j=1; j&lt;=n; j++)</span><br><span class="line">　　&#123;</span><br><span class="line">　　x++;</span><br><span class="line">　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　//第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，</span><br><span class="line">　　//则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。</span><br></pre></td></tr></table></figure></p><p>常见的算法时间复杂度由小到大依次为：<br>Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。Ο(log2n)、Ο(n)、Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者是有效算法，把这类问题称为P类问题，而把后者称为NP问题。但这也只能计算基本的计算时间复杂度，具体的运行还会与硬件有关。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法复杂度&quot;&gt;&lt;a href=&quot;#算法复杂度&quot; class=&quot;headerlink&quot; title=&quot;算法复杂度&quot;&gt;&lt;/a&gt;算法复杂度&lt;/h3&gt;&lt;p&gt;算法复杂度分为时间复杂度和空间复杂度。其作用： 时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。（算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度）。&lt;/p&gt;
&lt;h3 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h3&gt;&lt;p&gt;时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。&lt;/p&gt;
&lt;h3 id=&quot;时间复杂度计算方法&quot;&gt;&lt;a href=&quot;#时间复杂度计算方法&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度计算方法&quot;&gt;&lt;/a&gt;时间复杂度计算方法&lt;/h3&gt;&lt;p&gt;1.一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。&lt;br&gt;分析：随着模块n的增大，算法执行的时间的增长率和 f(n) 的增长率成正比，所以 f(n) 越小，算法的时间复杂度越低，算法的效率越高。&lt;br&gt;2.在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级（它的同数量级有以下：1，log2n，n，n log2n ，n的平方，n的三次方，2的n次方，n!），找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数c，则时间复杂度T(n) = O(f(n))。&lt;/p&gt;
&lt;h4 id=&quot;举例&quot;&gt;&lt;a href=&quot;#举例&quot; class=&quot;headerlink&quot; title=&quot;举例&quot;&gt;&lt;/a&gt;举例&lt;/h4&gt;&lt;p&gt;循环如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://dmdada.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
