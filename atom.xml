<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>邓铭的博客</title>
  
  <subtitle>努力不一定成功，不努力一定不成功！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-25T04:39:24.061Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>邓铭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>指针常量和常量指针的区别</title>
    <link href="http://yoursite.com/2018/05/24/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/05/24/常量指针和指针常量的区别/</id>
    <published>2018-05-24T15:09:09.000Z</published>
    <updated>2018-05-25T04:39:24.061Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>在面试中我们经常会被面试官问到什么是常量指针，什么又是指针常量。可能第一次被问到都会有些懵逼（大神略过）。我今天就来讲一讲这二者的区别。<br>下面开始正题。。。。</p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>指针常量：顾名思义它就是一个常量，但是是指针修饰的。<br>格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * const p //指针常量</span><br></pre></td></tr></table></figure></p><p>在这个例子下定义以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a，b；</span><br><span class="line">int * const p=&amp;a //指针常量</span><br><span class="line">//那么分为一下两种操作</span><br><span class="line">*p=9;//操作成功</span><br><span class="line">p=&amp;b;//操作错误</span><br></pre></td></tr></table></figure></p><p>因为声明了指针常量，说明指针变量不允许修改。如同次指针指向一个地址该地址不能被修改，但是该地址里的内容可以被修改</p><h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h2><p>常量指针：如果在定义指针变量的时候，数据类型前用const修饰，被定义的指针变量就是指向常量的指针变量，指向常量的指针变量称为常量指针，格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int *p = &amp;a; //常量指针</span><br></pre></td></tr></table></figure></p><p>在这个例子下定义以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a，b；</span><br><span class="line"> const int *p=&amp;a //常量指针</span><br><span class="line">//那么分为一下两种操作</span><br><span class="line">*p=9;//操作错误</span><br><span class="line">p=&amp;b;//操作成功</span><br></pre></td></tr></table></figure></p><p>因为常量指针本质是指针，并且这个指针是一个指向常量的指针，指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变。</p><h2 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h2><p>指向常量的指针常量该怎么写？<br>答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int * const b = &amp;a;//指向常量的指针常量</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在面试中我们经常会被面试官问到什么是常量指针，什么又是指针常量。可能第一次被问到都会有些懵逼（大神略过）。我今天就来讲一讲这二者的区别。&lt;br&gt;下面开始正题。。。。&lt;/p&gt;
&lt;h2 id=&quot;指针常量&quot;&gt;&lt;a href=&quot;#指针常量&quot; cl
      
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://yoursite.com/2018/05/23/hello-world/"/>
    <id>http://yoursite.com/2018/05/23/hello-world/</id>
    <published>2018-05-23T01:19:38.000Z</published>
    <updated>2018-05-23T12:45:39.414Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="测试博客"><a href="#测试博客" class="headerlink" title="测试博客"></a>测试博客</h2><h3 id="这是一篇测试博客"><a href="#这是一篇测试博客" class="headerlink" title="这是一篇测试博客"></a>这是一篇测试博客</h3><p>第一次使用github+hexo搭建属于自己的博客.<br>日经过不懈的努力终于搭建好了，我非常开心！！</p><pre><code>2018.5.23   邓铭</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;测试博客&quot;&gt;&lt;a href=&quot;#测试博客&quot; class=&quot;headerlink&quot; title=&quot;测试博客&quot;&gt;&lt;/a&gt;测试博客&lt;/h2&gt;&lt;h3 id=&quot;这是一篇测试博客&quot;&gt;&lt;a href=&quot;#这是一篇测试博客&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="c/c++" scheme="http://yoursite.com/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2018/05/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/23/快速排序/</id>
    <published>2018-05-23T01:19:38.000Z</published>
    <updated>2018-05-23T12:41:15.357Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h3><p>是对冒泡排序的一种改进。快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>官方解释：设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。<br>一趟快速排序的算法是：<br>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。<br>尼玛，这都是啥，想必没有见过这个算法的小可爱，对这个官方解释可能是一脸懵逼。所以我就把这个算法通俗的讲一讲。<br>首先要对一堆数字排序我们必须找到一个基准数。而这个基准数可以是这一堆数字中的任意一个，我们定义两个移动的变量从数组的两头向中间检索。从右往左走的变量找到一个小于基准数后停止，从左往右的的变量找到一个大余基准数后停止然后这两个数就交换一下，直到两个变量相遇后就遍历了整个数组，这时候数字的左边都小于基准数，右边大于基准数。然后把数组分成两部分在执行遍历交换后，就完成排序了。<br><img src="https://img-blog.csdn.net/20180515130753470?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>具体实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void quicksort(int* a, int left, int right)</span><br><span class="line">  &#123;</span><br><span class="line">  int i, j, t, temp;</span><br><span class="line">  if (left&gt;right)</span><br><span class="line">  return;</span><br><span class="line"></span><br><span class="line">  temp = a[left]; //temp中存的就是基准数</span><br><span class="line">  i = left;</span><br><span class="line">  j = right;</span><br><span class="line">  while (i != j)</span><br><span class="line">  &#123;</span><br><span class="line">  //顺序很重要，要先从右边开始找</span><br><span class="line">  while (a[j] &gt;= temp &amp;&amp; i&lt;j)</span><br><span class="line">  j--;</span><br><span class="line">  //再找右边的</span><br><span class="line">  while (a[i] &lt;= temp &amp;&amp; i&lt;j)</span><br><span class="line">  i++;</span><br><span class="line">  //交换两个数在数组中的位置</span><br><span class="line">  if (i&lt;j)</span><br><span class="line">  &#123;</span><br><span class="line">  t = a[i];</span><br><span class="line">  a[i] = a[j];</span><br><span class="line">  a[j] = t;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //最终将基准数归位</span><br><span class="line">  a[left] = a[i];</span><br><span class="line">  a[i] = temp;</span><br><span class="line">  quicksort(a, left, i - 1);//继续处理左边的，这里是一个递归的过程</span><br><span class="line">  quicksort(a, i + 1, right);//继续处理右边的 ，这里是一个递归的过程</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int main()&#123;</span><br><span class="line">  int arr[10] = &#123; 8, 2, 3, 1, 6, 5, 4, 7, 0, 9 &#125;;</span><br><span class="line">  quicksort(arr, 0, 9);</span><br><span class="line">  for (int i = 0; i &lt; 10; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  cout &lt;&lt; arr[i]&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180515134156903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvX2Rt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;快速排序（Quicksort）&quot;&gt;&lt;a href=&quot;#快速排序（Quicksort）&quot; class=&quot;headerlink&quot; title=&quot;快速排序（Quicksort）&quot;&gt;&lt;/a&gt;快速排序（Quicksort）&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>函数源码</title>
    <link href="http://yoursite.com/2018/05/23/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2-md/"/>
    <id>http://yoursite.com/2018/05/23/测试博客-md/</id>
    <published>2018-05-23T01:19:38.000Z</published>
    <updated>2018-05-23T06:26:38.136Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="strcpy源码："><a href="#strcpy源码：" class="headerlink" title="strcpy源码："></a>strcpy源码：</h3><pre><code>char *strcpy(char *strDes, const char *strSrc)   {       assert((strDes != NULL) &amp;&amp; (strSrc != NULL));       char *address = strDes;       while ((*strDes ++ = *strSrc ++) != &apos;\0&apos;)           NULL;       return address;   </code></pre><p>注意：strcpy只是复制字符串，但不限制复制的数量。很容易造成缓冲溢出，也就是说，不过dest有没有足够的空间来容纳src的字符串，它都会把src指向的字符串全部复制到从dest开始的内存</p><h3 id="strcmp源码："><a href="#strcmp源码：" class="headerlink" title="strcmp源码："></a>strcmp源码：</h3><pre><code>int strcmp(const char *s, const char *t)   {       assert(s != NULL &amp;&amp; t != NULL);       while (*s &amp;&amp; *t &amp;&amp; *s == *t)       {           ++ s;           ++ t;       }       return (*s - *t);   }  </code></pre><h3 id="strcat源码："><a href="#strcat源码：" class="headerlink" title="strcat源码："></a>strcat源码：</h3><pre><code>char *strcat(char *strDes, const char *strSrc)   {    assert((strDes != NULL) &amp;&amp; (strSrc != NULL));       char *address = strDes;       while (*strDes != &apos;\0&apos;)           ++ strDes;       while ((*strDes ++ = *strSrc ++) != &apos;\0&apos;)           NULL;       return address;   }  </code></pre><p>注意：1.不能向形参传递指向字符串常量的指针（本题中dst和src都是指向串常量的指针，字符串常量存储在常量区不能被修改<br>            2.传递的字符数组前一个实参的所分配的内存空间必须足够大</p><h3 id="strlen源码："><a href="#strlen源码：" class="headerlink" title="strlen源码："></a>strlen源码：</h3><pre><code>int strlen(const char *str)   {       assert(str != NULL);       int len = 0;       while (*str ++ != &apos;\0&apos;)           ++ len;       return len;   }  </code></pre><h3 id="strstr源码："><a href="#strstr源码：" class="headerlink" title="strstr源码："></a>strstr源码：</h3><pre><code>char *strstr(const char *strSrc, const char *str)   {       assert(strSrc != NULL &amp;&amp; str != NULL);       const char *s = strSrc;       const char *t = str;       for (; *t != &apos;\0&apos;; ++ strSrc)       {           for (s = strSrc, t = str; *t != &apos;\0&apos; &amp;&amp; *s == *t; ++s, ++t)               NULL;           if (*t == &apos;\0&apos;)               return (char *) strSrc;       }       return NULL;   }  </code></pre><h3 id="strchr源码："><a href="#strchr源码：" class="headerlink" title="strchr源码："></a>strchr源码：</h3><pre><code>char * __cdecl strchr (                      constchar * string,                      int ch                       ){   while (*string &amp;&amp; *string != (char)ch)        string++;   if (*string == (char)ch)       return((char *)string);    return(NULL);}</code></pre><p>断言：assert（表达式）如果表达式的值为假，整个程序将退出，并输出一条错误信息。如果表达式的值为真则继续执行后面的语句，使用这个宏前需要包含头文件assert.h<br>结语：函数就向一个黑盒一样，调用它的人给他输入（调用它本身就是一种输入），然后等待一个理想中的输出或者是相应的操作。调用者是希望我们的这个函数能够非常健壮的让他们利用，那么为了使我们的函数拥有一定的鲁棒性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;strcpy源码：&quot;&gt;&lt;a href=&quot;#strcpy源码：&quot; class=&quot;headerlink&quot; title=&quot;strcpy源码：&quot;&gt;&lt;/a&gt;strcpy源码：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;char *strcpy(cha
      
    
    </summary>
    
    
      <category term="c/c++" scheme="http://yoursite.com/tags/c-c/"/>
    
      <category term="程序源码" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E6%BA%90%E7%A0%81/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
